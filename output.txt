total 543
-rw-r--r-- 1 root root      0 Apr 15  2020 file1
-rw-r--r-- 1 root root 442398 Apr 15  2020 huge
-rw-r--r-- 1 root root 102423 Apr 15  2020 large
-rw-r--r-- 1 root root   3297 Apr 15  2020 small
-rw-r--r-- 1 root root    104 Apr 15  2020 tiny
dev = 3
check: superblock magic = 0xef53  OK
ninodes=1024  nblocks=4096  inode_size=256
inodes_per_block=4  ifactor=2
bmap=18  imap=19  iblk=20
root shareCount=2
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : cat large
pathname=large parameter=

myread: read 1024 char from file descriptor 0
<html>
<body>
<pre>
                  Project Read/Write HELP
                      
Double Indirect Blocks: lbk >= 12 + 256 = 268

            ---------------------------------------------------------------   
i_block[13]=|    D0       |    D1      |    D2      | . . .    |   D255   |
            ---------------------------------------------------------------
            |             |            |                       |          |
lbk         |             |            |
------------|----256------|----256 ----|----256-----|----------|---256-----
|0|1|.......|268|269|.....|            |    blk     | . . .    |          |
---------------------------------------|-----|------|----------------------
                                      lbk    |
                                       |     |
lbk -= (12+256); // lbk count from 0   |     |
		                       |     |
lbk / 256 ===========================>==     |
		                             |
lbk % 256 ---------------------------------->-


1. get i_bloc
myread: read 1024 char from file descriptor 0
k[13] into int buf13[256];  // buf13[ ] = |D0|D1|D2| ...... |

2. dblk = buf13[lbk/256];

3. get dblk into int dbuf[256];          // dbuf[  ] = |256 block numbers|
					    
4. blk = dbuf[lbk % 256];
<html>
<body>
<pre>

CS360 EXAM   NAME________________________________ ID ________________________

         NOTE!!!! WRITE YOUR ANASERS IN THE SPACE PROVIDED ONLY.

1. Assume: char buf[512] contains 4 partitions P1, P2, P3, P4, which begin at
   the byte offset 0x1BE. Each partition is a

       struct partition{ char dummy[8]; int start_sector, nr_sectors; };

(1). Define a partition POINTER and let it point at P3 in buf[] ________________

(2). Print the start_sector of P3: ___________________________________________

2. YOU wrote a myprintf() function before. Consider the following C program:

  --------------------------------------------------------------------------
   int f, g = 123; char *s="string";|   // YOUR myprintf function
   int main(int argc, char *argv[]) |   int myprintf(                      
myread: read 1024 char from file descriptor 0
)
   { int a = 1, b = 2;              |   { char *cp;  int *ip;
     myprintf("%d %d %s",a,b,s);    |   HERE: 
   }                                |   }
  ---------------------------------------------------------------------------
(1). YOUR myprintf() function head is incomplete. Make it complete.

(2). Which of the variables f,g,s,a,b,cp,ip are in a.out file?____ WHY?_________

(3). Execution is at the label HERE: Draw a diagram to show the stack contents
  from HERE to argv of main(). Also, show the STACK FRAME pointer of myprintf()
  

     

(4). While at HERE, how to tell CPU where is the local variable cp?_________
                                    where is the parameter a? ______________

3.(1). Write C statements to define a node structure with the following items:
----------------------------------------------- WRITE your ANSWER HERE ---------
name   : an array of 32 chars;        |
child  : pointer to first child node; |
sibling: pointer to next sibling node;|
-------------------------------------
myread: read 1024 char from file descriptor 0
-|
      Then, define node POINTERS p, q : ___________________________________

(2). Redraw the general tree shown as a BINARY tree by child, sibling pointers
         A                        | 
                                  |
     B   C   D (child of A)       |
                                  |
       E   F   (child of C)       |

(3). Assume: p points at a node X in a BINARY tree, q points at a new node.
     Write C code to add q as a child of X.



(4). Write C code to print the names of all child nodes of X.


4. Assume YOUR sh of LAB2: gets(line); got a command line = CMD a b c > outfile
(1). Write code to fork a child; parent wait for child to die; then repeat gets;


------------------------------ child ------------------------------------------
(2). Write C code to divide the command line in char line[ ] into token strings


(3). Write C code to do > outfile______________________________________________

(4). Assume the CMD file is in the /bin directory. Write C code to execute CMD,
     passi
myread: read 1024 char from file descriptor 0
ng myargv[], env[] as parameters ___________________________________

     For the command line = CMD a b c > outfile, show EXACLY what is myargv[]

(5). Assume command line = cat file | grep print 
     Wrtie C code to handle the pipe symbol |  ________________________
            







5. For the following code segments, write C code for questions (1) and (2).

     int total = 0;  pthread_mutex m; // an intitlaized mutex
     void *func(void *arg){    |     // Write code here for (3) 
   F1:    total += (int)arg;   |
   F2:    pthread_exit(arg);   |
     }
     int main()
     {     pthread_t tid[4];   int status;
     ------------------Write CODE for main thread -----------------------------
(1).   Create 4 threads to execute func(), each with a unique arg value 1 to 4.

(2).   Wait for all 4 threads to JOIN : ___________________________________
     }

(3). Which statement in func() is a Critical Region? ____ WHY?_________________
     Write code to protect the Critical Region =========> in space shown
myread: read 1024 char from file descriptor 0
 above

(4). In PARALLEL Gauss and LU programs, threads use BARRIERs to synchronize.
     What's the difference between threads wait at a barrier and threads JOIN?
YOUR ANSWER:__________________________________________________________________

(5). In Producer-Consumer Problem, threads use what?_______________ to cooperate

6. To solve linear equaltions A*X = B, LU decomposition converts A to A = L*U.
(1). What kind matrix is L?____________________________________________________
     How to solve for Y in L*Y = B?____________________________________________

(2). What kind matrix is U?____________________________________________________
     How to solve for X in U*X = Y?____________________________________________

(3). LC decomposition is better than Gauss elimination, WHY?________________


7. The following functions copy file src to dest, return total # bytes copied

    #define BLK 4096    (Linux file system block size)

int mycp(char *src, char *dest)   | int YOURcp(char *src, char *dest)
{ int n, tota
myread: read 1024 char from file descriptor 0
l=0; char buf[BLK];  | { int n, total=0; char buf[BLK];
 ___ fd = open(src, __________);  |  ____ fp = fopen(src,  _____); // for READ
 ___ gd = open(dest,__________);  |  ____ gp = fopen(dest, _____); // for WRITE
                             


				     
}                                 | } 

(1). Fill in the blanks in the above code lines.
(2). What's the RELATIONSHIP between fopen() and open()?______________________
(3). Write C code to complete the mycp() function in the SPACE shown above.
(4). Even if someone completes YOURcp(), mycp() is better than YOURcp().
     WHY?______________________________________________________________________

8. Given: struct stat mystat; // mystat contains u16 st_mode, u32 st_ctime
(1). Write code to get file information of "myfile": ___________________________

(2). Write code to test whether myfile is a DIR : _____________________________

(3). If st_ctime = 123456789, what does the value mean?_________________________
     Print myfile's st_ctime in CALDENDAR form ___
myread: read 1024 char from file descriptor 0
______________________________
(4). Given: DIR *dp; struct dirent *ep;  opendir(), readdir();
     Write code to print all file names in the Current Directory:




9. TCP/IP Network Programming and CGI:   Assume LAB4-preWork
(1). A TCP server received a line with 3 intgers      a b c from a client by
           char line[256];   read(client_sock, line, 256);
Write code for the server to reply a line containing: a b c SUM=a+b+c (value)


(2). The TCP server can only serve ONE client at a time.
     EXPLAIN: how to modify it to serve multiple clients at the same time?
     

(3). When access the website at SERVER_URL=http://cs360.eecs.wsu.edu/~YOURNAME,
     YOUR webpage is the default HTML file DIR/filename=_______________/________

     The default HTML file contains a HTML FORM:
     &lt;FORM METHOD="POST" ACTION="SERVER_URL/cgi-bin/mycgi.bin"> 
           Entries for user inputs
	   SUBMIT button 
     &lt;/FORM>
When SUBMIT, it sends user inputs to execute a CGI program at the webserver.

(4). How does the
myread: read 1024 char from file descriptor 0
 POST method send user inputs?________________________________
     YOUR CGI program is the file DIR/filename = ___________________/__________ 
     
(5). YOUR CGI program is executed at the webserver by a process with uid=?______
     The process is NOT yours but it can write in YOUR directory. WHY?

(6). YOUR CGI C program has a  printf("Content-type: text/html\n\n"); statement
     What's the puspose of this statement?______________________________________
     EXPLAIN: How does YOUR CGI program generate DYNAMIC webpages:
     
     
     
<TITLE>CS360</TITLE>

<BODY bgcolor="#00CCCC" TEXT="#000000" LINK="#990000" VLINK="#0000FF" ALINK="#33
00FF"> 

<H1>CS360 CLASS NOTES</H1>
<H2>

<p>
<img src="redball.gif" alt ="*">
<A HREF="plansp20.html">Course Plan : Spring, 2020</a>
<!------------ comment line ---------------------------->

<P>
<img src="redball.gif" alt = "*">
<A HREF="ch1.pdf">Notes #1: Introduction to Unix/Linux and MTX</a>
<P>
READing list: 1.8, 1.9, 1.15
<P>
<img src="redball.gif" alt = "*">
Not
myread: read 1024 char from file descriptor 0
es #2: Programming Background: Chapter 2 of Textbook
<P>
READing List: 2.3, 2.4, 2.5, 2.8, 2.9, 2.10, 2.13
<P>
<img src="redball.gif" alt = "*">
<A HREF="pre1.html">LAB#1 Pre-work DUE 1-21-2020 in class</a>
<P>
 
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB1.html">LAB Assignment #1 DUE 1-23-2020</a>
<P>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB1checklist.html">LAB #1 Checklist</a>
<P>

READING List: Chapter 3 of textbook

<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB2pre.html">LAB #2 Pre-Work DUE:1-30-2020 in class</a>
<P>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB2preCheck.html">LAB #2 Pre-Work Check List</a>
<P>

<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB2sp20.html">LAB #2 DUE:2-6-2020 DEMO to TA</a>
<P>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB2check.html">LAB #2 Check List</a>
<P>
  READING List: Chapter 4: 4.1 to 4.6 of textbook:
<P>
  threads creation, threads ID, threads exit, threads join
<P>
  threads synchronization: mutex_lock, deadlock prevention,
     
myread: read 1024 char from file descriptor 0
           condition variables, barriers
<P>
  ADVANCED TOPIC: 4.7: Implementation of User-level threads
<P>
  READING List: Chapter 5: 5.1 to 5.6 of textbook:
<P>
  Hardware Timers and Interrupt processing
<P>
  Timer service functions: gettimeofday, time, times, interval timer
<P>
  User level time commands: time, date
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB3pre.html">LAB #3 Pre-Work: DUE:2-13-2020 in class</a>
<P>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB3.html">LAB #3 DUE:2-20-2020 DEMO</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB3check.html">LAB #3 Check List</a>
<P>
  <H1><font color="red">Midterm Exam date : Thursday, Feb-27-2020</font></H1>
  <H2>
<P>READING List: Chapter 7 File Operations: 7.1-7.2 only (others will be later)
<P>READING List: Chapter 8 System Calls for File Operations: ALL
<P>READING List: Chapter 9 Library I/O Functions: ALL
<P>READING List: Chapter 13 Network Programming: ALL
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB4pre.html">LAB #4 Pre-WORK</
myread: read 1024 char from file descriptor 0
a>
<P>  
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB4preCheck.html">LAB #4 Pre-WORK check list</a>
<P>  
<P>
<img src="redball.gif" alt = "*">
<A HREF="review.html">Review for EXAM</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB4.tcp.html">LAB #4: TCP Programming DUE March 5 2020</a>
<P>  
<P>
<h2> Sh Programming : Chapter 10 of textbook</h2>
<h2>
<A HREF="stats.png"> Distribution of Midterm Exam Scores</a>
<p>
<p>
    
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB4check.html">LAB #4 Check List</a>
<P>  
<P>
<img src="redball.gif" alt = "*">
<A HREF="proj20.html">Project Specification</a>
<P>  
<P>
<img src="redball.gif" alt = "*">
<A HREF="mountroot.html">Project Start: mount_root</a>
<P>
  <h2>Level-1 Functions: samples/LEVEL1</h2>
  <h2>
<P>
<img src="redball.gif" alt = "*">
<A HREF="mkdir_creat.html">HOW TO mkdir_creat</a>
<P>  
<P>
<img src="redball.gif" alt = "*">
<A HREF="rmdir.html">HOW TO rmdir</a>

<P>3-26 ZOOM recording:
<h4>https://wsu.zoom.us/rec/share/xI8yFZrW80hLfoXi9B_zU5ADA
myread: read 1024 char from file descriptor 0
Ynqaaa82nVIq_VZmElqrCc_xkU7C5G3mV_mT1Ga</h4>
<P>  
<H2>
<P>
<img src="redball.gif" alt = "*">
<A HREF="link_unlink.html">HOW TO link_unlink_symlink</a>
<P>  
<P>
<img src="redball.gif" alt = "*">
<A HREF="misc1.html">Misc Level-1 Functions</a>


<H2><font color="red">Level-1 DUE and DEMO: 4-9-2020

Leve-1 Requirements: mkdir, rmdir, link, unlink, symlink
Turn in your Level-1 zip file to TA
<P>
SCP your zip file to YOURNAME@cs360.eecs.wsu.edu:public_html/LEVEL-1/ directory</font>

<P>
<img src="redball.gif" alt = "*">
<A HREF="level-1.demo.html">Level-1 DEMO Instructions</a>
<P>  
<P> 

<P>
  <h2>Level-2 Functions: samples/LEVEL2</h2>
<H2>
<P>
<img src="redball.gif" alt = "*">
<A HREF="open_close.html">HOW TO open_close_lseek</a>
<p>
<H4>3-31 class recording:
<P>
https://wsu.zoom.us/rec/share/usFRJu_e7UVORKvn4U-OW58BQLS1T6a81ydMrPQInR27uLHAj5bVZcVwpHzryEca
<p>
    
4-2-2020 recording:
<P>
https://wsu.zoom.us/rec/share/xOVLArqz9DpJTKfKzlCcSKt8Jdrlaaa8hCVP-fRcxB7H24WHGrOnqYz-3BKbtF-G
<P>
  
4-9-2020 recording:
h
myread: read 1024 char from file descriptor 0
ttps://wsu.zoom.us/rec/share/w51XKZ-z6kVOG42S4WXgUIsAEJ-iT6a8gyNI_fdbyE2UlgJfmDUBKcwZycQwSIgM
<P>
 
4-14 recording:
https://wsu.zoom.us/rec/share/5O1wMLrc8z1OQa-Qr0XmSLYRLtzOeaa81SRK-aAKmEt-1thGxtbKQCcRd1m1_z5M
 

</h4>
<H2>
<P>  
<P>
<img src="redball.gif" alt = "*">
<A HREF="read_ext2.html">HOW TO read_cat</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="dblk.html">Project HELP: Double-Indirect Blocks</a>
<P>  
<img src="redball.gif" alt = "*">
<A HREF="write_ext2.html">HOW TO write_cp</a>
<P>
  <h2>Level-3 Functions</h2>
  <h2>
<P>
<img src="redball.gif" alt = "*">
<A HREF="mount_umount.html">HOW TO mount_umount</a>
<P>  

<html>
<body>
<pre>
                   LAB2 Check List

Use YOUR C program source file in the tests.

// Simple commands
ls -a -l                       : show the ls results of CWD
cat file                       : show file contents

// Choose gedit OR nano OR vi OR emacs as the EDITOR
EDITOR file                    : show you can edit the file

// I/O redirections		   
cat file > out;
myread: read 1024 char from file descriptor 0
 ls -l; cat out : show out file exist and show its contents
cat file >> out; ls -l         : show out file size doubled
cat < file                     : show file contents

// PIPES
cat file | grep printf         : show lines containing printf

cat < file | grep printf > out : show pipe with I/O redirection

cat file | grep printf | more  : two pipes
      
cat file | cat | cat | grep printf : multiple pipes
<html>
<body>
<pre>
                    LAB2pre Check List

1. Outputs show executions of the commands?____________________ %80

 P1: fork    ==> show P1 childList as P2, which is in readyQueue
     switch  ==> switch to run P2
		  
 P2: fork; fork; ==> show P2 childList as P3->P4, which are in readyQueue
     exit        ==> P2 become a ZOMBIE => switch to P1

 P1:                 show P1 childList as P2->P3->P4
 P1: wait        ==> find ZOMBIE P2 and put it into freeList
     wait        ==> P1 should sleep in wait(), until a child becomes ZOMBIE
                    (P1 sleeps, not runable, so switch to
myread: read 1024 char from file descriptor 0
 P3)
		  
 P3: exit        ==> wakeup P1, which will FREE the ZOMBIE P3.

2. Used function pointers to invoke commands? _______________  %20
<html>
<body>
<pre>
                  CS360 LAB #2 Pre-Work
                 DUE: 1-30-2020 in class

1. Copy/paste/RUN Example programs C2.1 to C2.4 in textbook: NO NEED TO TURN IN

2. Download files from ~samples/LAB2pre/:
  (1). type.h, queue.c, t.c, wait.c, s.s
                        
  (2). gcc -m32 t.c s.s  # NOTE: must use -m32 to generate 32-bit code

  (3). Run a.out as demonstrated in class


============================== REQUIREMENTS ===========================
3. Programming Assignment in 3.6:

(1). Modify kfork() to implement the process tree as a BINARY tree.

(2). Implement ksleep(), kwakeup() for process synchronization

(3). Modify kexit() per algorithm in 3.5.1.
     When a proc exits, give away children, if any, to P1.

(4). Implement kwait() as in 3.5.3.

(5). Add a "wait" command to allow (running) proc to wait for a ZOMBIE child

(6). Use function
myread: read 1024 char from file descriptor 0
 pointers to invoke command executions
	       
=========================================================================
              Turn in a hardcopy of your work. 

 Run the command sequence: Use a script file to record YOUR outputs
	       
 P1: fork    ==> show P1 childList as P2, which is in readyQueue
     switch  ==> switch to run P2
		  
 P2: fork; fork; ==> show P2 childList as P3->P4, which are in readyQueue
     exit        ==> P2 become a ZOMBIE => switch to P1

 P1:                 show P1 childList as P2->P3->P4
 P1: wait        ==> find ZOMBIE P2 and put it into freeList
     wait        ==> P1 should sleep in wait(), until a child becomes ZOMBIE
                    (P1 sleeps, not runable, so switch to P3)
		  
 P3: exit        ==> wakeup P1, which will FREE the ZOMBIE P3.

sample solution: ~samples/LAB2pre/solution	       




<html>
<body>
<pre>
                     CS360 LAB3 Check List
		  
1. Run modified C4.5.c program with NTHREAD=2,4: Correct Solution?_____________

2. Run parallel
myread: read 1024 char from file descriptor 0
 LU decomposition program: Correct Solution?____________________
<html>
<body>
<pre>
                CS360 LAB Assignment #3
                 DUE & DEM: 2-20-2020

          Turn in a hard copy of your code with outputs
		
1. Download ~samples/LAB3/c4.5.c
   It solves a system of N linear equations with N threads.
		
   Modify it to do Problem 4.5 in the Problems Section of textbook:
     Input a NTHREADS nmumber, which may be 2,4 or any number<=N
									      
		
2. Download ~samples/LAB3/lu.c
   It solves a system of linear equations by LU decomposition
								
===== Solve system of linear equations by LU decomposition =====

(1). Theory:
      A*X = B
can be solved by decomposing A into L and U, such that
      A = L*U
where L is a  lower triangular matrix with diagonal elements = 1,
              and 0's above the diagnal
      U is an upper triangular matrix with 0's below the diagonal

Rewrite  A*X = B  as  L*U*X = B   OR
                      L*Y   = B   and   U*X = Y

Solve for Y by L*Y = B;  then 
myread: read 1024 char from file descriptor 0
solve for X by U*X = Y

(2). If using Partial Pivoting, which may exchange rows of A, it amounts to
     multiply L*U by a permutation matrix P, so that

	   A = P*L*U   
           A*X = B      becomes                 
       P*L*U*X = B  OR  L*U*X = P*B  because (inverse of P) = P
          
The algorithm of LU decomposition with partial pivoting is shown below:

#define n 8

double a[n,n] = data matrix A
double l[n,n] = lower: initialized to all 0 except L[i][i] = 1.0
double u[n,n] = upper: initilaized to all 0
int    p[n]   = permutation vector; initialized as [0,1,2,,,.N-1]
								
// these are defined as row vectors but used as COLUMN vectors in the equations
double b[n]   = constants vector;
double y[n]   = temporary solution vector; initialied to 0
double x[n]   = solution  vector

                       Algorithm
================================================================
int i,j,k;

for k = 0 to n-1 do{
    max = 0;
    for i = k to n-1 do {
        if max < |a(i,k)|{
           max = |a(i,k)|
myread: read 1024 char from file descriptor 0
;
           j = i;
        }
        if max == 0
           error (singular matrix)

        swap p[k] and p[j]             // exchanged row numbers
        swap row a(k) and row a(j)
        swap l(k,0:k-2) and l(j,0:k-2)

        u(k,k) = a(k,k)
        for i = k+1 to n-1 do{
           l(i,k) = a(i,k)/u(k,k)
           u(k,i) = a(k,i)
        }

        for i = k+1 to n-1 do{
           for j = k+1 to n-1 do{
             a(i,j) = a(i,j) - l(i,k)*u(k,j)
           }
       }
   }

After getting P, L and U, solve L*Y = P*B; then U*X = Y;
		 
============================================================================

                          REQUIREMENT:

Re-write lu.c as a parallel plu.c program for N=8 using N concurrent pthreads.
(HINT: consult program c4.5).








<html>
<body>
<pre>
                 CS360 LAB3 Pre-Work
	        DUE: 2-13-2020 in class
	NOTE: text-edit your answers, NO hand writings
		 
1. Download files from ~samples/LAB3pre/:
                                   ||
                
myread: read 1024 char from file descriptor 0
           c4.2.c c4.3.c c4.4.c

                    REQUIREMENTS
		  
(1). c4.2.c implements quciksort of an integer array by CONCURRENT THREADS

     Write a SEQUENTIAL quicksort program (for the same integer array).

     Run both c4.2.c AND your sequential quicksort program.
     Compare the running time of both programs.

		 
		 

(2). c4.3.c computes the sum of a matrix by CONCURRENT THREADS.
     Each thread computes the partial sum of a row and tries to update
     a global total by its partial sum.

(2).1. Explain what's a Critical Region: __________________________
       How to protect Critial Regions?   __________________________
		 
(2).2. In C4.3, each thread must use the same mutex_lock when updating total.
       WHY?______________________________________________________________
		 
(2).3. Write a SEQUENTIAL program to compute the sum of the same matrix.
       Run both c4.3.c AND your sequential program.
       Compare the running time of both programs.

		 
		 
(3). c4.4.c implements the pro
myread: read 1024 char from file descriptor 0
ducer-consumer problem using CONDITION variables.
	    The program uses a PAIR of producer and consumer threads.
		 
(3).1. Explain how condition variables work ________________________________
		 
(3).2. Modify the main() function to generate one more producer thread.
       Analyze the program logic to predict what would happen? _________________
       Run the modified program to verify YOUR predication: ___________________ 

(3).3. Modify the main() function to generate one more consumer thread.
       Analyze the program logic to predict what would happen? ________________
       Run the modified program to verify YOUR predication: ____________________

		 
<html>
<body>
<pre>
                 CS360 LAB4 pre-work Check List
               PART 2 ONLY: TA will check online
----------------------------------------------------------------------
1. Changed picture?                     %10

2. mkdir work?                          %10

3. ls work?                             %30   

4. cat file work?          
myread: read 1024 char from file descriptor 0
             %20

5. cp file1 file2 work?                 %30
----------------------------------------------------------------------
                                        100<html>
<body bgcolor="#00CCCC" text="#000000">
<pre>
                   CS360 LAB4 Pre-WORK
               DUE: PART 1: 2-18-2020 in class
               Turn in a hardcopy of your code

PART 1 : Network Programming using TCP

Download files from samples/LAB4pre/ :  server.c   client.c
The programs are EXPLAINED and demonstrated in class

Modify client.c to send a line containing two numbers, e.g. 123 456
Modify server.c to compute the SUM of the numbers and reply 123 456 sum=579
============================================================================


		   PART 2: Web Programming

              DUE: Saturday Midnight 2-22-2020
		  
    TA will check YOUR web page to verify the requirements

1. YOUR WEBSITE at cs360.eecs.wsu.edu
   Each of you has a user account on the Linux machine cs360.eecs.wsu.edu
        login name = YOUR last
myread: read 1024 char from file descriptor 0
 name     (lower case only)
        password   = YOUR WSU ID number (no leading 0)

2. Access YOUR website by

        http://cs360.eecs.wsu.edu/~YOURNAME
       
        ------------------------------------
        |    Welcome to YOUR Website       |
        |       ------------------         |
        |       | YOUR PICTURE   |         |
        |       ------------------         |
        | Input command  :  BOX            | 
        | Input filename1:  BOX            |
        | Input filename2:  BOX            | 
        | Submit command :  Submit BOX     |
        ------------------------------------

3. You will NOT like your current picture. Change it.
   In order to let us know you better, please use your OWN (.gif) picture
		   
4. When you click the Submit BOX, it submits the strings you entered to the
   httpd (Apache) server on the cs360.eecs.wsu.edu machine, directing it to 
   execute
             ~kcw/cgi-bin/mycgi.bin 
 
   which echos YOUR inputs and shows another input-submit window again.
myread: read 1024 char from file descriptor 0


5. login to your account. As of now, YOUR home directory contains:
 
        public_html --- index.html 
               |
            cgi-bin ---- mycgi.c util.o

5-1. Modify YOUR public_html/index.html file: CHANGE the line

< FORM METHOD="POST" ACTION="http://cs360.eecs.wsu.edu/~kcw/cgi-bin/mycgi.bin" >

TO

< FORM METHOD="POST" ACTION="http://cs360.eecs.wsu.edu/~YOURNAME/cgi-bin/mycgi.bin" >

5-2. Go to YOUR cgi-bin/ directory. Change the line in mycgi.c file

 printf("&lt;FORM METHOD=\"POST\" ACTION=\"http://cs360.eecs.wsu.edu/~kcw/cgi-bin/mycgi.bin\">"); 

TO

 printf("&lt;FORM METHOD=\"POST\" ACTION=\"http://cs360.eecs.wsu.edu/~YOURNAME/cgi-bin/mycgi.bin\">");

Then run
     cc -o mycgi.bin mycgi.c util.o   # generate YOUR OWN mycgi executable.
     chmod u+s mycgi.bin              # chmod mycgi to a SETUID executable

6. Access YOUR webpage again. Enter command and filenames. Then, Submit.
   It should execute YOUR mycgi program in YOUR cgi-bin/ directory.


<h2>======================= REQUIREMENTS =
myread: read 1024 char from file descriptor 0
==============================</H2>

1. login to your account by

            ssh YOURNAME@cs360.eecs.wsu.edu
            Change YOUR current ugly picture to YOUR pretty picture.

NOTE: in order for us to know you better, please use a REAL picture of you.

2. MODIFY mycgi.c to do the following commands:

     mkdir dirname      // mkdir syscall
     rmdir dirname      // rmdir syscall
     rm    filename     // unlink syscall
     cat   filename     // cat in textbook
     cp    file1 file2  // cp  in textbook
     ls    [directory] <== if no directory, ls CWD // ls code in textbook
 
NOTE: YOUR mycgi.bin program is executed by an Apache process (uid=80). 
In order for the Apache process to write to YOUR directories, you MUST change 
YOUR mycgi.bin to a setuid program by
                    chmod u+s mycgi
When a process executes a setuid program, it temporarily assumes the uid of the
program owner, allowing it to write to the owner's directories.

			   HAVE FUN !!
		   
<html>
<Body bgcolor="#00cccc" text="
myread: read 1024 char from file descriptor 0
#000000">
<pre>

     CS360 Lab Assignment #4 : File Operations across Networks
               
                     MAY WORK IN 2-PERSON TEAMS
                       DUE & DENO : 3-5-2020

              READ Chapter 13.17 Programming Project 1
     
A. OBJECTIVES:
   Network Programming using TCP.
   Unix system calls for file operations.

B. TCP/IP Programs: 
   Download samples/LAB4pre/server.c client.c files, which are the base code
     
C. REQUIREMENTS:
   Modify the server.c/client.c programs to do the following:

     Client : input a command:
              ----------------  
              pwd
              ls   [pathname]
              cd    pathname
              mkdir pathname
              rmdir pathname       
              rm    pathname       (rm pathname)
              get   pathname       (cp pathname to client side)
              put   pathname       (cp pathanme to server side)
              quit                 (Client exits)
           -----------------
           send command to Server.

myread: read 1024 char from file descriptor 0
           receive reply AND results from Server. Display the results

     Also, implement (local) commands
           lcat lpwd, lls, lcd, lmkdir. lrmdir, lrm
     which the Client executes LOCALLY.

     Server: loop:
            get a command from Client;
            perform the command;
            send reply to Client;
            repeat;    
    *************************************************************
    *  OUTPUTS REQUIREMENTS: CONSULT THE POSTED SAMPLE SOLUTION *
    *************************************************************

C. HELP Hints:

(1). Make each command a fixed-length string, e.g. of MAX=256 bytes.
     REASON: a TCP socket contains a "stream" of data. Each read operation
             reads whatever is available in the socket. Using fixed-length 
             items simplifies reading individual command strings.

(2). Assume get filname:

            CLIENT                             SERVER
   -------------------------------    -------------------------------
  send request (get f
myread: read 1024 char from file descriptor 0
ilename)  ====>  stat filename to get type AND SIZE  
  wait for reply               <===   send SIZE=xxxx or BAD 
  if (BAD): next input;               if (BAD): next command
  ====================================================================
  count = 0;                         
  open filename for WRITE             open filename for READ
  while(count < SIZE){                while(n=read(fd, buf, MAX)){
     n = read(socket,buf,MAX); <=====   send n bytes from buf
     count += n;
     write n bytes to file;
  }                                   }      
  close file;                         close file;
  /*******************************************************************/

(3). You figure out the algorithm for put filname

(4). When server starts, set VIRTUAL root to CWD:

     getcwd();       // get CWD into char curdir[ ];
     printf("server : chroot to %s\n", curdir);
     chroot(curdir); // change / to current DIR 

(5). EXTRA CREDITS: 10 points if your server can serve MULTIPLE clients
					
    
myread: read 1024 char from file descriptor 0
                  Sample Solutions
           samples/LAB4/ : server, client, multiServer

<html>
<Body bgcolor="#00cccc" text="#000000">
<H1>CS360 Lab Assignment #2 HELP : sh Simulator</H1>
<pre>
                DUE & DEMO: 2-6-2020

Purpose: Understand how Unix/Linux sh works by using fork/exec/wait/pipe.
         String operations

<h2>REQUIREMENTS</H2>
   Write a C program, mysh, which simulates the Unix sh for command processing.
   Your mysh should run as follows:

------------- PART 1: Single Command with I/O Redirection ---------------

1. Prompt for an input line, which is of the form
          cmd arg1 arg2 arg3 .... argn 
   where cmd is a command.

   Valid commands include "cd", "exit", and ANY Unix binary executables, 
   e.g. echo, ls, date, pwd, cat, cp, mv, cc, vi, emacs, ... you name it !!!


2. Handle simple commands:
     cmd = "cd"   :  chdir(arg1) OR chdir($HOME) if no arg1;
     cmd = "exit" :  exit(1) to terminate;  

   NOTE: chdir(pathname) is a syscall to change CWD.
         $HOME 
myread: read 1024 char from file descriptor 0
is the home directory; YOU must find its value from *env[ ].

3. For all other commands:
      fork a child process;
      wait for the child to terminate;
      print child's exit status code
      continue step 1;

4. Child process: First, assume NO pipe in command line:
   4-1. Handle I/O redirection:
          cmd  arg1 arg2 ...  <  infile    // take inputs from infile
          cmd  arg1 arg2 ...  >  outfile   // send outputs to outfile
          cmd  arg1 arg2 ...  >> outfile   // APPEND outputs to outfile

   4-2. Execute cmd by execve(), passing parameters 
                char *myargv[], char *env[]
        to the cmd file, 
        where myargv[ ] is an array of char * with

              myargv[0]->cmd, 
              myargv[1]->arg1,
              .....
              Ending with NULL pointer

   4-2. NOTE: your myargv[] must be passed correctly, as in
              cmd one two three
        Then in the cmd program, argc=4, myargv[0]="cmd", myargv[1]="one", etc.


------------------ PART 2: Command
myread: read 1024 char from file descriptor 0
s with Pipes ---------------------------

5. After YOUR mysh works for simple commands, extend it to handle PIPE.
   If the command line has a | symbol:
          divide it into head and tail: e.g.

          cmd1 < infile | cmd 2 > outfile
   
   head = "cmd < infile";   tail = "cmd 2 > outfile"

   Then consult the pipe example code in the class notes to see HOW TO 
        create a pipe
        fork a child process to share the pipe
        arrange one process as the pipe writer, and
                the other process as the pipe reader.
        Then, let each process execve() to its command
              (possibly with I/O redirection).

6. ===================== BONUS ====================
   If YOUR mysh can handle MULTIPLE pipes like

           cat file | grep "test" | more
           cat fle  | cat | grep "test" | more
   etc.
   ===============================================

7. For sh scripts files:

   Assume the first line of every sh script begin with
          #! /usr/bin/bash
   open the file fo
myread: read 1024 char from file descriptor 0
r READ;
   read 256 chars from file beginning to a char buf[256];
   close the opened file

   strncmp(buf, "#!", 2) to check whether the first 2 chars are #!;
   if so, cmd = "/usr/bin/bash", myargv[0]="bash", argv[1]="filename";
   Then execve(cmd, myargv, env);


8. SAMPLE SOLUTION:
   
   ~samples/LABb/lab2.bin          (down load and run under Linux)


<html>
<body>
<pre>
                        HOW TO link_unlink_symlink
			<h2>READ Chapter 11.8.6 - 11.8.9</h2>
			
0. POSTED test files in samples directory:

   =========== Project Level-1 ==========
   mountroot  : mount_root; ls, cd, pwd
   mkdir_creat: mkdir, creat
   rmdir      : rmdir
   link_unlink: link, unlink, symlink, readlink
   ======================================


1. link oldFileName newFileName

   creates a file newFileName which has the SAME inode (number) as that of
   oldFileName.


   Example: link     /a/b/c                      /x/y/z ==>
                     /a/b/   datablock           /x/y    data block
                 --------
myread: read 1024 char from file descriptor 0
----------------        -------------------------
                .. .|ino rlen nlen c|...        ....|ino rlen nlen z| ....
                ------|-----------------        ------|------------------
                      |                               |
                    INODE <----------------------------

                i_links_count = 1  <== INCrement i_links_count to 2



(1). get the INODE of /a/b/c into memory: mip->minode[ ]
                                               INODE of /a/b/c
                                               dev,ino
                                               .......

(2). check /a/b/c is a REG or LNK file (link to DIR is NOT allowed).

(3). check /x/y  exists and is a DIR but 'z' does not yet exist in /x/y/

(4). Add an entry [ino rec_len name_len z] to the data block of /x/y/
     This creates /x/y/z, which has the SAME ino as that of /a/b/c

(NOTE: both /a/b/c and /x/y/z must be on the SAME device; 
       link can not be across different devices).

(5). increment the
myread: read 1024 char from file descriptor 0
 i_links_count of INODE by 1

(6). write INODE back to disk      

===========================================================================
2.                     HOW TO unlink

     unlink pathname

(1). get pathname's INODE into memory

(2). verify it's a FILE (REG or LNK), can not be a DIR; 

(3). decrement INODE's i_links_count by 1;

(4). if i_links_count == 0 ==> rm pathname by

        deallocate its data blocks by:

     Write a truncate(INODE) function, which deallocates ALL the data blocks
     of INODE. This is similar to printing the data blocks of INODE.

        deallocate its INODE;
     
(5). Remove childName = basename(pathname) from the parent directory by

        rm_child(parentInodePtr, childName)

     which is the SAME as that in rmdir or unlink file operations.

3. ======================== HOW TO symlink ================================
   symlink oldNAME  newNAME    e.g. symlink /a/b/c /x/y/z

   ASSUME: oldNAME has <= 60 chars, inlcuding the ending NULL byte.

(1). verify oldNAME 
myread: read 1024 char from file descriptor 0
exists (either a DIR or a REG file)
(2). creat a FILE /x/y/z
(3). change /x/y/z's type to LNK (0120000)=(1010.....)=0xA...
(4). write the string oldNAME into the i_block[ ], which has room for 60 chars.
    (INODE has 24 unused bytes after i_block[]. So, up to 84 bytes for oldNAME) 

     set /x/y/z file size = number of chars in oldName

(5). write the INODE of /x/y/z back to disk.
  

4. readlink pathname: return the contents of a symLink file

(1). get INODE of pathname into a minode[ ].
(2). check INODE is a symbolic Link file.
(3). return its string contents in INODE.i_block[ ].

<html>
<body>
<pre>
            CS 360 NOTES on misc. Level-1 Functions

1. stat filename: 
        struct stat myst;
        get INODE of filename into memory:
            int ino = getino(pathname);
            MINODE *mip = iget(dev, ino);
            copy dev, ino to myst.st_dev, myst.st_ino;
            copy mip->INODE fields to myst fields;
        iput(mip);

2. chmod filename mode: (mode = |rwx|rwx|rwx|, e.g. 0644 in oct
myread: read 1024 char from file descriptor 0
al)
         get INODE of pathname into memroy:
             ino = getino(pathname);
             mip = iget(dev, ino);
             mip->INODE.i_mode |= mode;
         mip->dirty = 1;
         iput(mip);

3. utime filename: (Modify atime of INODE)


4. Many other level-1 functions:
        get INODE into memory;
        copy OR MODIFY INODE fields;
                set dirty flag if modified;
        iput(mip):

=================== Key Components of Level-1 =======================

1. Given a DIR INODE, step through entries in its data block(s) to 
   print all DIR entries = [inode|rec_len|name_len|name]:

         INODE *ip -> INODE
         get_block(dev, ip->i_block, buf[ ]);
         DIR  *dp = (  )buf;
         char *cp = buf;
         while(cp < buf + BLKSIZE){
            use dp-> to access entry's inode, rec_len, name_len, name;
            // print entry or search for an entry by inode number of by name;
          
            cp += dp->rec_len;
            dp = ( )cp;
         }
         ===========
myread: read 1024 char from file descriptor 0
=================================
         INODE *ip -> INODE
         get_block(dev, ip->i_block, buf[ ]);

         DIR  *dp = (  )buf;

         while(dp < buf + BLKSIZE){
            use dp-> to access entry's inode, rec_len, name_len, name;
            // print entry or search for an entry by inode number of by name;
 
            dp = (DIR *)( (char *)dp += dp->rec_len );
         }

 2. int ino = getino(pathname):

(1). tokenize pathname into name[0], name[1], .., name[n-1] with n pointers
  
(2). mip = root if pathname is absolute;
           CWD  if pathname is relative
 
(2). for (int i=0; i < n; i++){
         ino = search(mip, name[i]);

         if (!ino) return 0;

         iput(mip);
         mip = iget(dev, ino) 
     }
     iput(mip);
     return mip->ino;


===============================================================
For LAB#6: Since INODEs are never modified, no need to iput()

     for (int i=0; i < n; i++){
         ino = search(mip, name[i]);
         if (!ino) exit(1);
         mip =
myread: read 1024 char from file descriptor 0
 iget(dev, ino) 
     }
     print INODE's block numbers
==============================================================

3. MINODE *iget(dev, ino):

     return mip->minode[] containing INODE of (dev,ino)

4. iput(MINODE *mip)
 
     wrtie mip->INODE back to disk if refCount==0 AND dirty

5. Convert ino to disk block number and offset by Mailman's algorithm
        
6. Enter an entry [ino, name] into the data block of a parent directory.

7. Delete an entry [ino, name] from the dat block of a parent directory.








     
<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Project Help: HOW TO mkdir_creat</H1>
<h2>DUE and DEMO: 3-26-2020</h2>
<H2>Chapter 11.8.1: mkdir. 11.8.2: creat, 11.8.3</H2>
<Pre>

1. Base code: YOUR mount_root program

ADD these C code:

int tst_bit(char *buf, int bit)
{
  // in Chapter 11.3.1
}

int set_bit(char *buf, int bit)
{
  // in Chapter 11.3.1
}

int ialloc(int dev)  // allocate an inode number from inode_bitmap
{
  int  i;
  char buf[BLKSIZE];

// read i
myread: read 1024 char from file descriptor 0
node_bitmap block
  get_block(dev, imap, buf);

  for (i=0; i < ninodes; i++){
    if (tst_bit(buf, i)==0){
        set_bit(buf, i);
        put_block(dev, imap, buf);
        printf("allocated ino = %d\n", i+1); // bits count from 0; ino from 1
        return i+1;
    }
  }
  return 0;
}

// WRITE YOUR OWN balloc(dev) function, which returns a FREE disk block number

char *disk = "mydisk";    // work with an EMPTY mydisk by mkdisk

int main()
{
(1). open disk for RW; let dev = opened fd

(2). read SUPER block to verify it's an EXT2 FS
     and get ninodes, nblocks   as globals
     printf("ninodes = %d nblocks = %d\n", ninodes, nblocks);

(3). read Group Descriptor 0 to get bmap, imap and inode_start
     printf("bmp=%d imap=%d inode_start = %d\n", bmap, imap, inode_start);

----------------------------------------------------------
(4). init();            // initialize FS data structures
     mount_root();      // mount root

     YOUR ls, cd, pwd commands should be working by now
--------------------------
myread: read 1024 char from file descriptor 0
---------------------------------

                HOW TO mkdir

Assume: command line = "mkdir pathname" 
Extract cmd, pathname from line and save them as globals.

int make_dir()
{
   MINODE *start;		     
1. pahtname = "/a/b/c" start = root;         dev = root->dev;
            =  "a/b/c" start = running->cwd; dev = running->cwd->dev;

2. Let  
     parent = dirname(pathname);   parent= "/a/b" OR "a/b"
     child  = basename(pathname);  child = "c"

   WARNING: strtok(), dirname(), basename() destroy pathname

3. Get minode of parent:

       pino  = getino(parent);
       pip   = iget(dev, pino); 

   Verify : (1). parent INODE is a DIR (HOW?)   AND
            (2). child does NOT exists in the parent directory (HOW?);
               
4. call mymkdir(pip, child);

5. inc parent inodes's link count by 1; 
   touch its atime and mark it DIRTY

6. iput(pip);
     
} 

int mymkdir(MINODE *pip, char *name)
{
   MINODE *mip;

1. pip points at the parent minode[] of "/a/b", name is a string "c" 

2. allocate an i
myread: read 1024 char from file descriptor 0
node and a disk block for the new directory;
        ino = ialloc(dev);    
        bno = balloc(dev);
   DO NOT WORK IN THE DARK: PRINT OUT THESE NUMBERS!!!

3. mip = iget(dev, ino);  load the inode into a minode[] (in order to
   wirte contents to the INODE in memory.

4. Write contents to mip->INODE to make it a DIR INODE.

5. iput(mip); which should write the new INODE out to disk.

  // C CODE of (3), (4) and (5):
  //**********************************************************************
  mip = iget(dev,ino);
  INODE *ip = &mip->INODE;
  Use ip-> to acess the INODE fields:

  i_mode = 0x41ED;		// OR 040755: DIR type and permissions
  i_uid  = running->uid;	// Owner uid 
  i_gid  = running->gid;	// Group Id
  i_size = BLKSIZE;		// Size in bytes 
  i_links_count = 2;	        // Links count=2 because of . and ..
  i_atime = i_ctime = i_mtime = time(0L);  // set to current time
  i_blocks = 2;                	// LINUX: Blocks count in 512-byte chunks 
  i_block[0] = bno;             // new DIR has one data 
myread: read 1024 char from file descriptor 0
block   
  i_block[1] to i_block[14] = 0;
 
  mip->dirty = 1;               // mark minode dirty
  iput(mip);                    // write INODE to disk


//***** create data block for new DIR containing . and .. entries ******
6. Write . and .. entries to a buf[ ] of BLKSIZE

   | entry .     | entry ..     |                                       |
   ----------------------------------------------------------------------
   |ino|12|1|.   |pino|1012|2|..                                        |
   ----------------------------------------------------------------------

   Then, write buf[ ] to the disk block bno;

7. Finally, enter name ENTRY into parent's directory by 
            enter_name(pip, ino, name);


8. int enter_name(MINODE *pip, int myino, char *myname)
{
 For each data block of parent DIR do { // assume: only 12 direct blocks

     if (i_block[i]==0) BREAK;

(1). get parent's data block into a buf[];
   
(2). Each DIR entry has rec_len, name_len. Each entry's ideal length is   

        IDEAL_LEN 
myread: read 1024 char from file descriptor 0
= 4*[ (8 + name_len + 3)/4 ]
 
     All DIR entries in a data block have rec_len = IDEAL_LEN, except the last
     entry. The rec_len of the LAST entry is to the end of the block, which may
     be larger than its IDEAL_LEN.

  --|-4---2----2--|----|---------|--------- rlen ->------------------------|
    |ino rlen nlen NAME|.........|ino rlen nlen|NAME                       |
  --------------------------------------------------------------------------

(3). To enter a new entry of name with n_len, the needed length is

        need_length = 4*[ (8 + n_len + 3)/4 ]  // a multiple of 4

(4). Step to the last entry in a data block (HOW?).
 
    // get parent's data block into a buf[ ] 

       get_block(parent->dev, parent->INODE.i_block[i], buf);
  
       dp = (DIR *)buf;
       cp = buf;

       // step to LAST entry in block: int blk = parent->INODE.i_block[i];
       
       printf("step to LAST entry in data block %d\n", blk);
       while (cp + dp->rec_len < buf + BLKSIZE){

          /******************
myread: read 1024 char from file descriptor 0
*******************************
             print DIR record names while stepping through
          **************************************************/

          cp += dp->rec_len;
          dp = (DIR *)cp;
       } 
       // dp NOW points at last entry in block
  
     Let remain = LAST entry's rec_len - its IDEAL_LENGTH;

     if (remain >= need_length){
        enter the new entry as the LAST entry and trim the previous entry
        to its IDEAL_LENGTH; 
        goto (6) below.
     } 

                             EXAMPLE:

                                 |LAST entry 
  --|-4---2----2--|----|---------|--------- rlen ->------------------------|
    |ino rlen nlen NAME|.........|ino rlen nlen|NAME                       |
  --------------------------------------------------------------------------
                                                    |     NEW entry
  --|-4---2----2--|----|---------|----ideal_len-----|--- rlen=remain ------|
    |ino rlen nlen NAME|.........|ino rlen nlen|NAME|myino rlen 
myread: read 1024 char from file descriptor 0
nlen myname|
  --------------------------------------------------------------------------

}

(5).// Reach here means: NO space in existing data block(s)

  Allocate a new data block; INC parent's isze by BLKSIZE;
  Enter new entry as the first entry in the new data block with rec_len=BLKSIZE.

  |-------------------- rlen = BLKSIZE -------------------------------------
  |myino rlen nlen myname                                                  |
  --------------------------------------------------------------------------

(6).Write data block to disk;
}        


creat_file()
{
  This is ALMOST THE SAME AS mkdir() except : 
   (1). its inode's mode field is set to a REGULAR file, 
        permission bits to (default) rw-r--r--, 
   (2). No data block, so size = 0
   (3). links_count = 1;
   (4). Do NOT increment parent's links_count
} 


int my_creat(MINODE *pip; char *name)
{
  Same as mymkdir() except 
    INODE's file type = 0x81A4 OR 0100644
    links_count = 1
    NO data block, so size = 0
    do NOT in
myread: read 1024 char from file descriptor 0
c parent's link count.
}  

====================================================================

================ development HEPS =============================

1. Your mkdir/creat may trash the disk iamge (by writing to wrong inode or data
   blocks), which will cause problems later even if your program is correct.
   So, it's better to use a FRESH disk image each time during development.

   Write a sh script "run" or "doit" containing: 

      mkfs disk 1440  # renew the disk image file
      mk
      a.out

   Enter run or doit to test YOUR new a.out, so that you use a NEW disk image 
   file each time until YOUR a.out no longer traches the disk image.

2. After running YOUR mkdir/creat commands, you should check the results 
   under LINUX. Write a sh script "s" containing
       
         sudo mount -o loop disk /mnt
         ls -l /mnt
         sudo umount /mnt

   so that s will show the disk contents under LINUX.
==============================================================
  

     
<Title>360 No
myread: read 1024 char from file descriptor 0
tes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Project Help: HOW TO mkdir_creat</H1>
<h2>DUE and DEMO: 3-26-2020</h2>
<H2>Chapter 11.8.1: mkdir. 11.8.2: creat, 11.8.3</H2>
<Pre>

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;fcntl.h>
#include &lt;string.h>
#include &lt;time.h>
#include &lt;libgen.h>
#include &lt;sys/stat.h>
#include &lt;ext2fs/ext2_fs.h>
#include &lt;time.h>

#include "util.c"     // SAME as in mount_root but do not include type.h

// define shorter TYPES, save typing efforts
typedef struct ext2_group_desc  GD;
typedef struct ext2_super_block SUPER;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

#define BLKSIZE 1024
GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

/********** globals *************/
int fd, dev;             // dev = fd    
int ninodes, nblocks;    // ninodes, nblocks numbers from SUPER
int bmap, imap, iblock, inode_start;  // BMAP, IMAP, inodes start block numbers

char gpath[128];    
myread: read 1024 char from file descriptor 0
     // token strings
int  n;                  // number of token strings
char *name[64];          // pointers to token strings

char line[128], command[32], pathname[128];


int tst_bit(char *buf, int bit)
{
  // in Chapter 11.3.1
}

int set_bit(char *buf, int bit)
{
  // in Chapter 11.3.1
}


int decFreeInodes(int dev)
{
  char buf[BLKSIZE];
  // dec free inodes count by 1 in SUPER and GD
  get_block(dev, 1, buf);
  sp = (SUPER *)buf;
  sp->s_free_inodes_count--;
  put_block(dev, 1, buf);

  get_block(dev, 2, buf);
  gp = (GD *)buf;
  gp->bg_free_inodes_count--;
  put_block(dev, 2, buf);
}

// you should already have nblocks, ninodes, imap, bmap as GLOBALs

int ialloc(int dev)  // allocate an inode number
{
  int  i;
  char buf[BLKSIZE];

// read inode_bitmap block
  printf("bmap = %d ", bmp);  
  get_block(dev, imap, buf);

  for (i=0; i < ninodes; i++){
    if (tst_bit(buf, i)==0){
       set_bit(buf,i);
       put_block(dev, imap, buf);
       decFreeInodes();
       printf("allocated ino = %d\n", i+1);

myread: read 1024 char from file descriptor 0
       return i+1;
    }
  }
  return 0;
}

// WRITE YOUR OWN int balloc(dev) function, which returns a FREE disk block number

char *disk = "mydisk";    // work with an EMPTY mydisk first

int main(int argc, char *argv[ ])
{
  int i, ino;
  char buf[BLKSIZE];

  fd = dev = open(disk, O_RDWR);
  if (fd < 0){
    printf("open %s failed\n", disk);
    exit(1);
  }

  // read SUPER block to verify it's an EXT2 FS
  get_block(fd, 1, buf);
  sp = (SUPER *)buf;
  // verfiy it's an EXT2 FS
	   
  ninodes = sp->s_inodes_count;
  nblocks = sp->s_blocks_count;

  printf("ninodes = %d nblocks = %d\n", ninodes, nblocks);

  // read Group Descriptor 0 to get bmap, imap and iblock numbers
  get_block(fd, 2, buf);
  gp = (GD *)buf;

  bmap = gp->bg_block_bitmap;
  imap = gp->bg_inode_bitmap;
  iblock = gp->bg_inode_table;
		     
  inode_start = iblock;
  printf("bmp=%d imap=%d iblock = %d\n", bmap, imap, iblock);

----------------------------------------------------------
3. DO init(); mount_root(); as in LAB #6
----------
myread: read 1024 char from file descriptor 0
-------------------------------------------------
                   HOW TO mkdir

Assume: command line = "mkdir pathname" 
Extract cmd, pathname from line and save them as globals.

int make_dir()
{
   MINODE *start;		     
1. pahtname = "/a/b/c" start = root;         dev = root->dev;
            =  "a/b/c" start = running->cwd; dev = running->cwd->dev;

2. Let  
     parent = dirname(pathname);   parent= "/a/b" OR "a/b"
     child  = basename(pathname);  child = "c"

   WARNING: strtok(), dirname(), basename() destroy pathname

3. Get the In_MEMORY minode of parent:

         pino  = getino(parent);
         pip   = iget(dev, pino); 

   Verify : (1). parent INODE is a DIR (HOW?)   AND
            (2). child does NOT exists in the parent directory (HOW?);
               
4. call mymkdir(pip, child);

5. inc parent inodes's link count by 1; 
   touch its atime and mark it DIRTY

6. iput(pip);
     
} 


int mymkdir(MINODE *pip, char *name)
{
   MINODE *mip;

1. pip points at the parent minode[] of "/a/b", na
myread: read 1024 char from file descriptor 0
me is a string "c") 

2. allocate an inode and a disk block for the new directory;
        ino = ialloc(dev);    
        bno = balloc(dev);
   DO NOT WORK IN THE DARK: PRINT OUT THESE NUMBERS!!!

3. mip = iget(dev, ino);  load the inode into a minode[] (in order to
   wirte contents to the INODE in memory.

4. Write contents to mip->INODE to make it as a DIR INODE.

5. iput(mip); which should write the new INODE out to disk.

  // C CODE of (3), (4) and (5):
  //**********************************************************************
  mip = iget(dev,ino);
  INODE *ip = &mip->INODE;
  Use ip-> to acess the INODE fields:

  i_mode = 0x41ED;		// OR 040755: DIR type and permissions
  i_uid  = running->uid;	// Owner uid 
  i_gid  = running->gid;	// Group Id
  i_size = BLKSIZE;		// Size in bytes 
  i_links_count = 2;	        // Links count=2 because of . and ..
  i_atime = i_ctime = i_mtime = time(0L);  // set to current time
  i_blocks = 2;                	// LINUX: Blocks count in 512-byte chunks 
  i_block[0] = 
myread: read 1024 char from file descriptor 0
bno;             // new DIR has one data block   
  i_block[1] to i_block[14] = 0;
 
  mip->dirty = 1;               // mark minode dirty
  iput(mip);                    // write INODE to disk


//***** create data block for new DIR containing . and .. entries ******
6. Write . and .. entries into a buf[ ] of BLKSIZE

   | entry .     | entry ..                                             |
   ----------------------------------------------------------------------
   |ino|12|1|.   |pino|1012|2|..                                        |
   ----------------------------------------------------------------------

   Then, write buf[ ] to the disk block bno;

7. Finally, enter name ENTRY into parent's directory by 
            enter_name(pip, ino, name);


8. int enter_name(MINODE *pip, int myino, char *myname)
{
 For each data block of parent DIR do { // assume: only 12 direct blocks

     if (i_block[i]==0) BREAK;

(1). get parent's data block into a buf[];
   
(2). EXT2 DIR entries: Each DIR entry has rec_len a
myread: read 1024 char from file descriptor 0
nd name_len. Each entry's
     ideal length is   

        IDEAL_LEN = 4*[ (8 + name_len + 3)/4 ]
 
     All DIR entries in a data block have rec_len = IDEAL_LEN, except the last
     entry. The rec_len of the LAST entry is to the end of the block, which may
     be larger than its IDEAL_LEN.

  --|-4---2----2--|----|---------|--------- rlen ->------------------------|
    |ino rlen nlen NAME|.........|ino rlen nlen|NAME                       |
  --------------------------------------------------------------------------

(3). To enter a new entry of name with n_len, the needed length is

        need_length = 4*[ (8 + n_len + 3)/4 ]  // a multiple of 4

(4). Step to the last entry in a data block (HOW?).
 
    // get parent's ith data block into a buf[ ] 

       get_block(parent->dev, parent->INODE.i_block[i], buf);
  
       dp = (DIR *)buf;
       cp = buf;

       // step to LAST entry in block: int blk = parent->INODE.i_block[i];
       
       printf("step to LAST entry in data block %d\n", blk);
      
myread: read 1024 char from file descriptor 0
 while (cp + dp->rec_len < buf + BLKSIZE){

          /*************************************************
             print DIR record names while stepping through
          **************************************************/

          cp += dp->rec_len;
          dp = (DIR *)cp;
       } 
       // dp NOW points at last entry in block
  
     Let remain = LAST entry's rec_len - its IDEAL_LENGTH;

     if (remain >= need_length){
        enter the new entry as the LAST entry and trim the previous entry
        to its IDEAL_LENGTH; 
        goto (6) below.
     } 

                             EXAMPLE:

                                 |LAST entry 
  --|-4---2----2--|----|---------|--------- rlen ->------------------------|
    |ino rlen nlen NAME|.........|ino rlen nlen|NAME                       |
  --------------------------------------------------------------------------
                                                    |     NEW entry
  --|-4---2----2--|----|---------|----ideal_len-----|--- rlen=remain
myread: read 1024 char from file descriptor 0
 ------|
    |ino rlen nlen NAME|.........|ino rlen nlen|NAME|myino rlen nlen myname|
  --------------------------------------------------------------------------

}

(5).// Reach here means: NO space in existing data block(s)

  Allocate a new data block; INC parent's isze by BLKSIZE;
  Enter new entry as the first entry in the new data block with rec_len=BLKSIZE.

  |-------------------- rlen = BLKSIZE -------------------------------------
  |myino rlen nlen myname                                                  |
  --------------------------------------------------------------------------

(6).Write data block to disk;
}        


creat_file()
{
  This is ALMOST THE SAME AS mkdir() except : 
   (1). its inode's mode field is set to a REGULAR file, 
        permission bits to (default) rw-r--r--, 
   (2). No data block, so size = 0
   (3). links_count = 1;
   (4). Do NOT increment parent's links_count
} 


int my_creat(MINODE *pip; char *name)
{
  Same as mymkdir() except 
    INODE's file type = 0x81A4 OR
myread: read 1024 char from file descriptor 0
 0100644
    links_count = 1
    NO data block, so size = 0
    do NOT inc parent's link count.
}  

====================================================================

================ development HEPS =============================

1. Your mkdir/creat may trash the disk iamge (by writing to wrong inode or data
   blocks), which will cause problems later even if your program is correct.
   So, it's better to use a FRESH disk image each time during development.

   Write a sh script "run" or "doit" containing: 

      mkfs disk 1440  # renew the disk image file
      mk
      a.out

   Enter run or doit to test YOUR new a.out, so that you use a NEW disk image 
   file each time until YOUR a.out no longer traches the disk image.

2. After running YOUR mkdir/creat commands, you should check the results 
   under LINUX. Write a sh script "s" containing
       
         sudo mount -o loop disk /mnt
         ls -l /mnt
         sudo umount /mnt

   so that s will show the disk contents under LINUX.
=============
myread: read 1024 char from file descriptor 0
=================================================
  

     
<Title>360 Assignment</Title>
<Body bgcolor="#00CCCC" text="#000000">

<H1>Assignment #5: Mount Root Operation of FS</H1>
<H1>DUE: 3-12-2020: ABSOLUTELY NO COPYING!!!!</H1>
<H1>Turn in a hard copy in class (one per group)</H1>
<H1>READ Chapter 11.7.3: Mount-Root</H1>
<Pre>
  On top of your hard copy: MARK yes or no
  1. does your ls work?  ls; ls /dir1; ls /dir1/dir3_______________________
  2. does your cd work?  cd /dir1; cd /dir1/dir3 __________________________
  3. does your pwd work? __________________________________________________
  
                    A. REQUIREMENTS: 
=======================================================================
Write a C program to start up the FS project:

1. Initialize FS data structures
2. mount the root file system
3. ls the root directory /
4. cd and pwd
=======================================================================

                     B. HELP information

1. Download files from ~samples/MOUNTROO
myread: read 1024 char from file descriptor 0
T
   README

2. FS Level-1 Data Structures

PROC* running           MINODE *root                          
      |                          |                 ||*********************
      V                          |  MINODE         || 
    PROC[0]                      V minode[64]      ||         Disk dev
 =============  |-pointerToCWD-> ==== 0 =====      ||   ==================
 |nextProcPtr|  |                |  INODE   |      ||   |     INODEs   
 |pid = 0    |  |                | -------  |      ||   ================== 
 |uid = 0    |  |                | (dev,2)  |      || 
 |cwd --------->|                | refCount=3      ||*********************
 |           |                   | dirty=0  |
 |fd[8]      |                   | mounted=1|         
 | ------    |                   | mptr     |
 |           |                   |----------| 
 | - ALL 0 - |                   |==========|         
 | ------    |                   |  INODE   |          
 | ------    |                   | -------  |   
 ========
myread: read 1024 char from file descriptor 0
=====                   | (dev,ino)|   
                                 | refCount |  
   PROC[1]          ^            | dirty    |   
    pid=1           |            |          |
    uid=1           |            |          |
    cwd ----> root minode        |==========|  


3. init() // Initialize data structures of LEVEL-1:
   {
     (1). 2 PROCs, P0 with uid=0, P1 with uid=1, all PROC.cwd = 0
     (2). MINODE minode[128]; all with refCount=0
     (3). MINODE *root = 0;
   }

4. util.c file contains functions: getino(pathname); iget(dev, ino); iput(mip);
   Their usage has the following pattern:

     int ino     = getino(char *pathname);  
     MINODE *mip = iget(dev, ino);

                   // USE the INODE in minode

                   iput(mip)

5. int mount_root()  // mount root file system, establish / and CWDs
   {
      open device for RW (the file descriptor is dev for the opened device)
      read SUPER block to verify it's an EXT2 FS
      record nblocks, ninodes as globals

      read GD0; 
myread: read 1024 char from file descriptor 0
record    bamp, imap, iblock=inodes_start    as globals;
      
      root = iget(dev, 2);    // get root inode into MINODE[0] 
   
      Let cwd of both P0 and P1 point at the root minode (refCount=3)
          P0.cwd = iget(dev, 2); 
          P1.cwd = iget(dev, 2);

      Let running -> P0.
    }


6.int main()
  {
     init();
     mount_root();

     while(1){
        //  ask for a command line = "cmd [pathname]"
        //  cmd=ls:
                ls(pathname);
        //  cmd=cd:
                chdir(pathname);
        //  cmd=pwd
                pwd(running->cwd)
            cmd=quit
                quit();
  }       

<H2>The requirememnts are for YOU to implement ls(), cd(), pwd()</H2>
	    
7. HOW TO ls [pathname]:

   Read Chapter 11.7.3: HOW TO ls and Algorithm of ls

8. HOW TO chdir(char *pathname)

   Read Chapter 11.7.3: HOW TO chdir

9. HOW TO pwd()?    pwd(running->cwd):

   READ Chapter 11.7.3: HOW TO pwd

10.int quit()
   {
     iput() all minodes with (refCount > 0 && DIRTY);
     exit(0
myread: read 1024 char from file descriptor 0
); 
   }

11. Sample Solution: ~samples/MOUNTROOT/solution


                  Review Questions:

1. EXPLAIN in words: What does mount root do? 

2. Given  int ino;              // an INODE number
          INODE thisInode;      // an INODE structure
   Write C code to load the INODE of ino into thisInode

3. Assume: MINODE *mip points at an in-memory DIR minode
                                                  INODE
                                                  dev, ino
                                                  refCount
                                                  dirty

(1). Write C code to print its parent ino:

(2). HOW to find the name string of this DIR INODE?
	      


<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 HELP INFO</H1>
<h2>READ Chapter 11.10</H2>

<Pre>
   
                 HOW TO MOUNT_UMOUNT

ASSUME: newfs is a virtual disk (a Linux file) containing an EXT2 file system.

  RunningPtr
     |                                                  ||******
myread: read 1024 char from file descriptor 0
***************
     |                                                  ||
     V        |---- PointerToCWD ------|                ||
              |                        |                || 
   PROC[ ]    |                        V  MINODE[ ]     ||        root dev
 ===========  |                         ============    ||   ==================
 |nextProcPtr |                         |  INODE   |    ||   |     INODEs   
 |pid, ppid   |                         | -------  |    ||   ================== 
 |uid         |                         | dev,ino  |    || 
 |cwd --------|                         | refCount |    ||*********************
 |                                      | dirty    |
 |fd[10]                                | mounted  |         
 | ------                               | mTablePtr| 
 | ------                               |==========|<--<-        
 | ------                               |  INODE   |    |      
 | ------                               | -------  |    | 
 ===========       
myread: read 1024 char from file descriptor 0
                     | dev,ino  |    |
                                        | refCount |    |
                                        |  dirty   |    |
                                        |  mounted |    |
                                     <--| mTablePtr|    |
                                     |  |==========|    |         
            PointAtRootInode         |                  |
                   ^                 |                  |
                   |                 V                  |
                   |  MountTable[ ]  |                  |       mount DEV
                   |  ------- 0 --------- 1 ---------   |     --------------
                   |  | devNumber    |   DEV      |     |     |  #2_INODE   |
                   |--| MinodePtr    |  MinodePtr-|----->     --------------
                      -------------------------------
                      | deviceName   |    name    |
                      ------------------------------- 

                            Mounting Diagram
myread: read 1024 char from file descriptor 0

 
mount()    /*  Usage: mount filesys mount_point OR mount */
{

1. Ask for filesys (a pathname) and mount_point (a pathname also).
   If mount with no parameters: display current mounted filesystems.

2. Check whether filesys is already mounted: 
   (you may store the name of mounted filesys in the MOUNT table entry). 
   If already mounted, reject;
   else: allocate a free MOUNT table entry (whose dev=0 means FREE).

3. open filesys for RW; use its fd number as the new DEV;
   Check whether it's an EXT2 file system: if not, reject.

4. For mount_point: find its ino, then get its minode:
    call  ino  = getino(pathname);  to get ino:
    call  mip  = iget(DEV, ino);    to get its minode in memory;    

5. Check mount_point is a DIR.  
   Check mount_point is NOT busy (e.g. can't be someone's CWD)

6. Record new DEV in the MOUNT table entry;

  (For convenience, store the filesys name in the Mount table, and also its
                    ninodes, nblocks, bitmap blocks, inode_start block, etc. 
   for quick 
myread: read 1024 char from file descriptor 0
reference)

7. Mark mount_point's minode as being mounted on and let it point at the
   MOUNT table entry, which points back to the mount_point minode.

. return 0 for SUCCESS;
}
  

umount(char *filesys)
{

1. Search the MOUNT table to check filesys is indeed mounted.

2. Check whether any file is still active in the mounted filesys;
      e.g. someone's CWD or opened files are still there,
   if so, the mounted filesys is BUSY ==> cannot be umounted yet.
   HOW to check?      ANS: by checking all minode[].dev

3. Find the mount_point's inode (which should be in memory while it's mounted 
   on).  Reset it to "not mounted"; then 
         iput()   the minode.  (because it was iget()ed during mounting)

4. return 0 for SUCCESS;

}  
  

                  IMPLICATIONS of mount:

Although it is easy to implement mount and umount, there are implications.

With mount, you must modify the getino(pathname) function to support 
"cross mount points". Assume that a file system, newfs, has been mounted on 
the director
myread: read 1024 char from file descriptor 0
y /a/b/c/.  When traversing a pathname, crossing mount point may
occur in both directions.
 
(3).1. Dwonward traversal: When traversing the pathname /a/b/c/x/y, once you 
reach the minode of /a/b/c, you should see that the minode has been mounted on 
(mounted flag=1). Instead of searching for x in the INODE of /a/b/c, you must

    .Follow the minode's mountTable pointer to locate the mount table entry.
    .From the newfs's dev number, iget() its root (ino=2) INODE into memory.
    .Then,continue to search for x/y under the root INODE of newfs.

(3).2. Upward traversal: Assume that you are at the directory /a/b/c/x/ and 
traversing upward, e.g. cd  ../../,  which will cross the mount point at /a/b/c.

When you reach the root INODE of the mounted file system, you should see that it
is a root directory (ino=2) but its dev number differs from that of the real 
root. Using its dev number, you can locate its mount table entry, which points 
to the mounted minode of /a/b/c/. Then, you switch to the minode of /a/b/
myread: read 1024 char from file descriptor 0
c/ and 
continue the upward traversal. Thus, crossing mount point is like a monkey or 
squirrel hoping from one tree to another tree and then back.

(3).3. While traversing a pathname, the dev number may change. You must modify
the getino(pathname) function to change the (global) dev number whenever it 
crosses a mount point. Thus,

        (global) int dev;   // start from root dev OR running->cwd's dev
        int ino = getino(pathname);

essentially returns the (dev, ino) of a pathname.


==============================================================================
Sample solution of FS Project:   samples/projectDemo/
                                            |- a.out
                                            |- mydisk
                                            |- disk
                                            |- README

================ README ===================
Run a.out    (defualt disk image = mydisk)
Run a.out -d (in debugging mode)
Enter menu to see supported commands
=======================
myread: read 1024 char from file descriptor 0
====================

Downnload all the files. Run a.out as shown in README.

<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 Project HELP</H1>
<h2>READ Chapter 11.9.2 - 11.9.3</h2>
<Pre>
                    HOW TO open_close_lseek


Open File Data Structures:

    running
      |                                                  
      |                                                    ||****************** 
    PROC[ ]              OFT[ ]              MINODE[ ]     ||      Disk dev
  ===========    |---> ===========    |--> ============    || ===============
  |ProcPtr  |    |     |mode     |    |    |  INODE   |    || |      INODE   
  |pid, ppid|    |     |refCount |    |    | -------  |    || =============== 
  |uid      |    |     |minodePtr|---->    | dev,ino  |    || 
  |cwd      |    |     |offset   |         | refCount |    ||******************
  |         |    |     ====|======         | dirty    |
  |  fd[10] |    |         |               | mounted  |         
  |
myread: read 1024 char from file descriptor 0
 ------  |    |         |               ============
0 |   ----->|--->|         |
  | ------  |              |   
1 |         |              |
  | ------  |             --------------------------------
2 |         |             |0123456.............
  | ------  |             --------------------------------    
  ===========        logical view of file: a sequence of bytes
                          
   
int open_file()
{
  1. ask for a pathname and mode to open:
         You may use mode = 0|1|2|3 for R|W|RW|APPEND

  2. get pathname's inumber:
         if (pathname[0]=='/') dev = root->dev;          // root INODE's dev
         else                  dev = running->cwd->dev;  
         ino = getino(pathname); 

  3. get its Minode pointer
         mip = iget(dev, ino);  

  4. check mip->INODE.i_mode to verify it's a REGULAR file and permission OK.
      
     Check whether the file is ALREADY opened with INCOMPATIBLE mode:
           If it's already opened for W, RW, APPEND : reject.
           (that is, onl
myread: read 1024 char from file descriptor 0
y multiple R are OK)

  5. allocate a FREE OpenFileTable (OFT) and fill in values:
 
         oftp->mode = mode;      // mode = 0|1|2|3 for R|W|RW|APPEND 
         oftp->refCount = 1;
         oftp->minodePtr = mip;  // point at the file's minode[]

  6. Depending on the open mode 0|1|2|3, set the OFT's offset accordingly:

      switch(mode){
         case 0 : oftp->offset = 0;     // R: offset = 0
                  break;
         case 1 : truncate(mip);        // W: truncate file to 0 size
                  oftp->offset = 0;
                  break;
         case 2 : oftp->offset = 0;     // RW: do NOT truncate file
                  break;
         case 3 : oftp->offset =  mip->INODE.i_size;  // APPEND mode
                  break;
         default: printf("invalid mode\n");
                  return(-1);
      }

   7. find the SMALLEST i in running PROC's fd[ ] such that fd[i] is NULL
      Let running->fd[i] point at the OFT entry

   8. update INODE's time field
         for R: touch atime. 
         f
myread: read 1024 char from file descriptor 0
or W|RW|APPEND mode : touch atime and mtime
      mark Minode[ ] dirty

   9. return i as the file descriptor
}


int truncate(MINODE *mip)
{
  1. release mip->INODE's data blocks;
     a file may have 12 direct blocks, 256 indirect blocks and 256*256
     double indirect data blocks. release them all.
  2. update INODE's time field

  3. set INODE's size to 0 and mark Minode[ ] dirty
}
 
      
int close_file(int fd)
{
  1. verify fd is within range.

  2. verify running->fd[fd] is pointing at a OFT entry

  3. The following code segments should be fairly obvious:
     oftp = running->fd[fd];
     running->fd[fd] = 0;
     oftp->refCount--;
     if (oftp->refCount > 0) return 0;

     // last user of this OFT entry ==> dispose of the Minode[]
     mip = oftp->inodeptr;
     iput(mip);

     return 0; 
}

int lseek(int fd, int position)
{
  From fd, find the OFT entry. 

  change OFT entry's offset to position but make sure NOT to over run either end
  of the file.

  return originalPosition
}

int pfd()
{
  
myread: read 1024 char from file descriptor 0
This function displays the currently opened files as follows:

        fd     mode    offset    INODE
       ----    ----    ------   --------
         0     READ    1234   [dev, ino]  
         1     WRITE      0   [dev, ino]
      --------------------------------------
  to help the user know what files has been opened.
}

====================================================================
          Other Simple FILE DESCRIPTOR operations:

dup(int fd): 
{
  verify fd is an opened descriptor;
  duplicates (copy) fd[fd] into FIRST empty fd[ ] slot;
  increment OFT's refCount by 1;
}

dup2(int fd, int gd):
{
  CLOSE gd fisrt if it's already opened;
  duplicates fd[fd] into fd[gd]; 
}

As you already know, these are needed for I/O redirections

<Title>360 File System HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 Project HELP</H1>
<H2>READ chapter 11.9.4</H2>
<Pre>
                      HOW TO read

int read_file()
{
  Preparations: 
    ASSUME: file is opened for RD or RW;
    ask for a fd  an
myread: read 1024 char from file descriptor 0
d  nbytes to read;
    verify that fd is indeed opened for RD or RW;
    return(myread(fd, buf, nbytes));
}

int myread(int fd, char buf[ ], nbytes) behaves EXACTLY the same as the
read() system call in Unix/Linux. 
The algorithm of myread() can be best explained in terms of the following 
diagram.

(1).  PROC              (2).                          | 
     =======   |--> OFT oft[ ]                        |
     | pid |   |   ============                       |
     | cwd |   |   |mode=flags|                       | 
     | . ..|   |   |minodePtr ------->  minode[ ]     |      BlockDevice
     | fd[]|   |   |refCount=1|       =============   |   ==================
 fd: | .------>|   |offset    |       |  INODE    |   |   | INODE -> blocks|
     |     |       |===|======|       |-----------|   |   ==================
     =======           |              |  dev,ino  |   |
                       |              =============   |
                       |
                       |<------- avil ------->|
    ----
myread: read 1024 char from file descriptor 0
---------------|-----------------------
    |    |    | ...  |lbk  |   |  ...| .......|
    -------------------|---|------------------|-
lbk   0    1 .....     |rem|                   |
                     start                   fsize  
                        
------------------------------------------------------------------------------
                 Data structures for reading file

(1). Assume that fd is opened for READ. 
(2). The offset in the OFT points to the current byte position in the file from
     where we wish to read nbytes. 
(3). To the kernel, a file is just a sequence of contiguous bytes, numbered from
     0 to file_size - 1. As the figure shows, the current byte position, offset
     falls in a LOGICAL block (lbk), which is 

             lbk = offset / BLKSIZE 

     the byte to start read in that logical block is 

             start = offset % BLKSIZE 

     and the number of bytes remaining in the logical block is 

             remain = BLKSIZE - start. 

     At this moment, the 
myread: read 1024 char from file descriptor 0
file has 

             avil = file_size - offset 

     bytes available for read. 

     These numbers are used in the read algorithm.


(4). myread() behaves exactly the same as the read(fd, buf, nbytes) syscall of 
     Unix/Linux. It tries to read nbytes from fd to buf[ ], and returns the 
     actual number of bytes read.

(5). ============ Algorithm and pseudo-code of myread() =======================

int myread(int fd, char *buf, int nbytes)
{
 1. int count = 0;
    avil = fileSize - OFT's offset // number of bytes still available in file.
    char *cq = buf;                // cq points at buf[ ]

 2. while (nbytes && avil){

       Compute LOGICAL BLOCK number lbk and startByte in that block from offset;

             lbk       = oftp->offset / BLKSIZE;
             startByte = oftp->offset % BLKSIZE;
     
       // I only show how to read DIRECT BLOCKS. YOU do INDIRECT and D_INDIRECT
 
       if (lbk < 12){                     // lbk is a direct block
           blk = mip->INODE.i_block[lbk]; // map
myread: read 1024 char from file descriptor 0
 LOGICAL lbk to PHYSICAL blk
       }
       else if (lbk >= 12 && lbk < 256 + 12) { 
            //  indirect blocks 
       }
       else{ 
            //  double indirect blocks
       } 

       /* get the data block into readbuf[BLKSIZE] */
       get_block(mip->dev, blk, readbuf);

       /* copy from startByte to buf[ ], at most remain bytes in this block */
       char *cp = readbuf + startByte;   
       remain = BLKSIZE - startByte;   // number of bytes remain in readbuf[]

       while (remain > 0){
            *cq++ = *cp++;             // copy byte from readbuf[] into buf[]
             oftp->offset++;           // advance offset 
             count++;                  // inc count as number of bytes read
             avil--; nbytes--;  remain--;
             if (nbytes <= 0 || avil <= 0) 
                 break;
       }
 
       // if one data block is not enough, loop back to OUTER while for more ...

   }
   printf("myread: read %d char from file descriptor %d\n", count, fd);  
   return coun
myread: read 1024 char from file descriptor 0
t;   // count is the actual number of bytes read
}

                  OPTMIAZATION OF THE READ CODE:

Instead of reading one byte at a time and updating the counters on each byte,
TRY to calculate the maximum number of bytes available in a data block and
the number of bytes still needed to read. Take the minimum of the two, and read
that many bytes in one operation. Then adjust the counters accordingly. This 
would make the read loops more efficient. 

REQUIRED: optimize the read algorithm in your project.

==========================  HOW TO cat ======================================
cat filename:

   char mybuf[1024], dummy = 0;  // a null char at end of mybuf[ ]
   int n;

1. int fd = open filename for READ;
2. while( n = read(fd, mybuf[1024], 1024)){
       mybuf[n] = 0;             // as a null terminated string
       // printf("%s", mybuf);   <=== THIS works but not good
       spit out chars from mybuf[ ] but handle \n properly;
   } 
3. close(fd);
<TITLE>CS360 Review</TITLE>

<BODY bgcolor="#00CCCC" T
myread: read 1024 char from file descriptor 0
EXT="#000000" LINK="#990000" VLINK="#0000FF" ALINK="#3300FF"> 

<H2>Students Requested to take exam at WSU Access Center: Go to Access Center directly</H2>
<h2><font color="red">Exam has 3 pages, 9 questions; CLOSE book, notes, laptop, iphone</font></h2>
<pre>
LAB1pre Part1: C variables in a.out file: READ Chapter 2.3.1, 2.3.2
 Given a C program with GLOBAL variable, LOCAL variables, which variables are
 in the a.out file?________________ WHY?_______________________________________

LAB1pre Part 2: Stack contents: READ Chapter 2.4.1, 2.4.2, 2.4.3
 Given main(int argc, char *argv[]){ int a=1,b=2; A(a,b); }
       int A(int x, int y){ int u, v; HERE:   }
 Draw a diagram of stack contents from HERE: to argv of main()
 Identify the STACK FRAME of A() function. 

LAB1 Part 1: Partition table: READ LAB1 Assignment AND YOUR LAB1 work
 How did you get MBR of a diskimage into char buf[512]?
 How did you print the type of the 4 partitions?


LAB1 Part 2: myprintf(char *fmt, . . .){ char *cp; int *ip; ....}
 Given print
myread: read 1024 char from file descriptor 0
(u32 x), How did you write printd(int x)?______________________
 Write code to let cp point at the fmt string_______________________
 Write code to let ip point at the first item to be printed on stack__________


LAB2 PreWork Processes: 

  READ Chapter 3.4 on kfork/kexit/sleep/wakeup/wait operations

  What does   kfork() do? ________________________________________________
  What does    exit() do? ________________________________________________
  What does   sleep() do? ______________________________________________
  What does  wakeup() do? ______________________________________________
  What does    wait() do?_______________________________________________

  Write C statements to define a node structure for
          name   : array of 16 chars
          child  : pointer to first child node
          sibling: pointer to next sibling

  Given a GENERAL tree, redraw it as a BINARY tree by child, sibling pointers.
       
Assume: node pointer p points at a node A in a BINARY tree, q points at a new node,
myread: read 1024 char from file descriptor 0
 "name" is a string 
  
  Write C code to 
        ADD q as a child of A    ________________________________________
        print names of ALL child of A___________________________________
        search for a child of A with name; return pointer to the node or NULL

LAB#2: sh simulator <========== VERY VERY IMPORTANT

  READ Chapter 3.8.1: fork()
       Chapter 3.8.3: Process termination
       Chpater 3.8.4: pid = wait(int *status)
       Chapter 3.8.6: execve()
       Chapter 3.9  : I/O redirection
       Chapter 3.10.2: Pipe command processing
      
  For any Linux command, how does the Linux sh find the command?______________
  How did you tokenize PATH into dir[0],dir[1],...?__________________________
  How did you tokenize a command line cmd a b c > out into soken strings?
  i.e. WRITE CODE to show me how to tokenize !!!!!!!!!!
  

  YOUR main sh's logic:
       while(1){
         get a command line;
         tokenize the command line;
         for non-trivial command:
             fork a child; HOW?
myread: read 1024 char from file descriptor 0
______________________________________________
             if (parent){ wait for child to die: HOW_________________________
                          continue;
                        }
             else{ 
                 // YOUR child sh do the command line
             }
       }
   ----------------------------------------------------------------

   CHILD sh: for a command line = CMD a b c d > outfile
     Write code to do > outfile ___________________________________________
               MAY be < 
     Create a pathname = dir[i]/cmd      HOW?____________________________
     Create myargv[ ]:   What are in myargv[ ]?___________________________
 
            int r = execve(pathname, myargv, env);

     What if the execve() call fails? ___________________________________
     What if it succeeds? __________________________________________________

     Assume command line = cat filename | grep print
     Write C code to do the pipe _____________________________________________



LAB3 PreWork:  READ Cha
myread: read 1024 char from file descriptor 0
pter 4 on Concurrent Programming

  What are threeds?________________________________________________________
  Difference between PROCESS and threads is? _______________________________

  How to create a threads? WRITE CODE for it!!!_________________________________
  How does thread terminate? WRITE CODE for it!!!_______________________________

  How to wait to a thread to terminate? Code!!! _______________________________

  What's mutex? _______________________________________________________
  What's a Critical Region?____________________________________________

  STUDY program C4.3: How to protect Critical Region by mutex?________________

  STUDY program C4.4: Producer-Consumer Problem:
        Producer and Comsumer (threads) MUST cooperate. The tool used is WHAT?
       
        HOW does Condition Variables WORK?____________________________________

  What's DEADLOCK? _______________________________________________________


LAB#3 Sequential AND PARALLEL programs of Gauss elimination and LU decompo
myread: read 1024 char from file descriptor 0
sition
      with Partial Pivoting
                       Given A*X = B, solve for X

Gauss Elimination : reduce [A|B] to WHAT kind of matrix?_____________________

LU decomposition  : convert A  to  P*L*U, where P = INVERSE of P.

WHAT'S Partial Pivoting? ______________________________ WHY?___________________


Assume LU method with Partial Pivoting:   A*X = B   becomes 
                                      P*L*U*X = B   OR  
                                        L*U*X = P*B;   

 WHAT's L? _________________________________________________________________
 WAHT's U? __________________________________________________________________

 HOW TO change B to b = P*B? (READ my lu.c code)_____________________________

 HOW to solve A*X = B? by L*U*X = P*B _____________________________________
     READ LAB 3 ASSIGNMENTS and the POSTED lu.c program code.



LAB#3: In the PARALLEL Gauss program C4.5, the pattern is:

       // ALL N threads execute this code:
       for (row=0, row < N-1; row++){
           ONE thr
myread: read 1024 char from file descriptor 0
ead do Partial Pivoting;
           pthread_barrier_wait(&barrier); // WHY?_____________________________ 
           Many threads do row reductions in parallel;
           pthread_barrier_wait(&barrier); // WHY? ___________________________
       }  

WHAT's a barrier?____________________________________________________________

Difference between barrier and threads JOIN?_________________________________
 
LAB#3 SPECIFIC: In the PARALLEL Gauss program C4.5, NTHREADs = A matrix size 8.
      HOW did you ALLOW NTHREDS < 8, e.g. 2 or 4?_____________________________


Chapters 7,8,9: FILE OPERATIONS

  System calls vs. Library I/O functions:
         FOCUS: relationship between Library I/O functions and system calls:
                their DIRFFERENCES and suitability.

  STUDY Chapter 8.6: stat syscall:
        HOW TO use stat call?      CODE !!!! ______________________________
        HOW to test file type?_____________________________________________
        HOW to test file permission bits as rwx?____________
myread: read 1024 char from file descriptor 0
_______________

        What do the time field values mean?___________________________________
        How to converts time into CALDENDAR form?____________________________

  STUDY the ls program code in Chapter 8.6.7 !!!!!
        YOU MUST HAVE DONE this: Use opendir(), readdir() to
                                 get all file names in a directory?____________

  STUDY program Example 9.1: cat file program
        program Example 9.2: cp  file programs  CAREFULLY and try to
                                                UNDERSTAND which is better !!!!
                                                  

LAB4 PreWork: Network Programming AND Web Pages
     Have YOU done LAB4 preWork? if NOT you are in trouble. 

PART 1: When server gets a line containing NUMBERS from client
        HOW did you extract the numbers?_____________________________________
        HOW did you fill a line[] with %d %s or whatever you want 
            to be sent to client?____________________________________________

PART 2: HTTP
myread: read 1024 char from file descriptor 0
, CGI and DYNAMIC webpages:

     What's your default webpage HTML file? DIR_____________/__________________

     The HTML file contains a HTML FORM for submitting user inputs:
         &lt;FORM METHOD="POST", ACTION="................">
           BOXes for user inputs
           SUBMIT
         &lt;/FROM>

What's POST method:       READ Chapter 13 ________________________________
What's the purpose of the ACTION="............" statement?_____________
When click SUBMIT, what heppens?_________________________________________

What's the process uid?________________________ that excutes YOUR CGI program?
What does  chmod u+s program  do? ____________________________________________

READ mcgi.c code in YOUR public_html/cgi-bin/ directory:
     
     int m = getinputs(); return m pairs of user inputs from FORM as
                          entry[i].name, entry[i].value
                          
                          WHAT are entry[i].value?_____________________________

     In LAB4pre, AT MOST 3 user input
myread: read 1024 char from file descriptor 0
s: command : mkdir|rmdir|rm|ls|cat|cp 
                                        file1   :
                                        file2   :
     HOW did you implement mkdir abc 0x755 ?__________________________________
     HOW did you implement cat   filename? ___________________________________
     HOW did you implement ls [dir] __________________________________________

     The mycgi.c program has a line    printf("Content-type: text/html\n\n"); 
     What's the purpose of this statement?___________________________

     What's a DYNAMIC webpage? ______________________________________________
     How does YOUR mycgi-bin generate dynamic webpages?_________________________

     

 

<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>HOWTO rmdir</H1>
<h2>READ: Chapter 11.8.4, 11.8.5</h2>

<Pre>
Assume: command line = "rmdir pathname"
1. Extract cmd, pathname from line and save them as globals.

int rmdir()
{
  2. get inumber of pathname: determine dev, then  
         ino = getin
myread: read 1024 char from file descriptor 0
o(&dev, pathname) 
  3. get its minode[ ] pointer:
         mip = iget(dev, ino);

  4. check ownership 
       super user : OK
       not super user: uid must match
 
  ------------------------------------------------------------------------
  5. check DIR type (HOW?) AND not BUSY (HOW?) AND is empty:

     HOWTO check whether a DIR is empty:
     First, check link count (links_count > 2 means not empty);
     However, links_count == 2 may still have FILEs, so go through its data 
     block(s) to see whether it has any entries in addition to . and ..

     if (NOT DIR || BUSY || not empty): iput(mip); retunr -1;

  6. ASSUME passed the above checks.
     Deallocate its block and inode
     for (i=0; i<12; i++){
         if (mip->INODE.i_block[i]==0)
             continue;
         bdealloc(mip->dev, mip->INODE.i_block[i]);
     }
     idealloc(mip->dev, mip->ino);
     iput(mip); (which clears mip->refCount = 0);
     

  7. get parent DIR's ino and Minode (pointed by pip);
         pip = iget(mip->dev, par
myread: read 1024 char from file descriptor 0
ent's ino); 

  8. remove child's entry from parent directory by

        rm_child(MINODE *pip, char *name);
                 pip->parent Minode, name = entry to remove

  9. decrement pip's link_count by 1; 
     touch pip's atime, mtime fields;
     mark pip dirty;
     iput(pip);
     return SUCCESS;
}

// rm_child(): removes the entry [INO rlen nlen name] from parent's data block.

int rm_child(MINODE *parent, char *name)
{
   1. Search parent INODE's data block(s) for the entry of name

   2. Erase name entry from parent directory by
    
  (1). if LAST entry in block{
                                         |remove this entry   |
          -----------------------------------------------------
          xxxxx|INO rlen nlen NAME |yyy  |zzz                 | 
          -----------------------------------------------------

                  becomes:
          -----------------------------------------------------
          xxxxx|INO rlen nlen NAME |yyy (add zzz len to yyy)  |
          --------------------
myread: read 1024 char from file descriptor 0
---------------------------------

      }
    
  (2). if (first entry in a data block){
          deallocate the data block; modify parent's file size;

          -----------------------------------------------
          |INO Rlen Nlen NAME                           | 
          -----------------------------------------------
          
          Assume this is parent's i_block[i]:
          move parent's NONZERO blocks upward, i.e. 
               i_block[i+1] becomes i_block[i]
               etc.
          so that there is no HOLEs in parent's data block numbers
      }

  (3). if in the middle of a block{
          move all entries AFTER this entry LEFT;
          add removed rec_len to the LAST entry of the block;
          no need to change parent's fileSize;

               | remove this entry   |
          -----------------------------------------------
          xxxxx|INO rlen nlen NAME   |yyy  |zzz         | 
          -----------------------------------------------

                  becomes:
    
myread: read 1024 char from file descriptor 0
      -----------------------------------------------
          xxxxx|yyy |zzz (rec_len INC by rlen)          |
          -----------------------------------------------

      }
    
  3. Write the parent's data block back to disk;
     mark parent minode DIRTY for write-back
}

<html>
<Body bgcolor="#00CCCC" text="#000000">
<pre>

                  CS360 LAB #8 PRE-WORK
                 DUE: Tuesday, 10-15-2019
		  
    TA will check YOUR web page to verify the requirements

================= PART 1: CGI PROGRAMMING: ==============================

1. YOUR WEBSITE at cs360.eecs.wsu.edu
   Each of you has a user account on the Linux machine cs360.eecs.wsu.edu
        login name = YOUR last name     (lower case only)
        password   = YOUR WSU ID number (no leading 0)

2. Access YOUR website by

        http://cs360.eecs.wsu.edu/~YOURNAME
       
        ------------------------------------
        |    Welcome to YOUR Website       |
        |       ------------------         |
        |       | YOUR PICT
myread: read 1024 char from file descriptor 0
URE   |         |
        |       ------------------         |
        | Input command  :  BOX            | 
        | Input filename1:  BOX            |
        | Input filename2:  BOX            | 
        | Submit command :  Submit BOX     |
        ------------------------------------

3. You will NOT like your current picture. live with it OR change it.
   

4. When you click the Submit BOX, it submits the strings you entered to the
   httpd (Apache) server on the cs360.eecs.wsu.edu machine, directing it to 
   execute
             ~kcw/cgi-bin/mycgi.bin 
 
  which echos YOUR inputs and shows another input-submit window again.

5. login to your account. As of now, YOUR home directory contains:
 
        public_html --- index.html 
               |
            cgi-bin ---- mycgi.c util.o

5-1. Modify YOUR public_html/index.html file: CHANGE the line

< FORM METHOD="POST" ACTION="http://cs360.eecs.wsu.edu/~kcw/cgi-bin/mycgi.bin" >

TO

< FORM METHOD="POST" ACTION="http://cs360.eecs.wsu.edu/~YOURNAME/cgi-bi
myread: read 1024 char from file descriptor 0
n/mycgi.bin" >

5-2. Go to YOUR cgi-bin/ directory. Change the line in mycgi.c file

 printf("&lt;FORM METHOD=\"POST\" ACTION=\"http://cs360.eecs.wsu.edu/~kcw/cgi-bin/mycgi.bin\">"); 

TO

 printf("&lt;FORM METHOD=\"POST\" ACTION=\"http://cs360.eecs.wsu.edu/~YOURNAME/cgi-bin/mycgi.bin\">");

Then run
     cc -o mycgi.bin mycgi.c util.o   # generate YOUR OWN mycgi executable.
     chmod u+s mycgi.bin              # chmod mycgi to a SETUID executable

6. Access YOUR webpage again. Enter command and filenames. Then, Submit.
   It should execute YOUR mycgi program in YOUR cgi-bin/ directory.


<h2>======================= REQUIREMENTS ===============================</H2>

1. login to your account by

            ssh YOURNAME@cs360.eecs.wsu.edu
            Change YOUR current ugly picture to YOUR pretty picture.

NOTE: in order for us to know you better, please use a REAL picture of you.

2. MODIFY mycgi.c to do the following commands:

     mkdir dirname
     rmdir dirname
     rm    filename
     cat   filename
 
myread: read 1024 char from file descriptor 0
    cp    file1 file2
     ls    [directory] <== if no directory, ls CWD

NOTE: YOUR mycgi.bin program is executed by an Apache process (uid=80). 
In order for the Apache process to write to YOUR directories, you MUST change 
YOUR mycgi.bin to a setuid program by
                    chmod u+s mycgi
When a process executes a setuid program, it temporarily assumes the uid of the
program owner, allowing it to write to the owner's directories.


			   HAVE FUN !!

			   
3. Download server.c, client.c from samples/LABA4pre/
   In One X window terminal: cc server.c; a.out
   In another X terminal   : cc client.c; a.out

		 REQUIREMAENT:

  Client: input 2 numbers, e.g. 123 456
  Server: Reply 123 456 SUM = 579
			   
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>
<H2>READ Chapter 11.9.5</h2>
<Pre>
                     HOW TO write_cp

int write_file()
{
  1. Preprations:
     ask for a fd   and   a text string to write;

  2. verify fd is indeed opened for WR or 
myread: read 1024 char from file descriptor 0
RW or APPEND mode

  3. copy the text string into a buf[] and get its length as nbytes.

     return(mywrite(fd, buf, nbytes));
}

The algorithm of write_file() can also be explained in terms of the following
figure.

(1).  PROC              (2).                          | 
     =======   |--> OFT oft[ ]                        |
     | pid |   |   ============                       |
     | cwd |   |   |mode=flags|                       | 
     | . ..|   |   |minodePtr ------->  minode[ ]     |      BlockDevice
     | fd[]|   |   |refCount=1|       =============   |   ==================
 fd: | .------>|   |offset    |       |  INODE    |   |   | INODE -> blocks|
     |     |       |===|======|       |-----------|   |   ==================
     =======           |              | dev,inode |   | 
                       |              |  dirty    |   |
                       |              =============   |
                       |
    -------------------|-----------------
    |    |    | ...  |lbk  | ...........
myread: read 1024 char from file descriptor 0
.
    -------------------|-----------------
lbk   0    1 .....     |rem|            |
                     start           fileSize (in INODE)  
                        
------------------------------------------------------------------------------
               Data Structures for write()


mywrite behaves exactly the same as Unix's write(fd, buf, nbytes) syscall.
It writes nbytes from buf[ ] to the file descriptor fd, extending the file 
size as needed.

int mywrite(int fd, char buf[ ], int nbytes) 
{
  while (nbytes > 0 ){

     compute LOGICAL BLOCK (lbk) and the startByte in that lbk:

          lbk       = oftp->offset / BLKSIZE;
          startByte = oftp->offset % BLKSIZE;

    // I only show how to write DIRECT data blocks, you figure out how to 
    // write indirect and double-indirect blocks.

     if (lbk < 12){                         // direct block
        if (ip->INODE.i_block[lbk] == 0){   // if no data block yet

           mip->INODE.i_block[lbk] = balloc(mip->dev);// MUST ALLOCATE a bloc
myread: read 1024 char from file descriptor 0
k
        }
        blk = mip->INODE.i_block[lbk];      // blk should be a disk block now
     }
     else if (lbk >= 12 && lbk < 256 + 12){ // INDIRECT blocks 
              // HELP INFO:
              if (i_block[12] == 0){
                  allocate a block for it;
                  zero out the block on disk !!!!
              }
              get i_block[12] into an int ibuf[256];
              blk = ibuf[lbk - 12];
              if (blk==0){
                 allocate a disk block;
                 record it in i_block[12];
              }
              .......
     }
     else{
            // double indirect blocks */
     }

     /* all cases come to here : write to the data block */
     get_block(mip->dev, blk, wbuf);   // read disk block into wbuf[ ]  
     char *cp = wbuf + startByte;      // cp points at startByte in wbuf[]
     remain = BLKSIZE - startByte;     // number of BYTEs remain in this block

     while (remain > 0){               // write as much as remain allows  
           *cp++ = *cq
myread: read 1024 char from file descriptor 0
++;              // cq points at buf[ ]
           nbytes--; remain--;         // dec counts
           oftp->offset++;             // advance offset
           if (offset > INODE.i_size)  // especially for RW|APPEND mode
               mip->INODE.i_size++;    // inc file size (if offset > fileSize)
           if (nbytes <= 0) break;     // if already nbytes, break
     }
     put_block(mip->dev, blk, wbuf);   // write wbuf[ ] to disk
     
     // loop back to outer while to write more .... until nbytes are written
  }

  mip->dirty = 1;       // mark mip dirty for iput() 
  printf("wrote %d char into file descriptor fd=%d\n", nbytes, fd);           
  return nbytes;
}


                OPTIMIZATION OF write Code

As in read(), the above inner while(remain > 0) loop can be optimized:
Instead of copying one byte at a time and update the control variables on each 
byte, TRY to copy only ONCE and adjust the control variables accordingly.

REQUIRED: Optimize the write() code in your project.

===================
myread: read 1024 char from file descriptor 0
==========================================================

                      HOW TO cp ONE file:

cp src dest:

1. fd = open src for READ;

2. gd = open dst for WR|CREAT; 

   NOTE:In the project, you may have to creat the dst file first, then open it 
        for WR, OR  if open fails due to no file yet, creat it and then open it
        for WR.

3. while( n=read(fd, buf[ ], BLKSIZE) ){
       write(gd, buf, n);  // notice the n in write()
   }

==============================================================================

                    HOW TO mv (rename)
mv src dest:

1. verify src exists; get its INODE in ==> you already know its dev
2. check whether src is on the same dev as src

              CASE 1: same dev:
3. Hard link dst with src (i.e. same INODE number)
4. unlink src (i.e. rm src name from its parent directory and reduce INODE's
               link count by 1).
                
              CASE 2: not the same dev:
3. cp src to dst
4. unlink src
        
============ END OF large FIL
myread: read 23 char from file descriptor 0
E ==================
	

myread: read 0 char from file descriptor 0
cat 102423 bytes
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : cat huge
pathname=huge parameter=

myread: read 1024 char from file descriptor 0
<TITLE>CS360 NOTES</Title>
<Body bgcolor="#FFFFd8" text="#000000">
<H1>CS360 NOTES</H1>
<Pre>
                   360 NOTES on TCP/IP

1. IP stands for Internet Protocol. TCP (Transmission Control Protocol) is a 
   protocol built on top of IP. TCP/IP is the backbone of InterNet. Currently 
   there are 2 versions of IP, known as IPv4 and IPv6. IPv4 uses 32-bit address
   and IPv6 uses 128-bit address. The discussion here is based on IPv4, which 
   is still the predominat version IP in use.

2. Host and IP address:
   A host is a machine that runs IP. Every host is identified by a unique 
   32-bit number called the IP address. For human convenience, this 32-bit 
   number is usually expressed in a "dotted" notation, such as 134.121.64.1  
   A host is also known by a host name, e.g. dns1.eecs.wsu.edu. Host name and 
   IP address are "equivalent" in the sense that, given one, we can find the 
   other (by a Domain-Name-Server, DNS). 

   An IP address is divided into two parts: | networkID | hostID |.
   Dep
myread: read 1024 char from file descriptor 0
ending on networkID, IP addresses are classified as

                                             Decimal Notation:
   Class A : |0xxxxxxx|    24 bits          |    1-126
             | netID  |    host ID          |

   Class B : |10| 14 bits   |   16 bits     |    128-191  
             |   NetID      |   HostID      |
   
   Class C : |110 21 bits            |8 bits|    192-223
             |       netID           |host  |
   ------------------------------------------------------- 
   Class D : |1110x|  multicast group ID    |
   Class E : |11110|  reserved              |

   Data packets intended for an IP address are first sent to a "Router" with 
   the same NetworkID.  That router will forward the packets to a specific
   host by using the HostID.

3. What is IP ?  
   IP is a protocol for sending/receiving data packets between hosts. IP 
   operates in a best-effort manner, i.e. it just sends the packets out, but 
   does NOT guarantee that they will be delivered to their destinations, NOR 
   in orde
myread: read 1024 char from file descriptor 0
r. So, IP may be unreliable. 

4. IP Packet Format:
   An IP packet consists of

      | Header |SourceIP|DestIP|<-----  DATA ---->|
         12       4        4   | upto 64K-24 bytes|
        
   The Header part contains more information, e.g. total length, TCP/UDP, TTL, 
   check-sum for error detection, etc. about the packet so that a receiving
   host would know what to do with the packet. For example, an IP packet is
   simply dropped if its check-sum indicates an error or its TTL has expired.

5. Routers:
   IP hosts may be located far apart. It is usually not possible to send data 
   packets from one host to the other DIRECTLY. "Routers" are special IP hosts 
   that receive and forward packets. Therefore, IP packets may go through 
   many routers, or "hops",  before arriving at a destination. 


6. UDP (User DataGram Protocol)
   UDP operates on top of IP. It is used to send/receive "datagrams". Like
   IP, UDP doe NOT guarantee reliability but it is fast and efficient. It is 
   used in situations 
myread: read 1024 char from file descriptor 0
where reliablility is not essential.
   Example:

      ping mail.wsu.edu     OR    ping 134.121.1.8
   
   ping is a program that sends a UDP packet to a host, which "echo" the UDP 
   packet back to the sender with a round-trip time.
      
7. TCP (Transmission Control Protocol)
   TCP also operates on top of IP but guarantees reliable data transfer. It is
   a connection-oriented protocol for sending/receiving "data streams". 

   A common analogy is that UDP is similar to "telegram" (or USPS), and TCP is
   similar to "telephone".

8. Port Number:
   At each IP host, many applications may be using UDP/TCP at the same time. 
   Each application is uniquely identified by a triple
        Application = (HostIP, Protocol, PortNumber)
   where Protocol is either UDP or TCP, and PortNumber is a unique 2-byte 
   unsiged integer assigned to the application. In order to use UDP or TCP at 
   a host, an application (process) must choose or obtain a PortNumber first. 
   The first 1024 port numbers (0 to 1023) are 
myread: read 1024 char from file descriptor 0
reserved.  

9. Network and Host (byte) Order:
   Machines may use either "big-endian" or "little-endian" byte-ordering. On 
   the "Internet", data are always in "network order", which is "big-endian".

   A set of library functions htons()/htonl(), ntohs()/ntohl() are used to 
   convert data between host-order and network-order. 

10. Server-Client Model:
    In network programming, we typically run a Server at a host first. The 
    Server waits for Client requests and serves the requests. In UDP, the 
    Server simply waits for "datagrams" from a Client. In TCP, the Server 
    waits for a Client to "connect".

    Then, we run the Client from a client host, In UDP, the client simply sends
    each request as a UDP datagram to the Server. Then it receives a reply 
    datagram from the Server. In TCP, the Client requests to connect to the 
    Server first. Then the Server and Client can exchange "continuous" streams
    of data.

In the following, we shall show how to do network programming using TCP.

myread: read 1024 char from file descriptor 0

11. Network Programming:
    Unix (Linux) Kernel provides TCP/IP support. User interface to TCP/IP is
    through "sockets". To the user (program), creating a socket is similar to 
    opening a file for RW. It returns a file descriptor so that the same 
    read()/write() system calls can be used to transfer data.   

12. Sockets Programming

    First, we need the following C structs defined in netdb.h and sys/socket.h

12-1.The socket address data structure:

    struct sockaddr_in {
       u_short        sin_family; /* protocol identifier; usually AF_INET */
       u_short        sin_port;   /* port number. 0 means let kernel choose */
       struct in_addr sin_addr;   /* IP address. INADDR_ANY=the current host.*/
       char           sin_zero[8];}; /* Unused, always zero */
    }

    struct in_addr {
        u_long s_addr;
    };

12-2. The hostent struct in &lt;netdb.h&gt; is as shown (man gethostbyname):
        
        struct hostent {
               char    *h_name;        // DOT name string of h
myread: read 1024 char from file descriptor 0
ost
               char    **h_aliases;    // alias list 
               int     h_addrtype;     // host address type
               int     h_length;       // length of address
               char    **h_addr_list;  // list of addresses (long IP address)
        }
        #define h_addr  h_addr_list[0]  // for backward compatibility 

        // NOTE: h_addr is defined as a char * but it points at the IP_address,
        //       which is a 4-byte number in network (big-endian) order.
        // ulong NIP = *(ulong *)h_addr is the IP_address in network order.
        // ulong HIP = ntohl(NIP) is NIP in host order (INTEL=little-endian).
        // inet_ntoa(NIP) converts NIP to a string in DOT notation.

13. An ECHO Server/Client Program using TCP

    Shown below are the C source files of an ECHO server and a client.
    These files are also available in ~samples/LAB4/. 

    First, run the server at a host as        server [hostname]
    where hostname is either the DNS name or IP address of the host machin
myread: read 1024 char from file descriptor 0
e. 
    If no hostname is given, the default "localhost" (127.0.0.1) will be used.

    The Server first displays the server's hostname, IP address and port number
    Then it waits for a client to connect.

    Next, run the client at another host as   client ServerName ServerPort

    (You may also run both on the SAME host but in separate X-windows).

    After connecting to the server, the client asks the user for an input 
    string, sends it to the server, which simply echos the string back.

    When the client ends (by Enter or Control-C), the server loops back
    to accept another connection, etc.

    The sequence of actions between the server and the client are shown
    in the following diagram.

                                ACTIONS OF 
            Server                                       Client:
   --------------------------------      ---------------------------------
1. Display hostname, IP, Port#      ===> 1. MUST know Server's name|IP,Port#
2. Construct a server_addr struct        2.
myread: read 1024 char from file descriptor 0
 Construct a server_addr struct 
3. Create a TCP socket with Port#        3. Create a TCP socket sock
4. Bind socket to server_addr info             
5. Listen at socket by listen() syscall
6. newsock = accept()               <==  4. connect() to Server via sock
   ------------------------------------------------------------------------
                           Send/Receive Data
7. READ from newsock      <------------------  WRITE to  sock
   WRITE to  newsock      ------------------>  READ from sock
   ------------------------------------------------------------------------
8. loop to 6 to accept next client             close(sock);

//**************************************************************************
//           This Server-Client package uses TCP sockets.
//              This is the ECHO SERVER server.c file. 
//**************************************************************************

#define  MAX 256

#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;

// Define variables:
struct sockaddr
myread: read 1024 char from file descriptor 0
_in  server_addr, client_addr, name_addr;
struct hostent *hp;

int  sock, newsock;                  // socket descriptors
int  serverPort;                     // server port number
int  r, length, n;                   // help variables

// Server initialization code:

int server_init(char *name)
{
   printf("==================== server init ======================\n");   
   // get DOT name and IP address of this host

   printf("1 : get and show server host info\n");
   hp = gethostbyname(name);
   if (hp == 0){
      printf("unknown host\n");
      exit(1);
   }
   printf("    hostname=%s  IP=%s\n",
               hp->h_name,  inet_ntoa(*(long *)hp->h_addr));
  
   //  create a TCP socket by socket() syscall
   printf("2 : create a socket\n");
   sock = socket(AF_INET, SOCK_STREAM, 0);
   if (sock < 0){
      printf("socket call failed\n");
      exit(2);
   }

   printf("3 : fill server_addr with host IP and PORT# info\n");
   // initialize the server_addr structure
   server_addr.sin_family = AF_INET;     
myread: read 1024 char from file descriptor 0
             // for TCP/IP
   server_addr.sin_addr.s_addr = htonl(INADDR_ANY);   // THIS HOST IP address  
   server_addr.sin_port = 0;   // let kernel assign port

   printf("4 : bind socket to host info\n");
   // bind syscall: bind the socket to server_addr info
   r = bind(sock,(struct sockaddr *)&server_addr, sizeof(server_addr));
   if (r < 0){
       printf("bind failed\n");
       exit(3);
   }

   printf("5 : find out Kernel assigned PORT# and show it\n");
   // find out socket port number (assigned by kernel)
   length = sizeof(name_addr);
   r = getsockname(sock, (struct sockaddr *)&name_addr, &length);
   if (r < 0){
      printf("get socketname error\n");
      exit(4);
   }

   // show port number
   serverPort = ntohs(name_addr.sin_port);   // convert to host ushort
   printf("    Port=%d\n", serverPort);

   // listen at port with a max. queue of 5 (waiting clients) 
   printf("6 : server listening ....\n");
   listen(sock, 5);
   printf("===================== init done =======================
myread: read 1024 char from file descriptor 0
\n");
}

main(int argc, char *argv[])
{
   char *hostname, line[MAX];

   if (argc < 2)
      hostname = "localhost";
   else
      hostname = argv[1];
 
   server_init(hostname); 

   // Try to accept a client request
   while(1){
     printf("server: accepting new connection ....\n"); 

     // Try to accept a client connection as descriptor newsock
     length = sizeof(client_addr);
     newsock = accept(sock, (struct sockaddr *)&client_addr, &length);
     if (newsock < 0){
        printf("server: accept error\n");
        exit(1);
     }
     printf("server: accepted a client connection from\n");
     printf("-----------------------------------------------\n");
     printf("        IP=%s  port=%d\n", inet_ntoa(client_addr.sin_addr.s_addr),
                                        ntohs(client_addr.sin_port));
     printf("-----------------------------------------------\n");

     // Processing loop
     while(1){
       n = read(newsock, line, MAX);
       if (n==0){
           printf("server: client died
myread: read 1024 char from file descriptor 0
, server loops\n");
           close(newsock);
           break;
      }
      
      // show the line string
      printf("server: read  n=%d bytes; line=[%s]\n", n, line);

      strcat(line, " ECHO"); // ASSUME line[MAX] still has room for " ECHO"

      // send the echo line to client 
      n = write(newsock, line, MAX);

      printf("server: wrote n=%d bytes; ECHO=[%s]\n", n, line);
      printf("server: ready for next request\n");
    }
 }
}


//*********************** ECHO CLIENT client.c file *************************

#define MAX 256

#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;


// Define variables
struct hostent *hp;              
struct sockaddr_in  server_addr; 

int sock, r;
int SERVER_IP, SERVER_PORT; 

int client_init(char *argv[])
{
  printf("======= clinet init ==========\n");

  printf("1 : get server info\n");
  hp = gethostbyname(argv[1]);
  if (hp==0){
     printf("unknown host %s\n", argv[1]);
     exit(1);
  }

  SERVER_IP   = *(long *)hp->h_addr;

myread: read 1024 char from file descriptor 0
  SERVER_PORT = atoi(argv[2]);

  printf("2 : create a TCP socket\n");
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock<0){
     printf("socket call failed\n");
     exit(2);
  }

  printf("3 : fill server_addr with server's IP and PORT#\n");
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = SERVER_IP;
  server_addr.sin_port = htons(SERVER_PORT);

  // Connect to server
  printf("4 : connecting to server ....\n");
  r = connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
  if (r < 0){
     printf("connect failed\n");
     exit(1);
  }

  printf("5 : connected OK to \007\n"); 
  printf("---------------------------------------------------------\n");
  printf("hostname=%s  IP=%s  PORT=%d\n", 
          hp->h_name, inet_ntoa(SERVER_IP), SERVER_PORT);
  printf("---------------------------------------------------------\n");

  printf("========= init done ==========\n");
}


main(int argc, char *argv[ ])
{
  int n;
  char line[MAX], ans[MAX];

  if (argc < 3){
     printf("Usag
myread: read 1024 char from file descriptor 0
e : client ServerName SeverPort\n");
     exit(1);
  }

  client_init(argv);

  printf("********  processing loop  *********\n");
  while (1){
    printf("input a line : ");
    bzero(line, MAX);                // zero out line[ ]
    fgets(line, MAX, stdin);         // get a line (END with \n) from stdin 
    line[strlen(line)-1] = 0;        // kill \n at end
    if (line[0]==0)                  // exit if NULL line
       exit(0);

   // Send ENTIRE line to server
    n = write(sock, line, MAX);
    printf("client: wrote n=%d bytes; line=(%s)\n", n, line);

    // Read a line from sock and show it
    n = read(sock, ans, MAX);
    printf("client: read  n=%d bytes; echo=(%s)\n",n, ans);
  }
}



13-1. Run the above Server/Client programs. 
      The source files of server.c/clinet.c are in ~samples/LAB4/ directory.
      Download them, cc and run.

      Modify them to do computations, e.g. client sends 2 numbers to server, 
      which returns the SUM.

13-2. 
The above Server/Client code may be used as the
myread: read 1024 char from file descriptor 0
 basis for TCP-orineted network
programming. You may adapt it for different applications by simply changing the
data contents and the ways they process the data.

                    Example:
============================================================================== 
Instead of numbers, the Client may send a "command" string, such as

           pwd  
           ls  [pathname]
           cd  [pathname]
           get filename  
           put filename
           
The Server executes the command and sends results back to the Client. 

Simlarly, you may implement mkdir, rmdir, creat, rm operations at the Server. 
==============================================================================
<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Lab Assignment #2 </H1>

<Pre>

Given the C program:

main(int argc, char *argv[], char *env[])
{
  int a,b,c;
  printf("enter main\n");
  a=1; b=2; c=3;

     //****** DO (1): Write C code here to print the ************* 
     (1). argv[] st
myread: read 1024 char from file descriptor 0
rings
     (2).  env[] strings

  A(a,b);
  printf("exit main\n");
}

int A(int x, int y)
{
  int d,e,f;
  printf("enter A\n");
  d=3; e=4; f=5;
  B(d,e);
  printf("exit A\n");
}

int B(int x, int y)
{
  int g,h,i;
  printf("enter B\n");
  g=6; h=7; i=8;
  C(g,h);
  printf("exit B\n");
}

int C(int x, int y)
{
  int p,q,r;
  printf("enter C\n");
  p=9; q=10; r=11;

    / Write C and assembly code to 
    ********* DO (2)-(4) AS SPECIFIED BELOW *************/

  printf("exit C\n");
}
=============================================================================

(1). Call an assembly function
             getfp:   
                     pushl %ebp
                     movl  %esp, %ebp
                     ...............
     which returns the current frame pointer fp=%ebp. As shown by the diagram,
     fp is the head pointer of a link list of the stack frames, which ends 
     with a 0.

       HIHG                                                  LOW
        ----------------------------------------------------
myread: read 1024 char from file descriptor 0
-----
          0        fp0       fpM       fpA        fpB     fpC
        ---------------------------------------------------------  
          ^         ^         ^         ^          ^       ^ 
         fp0       fpM       fpA       fpB        fpC      fp

(2). Print in HEX the stack contents from fp to fp0 in the form

              Address      Contents
             ---------    ----------

             ---------    ---------- 

(3). On a hard copy of the outputs, IDENTIFY and EXPLAIN the stack contents 
     in terms of the function stack frames, i.e. local variables, parameters, 
     return address, etc. 


4: Long Jump:
   In the above calling sequence, it is possible to return from C() directly 
   to, say main(), by a long jump, as shown below:

4-1: First, define global variables

       int mainFP, mainPC;  /* for saving main()'s FP and PC */

       main()
       { 
           int r;

4-2: /**** Save long jump return point ****/
         if ( r = setjump() )

             /*********************
myread: read 1024 char from file descriptor 0
************************
              Implement setjump() in such a way that it
              saves main's FP into mainFP, setjump()'s return
              PC into mainPC, and returns to here with a 0;
             **********************************************/    
         { 
             printf("back via long jump: r=%d\n",r);
             exit(1);
         }
4-3: /***** Normal call out ******/
         /* call A() -> B() -> C() as before */
         printf("noraml return\n");
       }


4-4:  In one of the called functions, e.g. C():

       int C()
       { .......................;

         printf("long jump back to main? {y|n) ");
        
         /**************************************
           If the answer is 'y' call the function
                 longjump(100);  
           which returns to main() via the saved 
           globals (mainFP, mainPC), and return a 
           nonzero value, e.g. 100.
          **************************************/
       }

           
-------------------  DO #3
myread: read 1024 char from file descriptor 0
  ---------------------------
3-5: Implement the functions IN ASSEMBLY:
         int setjump();
         int longjump(int returnValue);
     and DEMO your long jump in LAB.

NOTE: YOU MUST IMPLEMENT these in ASSEMBLY !!!!
=======================================================
<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Lab #2 Pre-Work</H1>

<Pre>
            DUE : in Lab 

1. A binary executable file, a.out, consists of

           |header| TEXT | DATA |<== BSS ===>|

The Unix command    size a.out   shows the size of TEXT, DATA, BSS of a.out.

Use the following C program, t1.c, to generate t2.c, t3.c,.. t6.c as specified
below. 
        //********** t1.c file ************
          int g;                              
          main()                              
          {                                   
             int a,b,c; 
             a = 1; b = 2; 
             c = a + b;
             printf("c=%d\n", c);
          }                                

t2.c: Ch
myread: read 1024 char from file descriptor 0
ange the global variable  g  to  int g=3;
t3.c  Change the global variable  g  to  int g[10000];
t4.c  Change the global variable  g  to  int g[10000] = {4);
t5.c  Change the local variables of main() to
                 int a,b,c, d[10000];
t6.c. Change the local variables of main() to
                 int a,b,c, d[10000]={5];
t7.c  Change the local variables of main() to
                 static int a,b,c, d[10000];
t8.c  Change the local variables of main() to
                 static int a,b,c, d[10000]={6};
           
(A). For each case, use cc to generate a.out. Then use  ls -l a.out to get 
     a.out size, and run size a.out to get its section sizes. Record the
     observed sizes in a table:

          Case  | a.out |  TEXT  |  DATA  |  BSS   |
        --------------------------------------------
          (1)   |       |        |        |        |
        --------------------------------------------  
          (2)
        --------------------------------------------
          (3)
        -----------
myread: read 1024 char from file descriptor 0
---------------------------------
          (4)
        --------------------------------------------
          (5)
        --------------------------------------------        
          (6)
        --------------------------------------------
          (7)
        --------------------------------------------        
          (8)
        --------------------------------------------

                  ANSWER THESE QUESTIONS:

   1. Variables in C may be classified as

          globals ---|--- UNINITIALIZED  globals;
                     |---   INITIALIZED  globals;

          locals  ---|--- AUTOMATIC locals;
                     |--- STATIC    locals;
          

   In terms of the above classifications and the variables g, a, b, c, d,

      Which variables are in DATA? ______________________________________
      Which variables are in BSS ? ______________________________________

   2. In terms of the TEXT, DATA and BSS sections,
      Which sections are in a.out, which section is NOT in a.out?
      WHY?
myread: read 1024 char from file descriptor 0
______________________________________________________

  (B). For each case, use   cc -static t.c   to generate a.out.
       Record the sizes again and compare them with the sizes in (A).
       WHAT DO YOU SEE?_________________________________________________

       WHY?______________________________________________________________


2. Given the C function, test.c:
     int g;
     int sub(int x, int y)
     {
        int a, b;
        g = 1;
        x = 2; y = 3;
        a = 4; b = 5;
        return 6;
     }

Use cc -S test.c to generate test.s   Examine the test.s file

ABSWER these questions: WHAT ARE THE addresses OF
(1). g?______________________________________________________
(2). parameters x, y ________________________________________
(3). locals a, b     ________________________________________
(3). Which CPU register contains the return value?___________       
<html>
<Body bgcolor="#00cccc" text="#000000">
<pre>

     CS360 Lab Assignment #4 : File Operations across Networks
               
 
myread: read 1024 char from file descriptor 0
                  WORK IN 2-person teams
                  DUE & DENO : to be posted


A. OBJECTIVE:
   Network Programming using TCP.
   Unix system calls for file operations.

B. PRE Lab (Do these on your own).:
   Donwload the server.c and client.c files from samples/LAB4/ direcotry.
   cc and run the server and client programs.

   Modify the programs to do the following:
      Client: input 2 numbers, send them to server and get the answer.
      Server: Add the two numbers and send the result back to client.

C. REQUIREMENTS:
   Modify the server/client programs in samples/LAB4/ to do the following:

     Client : input a command:
              ----------------  
              pwd
              ls   [pathname]
              cd    pathname
              mkdir pathname
              rmdir pathname       
              rm    pathname       (rm pathname file)
              get   pathname       (cp pathname file to client side)
              put   pathname       (cp pathanme file to server side)
            
myread: read 1024 char from file descriptor 0
  quit                 (Client exits)
           -----------------
           send command to Server.
           receive reply (results) from Server.

     Also,implement the (local) commands
         lpwd, lls, lcd, lmkdir. lrmdir, lrm
     which the Client executes LOCALLY.

     Server:
             get a command from Client;
             perform the command;
             send reply to Client;

C. HELP Hints:

   Make each command a fixed-length string, e.g. of LEN=128 bytes.
   REASON: a TCP socket contains a "stream" of data. Each read operation
           reads whatever is available in the socket. Using fixed-length 
           items simplifies reading inidvidual command strings.

D. Sample Solutions
   in samples/LAB4/ : lab4.server  and lab4.client

<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H2>360 LAB Pre-Work #6</H2>
<Pre>
                   CS 360 LAB #5 Pre_work
          PART 1 only:   DUE Wed Oct 15, in LAB 
=================================================================
myread: read 1024 char from file descriptor 0
==============

1. Given: kcmkfs.c file in samples/LAB5

   Write YOUR own C code for 

         get_block(int dev, char *buf, int blk);
         put_block(int dev, char *buf, int blk);

   where dev is an opened file descriptor of a "DEVICE", such as a FD. 

         set_bit(char buf[], int bit);
         clr_bit(char buf[], int bit):
         
         make_bmap();
         make_imap();

   to make the program kcmkfs.c complete. DEMO YOUR WORK on Wednesday,3-19


2. ASSUME: mkfs /dev/fd0 1440  OR  kcmkfs /dev/fd0 1440 184   
   Write C programs to display the specified information on the FD:
------------------------------------------------------------------------
1. super.c  : the superblock information,
2. gd.c     : the group descriptor information.
3. bmap.c   : the Bmap as a sequence of 0/1 chars (80 chars per row).
4. imap.c   : the Imap as a sequence of 0/1 chars (80 chars per row)
5. inode.c  : root inode info
6. dir.c    : dir_entries of the root directory.
------------------------------------------
myread: read 1024 char from file descriptor 0
-------------------------------


//Sample dir.c code

<PRE>

#include &lt;fcntl.h&gt;
#include &lt;linux/ext2_fs.h&gt;

// define shorter TYPES
typedef struct ext2_group_desc    GD;
typedef struct ext2_super_block   SUPER;
typedef struct ext2_inode         INODE;
typedef struct ext2_dir_entry_2   DIR;  

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 


char buf[1024], rbuf[1024];
int fd, blk, i;

int get_block(int blk, char *buf)
{
  // read disk blk into buf[ ]
}

main()
{
  char *cp, temp[256];

  fd=open("/dev/fd0", O_RDONLY);

  get_block(5, buf);      // get root inode block
  ip = (INODE *)buf + 1;  // it's inode #2

  for (i=0; i<12; i++){   // ASSUME dir has only direct blocks
    blk = ip->i_block[i];
    printf("i_block[%d] = %d\n", i, blk);  // print blk number
    if (blk==0)
       break;

    get_block(blk, rbuf); // get block contents into rbuf[] 
    
    dp = (DIR *)rbuf;     // as DIR entries
    cp = rbuf;            
 
   while(cp &lt; &rbuf[1024]){
      bzero(temp, 256);
      strncpy(tem
myread: read 1024 char from file descriptor 0
p, dp->name, dp->name_len);

      // print DIR entry info
      printf("%4d %4d %4d  %s\n", dp->inode, dp->rec_len, dp->name_len, temp);
      // In addition to printing, CAN YOU SEARCH FOR A name STRING? 
      // OR SEARCH FOR A INOODE NUMBER?
      
      cp += dp->rec_len;
      dp = (DIR *)cp;
   }
  }
}







<html>
<Body bgcolor="#00cccc" text="#000000">
<H1>CS360 Lab Assignment #3 : sh Simulator</H1>
<pre>

                DUE & DENO : To be posted

A. OBJECTIVE:
   Understand how Unix sh works by using fork/wait/exec.
   String operations

B. REQUIREMENTS:
   Write a C program, mysh, which simulates the Unix sh for command processing.
   Your mysh should run as follows:

1. Prompt for an input line, which is of the form
          cmd arg1 arg2 arg3 .... argn
   where cmd is a command.

   For simplicity, do NOT consider sh scripts files.
   Valid commands include only "echo", "cd", "exit", and ANY Unix binary 
   executables, e.g. ls, date, pwd, cat, cp, mv, cc ... you name it !!!


2. Handle simpl
myread: read 1024 char from file descriptor 0
e commands:
     cmd = "cd"   :  chdir(arg1) OR chdir($HOME) if no arg1;
     cmd = "echo" :  echo the remaining line;
     cmd = "exit" :  exit(1) to terminate;  

   NOTE: chdir(pathname) is a syscall to change CWD.
         $HOME is the home directory; YOU must find its value from *env[ ].

3. For all other commands:
      fork a child process;
      wait for the child to terminate;
      print child's exit status code
      continue step 1;

4. Child process:
   4-1. Handle I/O redirection:
          cmd  arg1 arg2 ...  <  infile    // take inputs from infile
          cmd  arg1 arg2 ...  >  outfile   // send outputs to outfile
          cmd  arg1 arg2 ...  >> outfile   // APPEND outputs to outfile
        For simplicity, assume at most ONE I/O redirection per line.

   4-2. Execute cmd by execve(), passing parameters 
                char *myargv[], char *env[]
        to the cmd file, 
        where myargv[0]->cmd, myargv[1]->arg1, ....., ending with NULL pointer

        NOTE: if cmd begins with /, exe
myread: read 1024 char from file descriptor 0
cute it directly.
              otherwise, try to execute pathdir/cmd for every pathdir in $PATH


5. SAMPLE SOLUTION:
   
   ~samples/LAB3/lab3.bin          (down load and run under Linux)

===========================  I/O Redirections ===============================

6. I/O Redirections:

6-1. Stream FILEs and File Descriptors:
   Recall that the sh process has 3 stream FILEs: stdin, stdout, stderr.
   When sh forks a child, the child process also has the same FILE streams.
   Each of the FILE streams corresponds to an opened file in the Unix kernel.
   Each opened file has a unique file descriptor (number). The file descriptors
   of stdin, stdout, stderr are 0,1,2, respectively.

6-2. Stream I/O and System Call:
   When a process executes        scanf("formatString", &item);
   it tries to input an item from stdin, which points to a FILE struct.If the
   FILE struct's buffer is empty, it issues a system call to the Unix kernel,
   to READ data from the file descriptor 0, which is mapped to the terminal
  
myread: read 1024 char from file descriptor 0
 (/dev/ttyX) of the sh process.

                      REDIRECT INPUT: 
   If we let stdin point to the FILE struct of a diffferent file that's 
   opened for input, then every scanf() would read inputs from the new file.
   So, if we do
              fclose(stdin);
   which erases the FILE struct pointed by stdin, casuing stdin to be NULL, 
   followed by
              stdin = fopen("filename", "r");
   which fopens filename for READ and let stdin point at the new FILE struct,
   then scanf() would get inputs from the file filename.
   
   The FILE struct of stdin contains a file descriptor 0. If we replace the 
   file descriptor 0 with a newly opened file, we would achieve the same 
   effect. Thus, if we do 
           close(0);    // system call to close file descriptor 0
           open("filename", O_RDONLY);  // open filename for READ, which
                                        // will replace fd 0
   Then, every scanf() call will get inputs from the opened file.


   Similarly, when a process execu
myread: read 1024 char from file descriptor 0
tes      printf("formatString", item);
   it tries to write to stdout, which points to a FILE struct. If the FILE
   struct's buffer is full, it issues system call to the Unix kernel to
   write data to file descriptor 1, which is mapped to the terminal screen.

                       REDIRECT OUTPUT: 
   If we 
          fclose(stdout);
   which erase the FILE struct of stdout, followed by
          stdout = fopen("filenmae", "w");
   which opens filename for WRITE and let stdout point to the FILE struct,
   then printf() would send outputs to filename. More directly, we may keep
   stdout and its FILE struct but let file descriptor 1 point at a different
   file. Thus, if we
          close(1);
          open("filename", O_WRONLY|O_CREAT, 0644); 
   which change file descriptor 1 to point to a file, then the outputs will 
   go to that file instead of the screen. 
  
   When a process dies (in Kernel), it cloes all opened files, (causing
   data to be written out to disk ..

6-3 Use man open to read more on
myread: read 1024 char from file descriptor 0
 how to issue syscalls 
        open(), read(), write(), close(), 
    and (I/O library functions)
       fopen(), fclose()
              









<Title>460 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 Notes #5</H1>
<Pre>
         360 Notes on Process Management in Unix

1. Read Unix man pages on
        fork, exec, wait, exit,  
        kill, signal,  

2. Process:
   A process is a sequence of executions regarded as a single entity by the 
   Unix kernel. Each process has a unique pid and a ppid, which identify the
   process and its parent process, respectively. Processes in Unix form a 
   family tree. They compete for CPU time to run. 

3. Process Origin:
   How does a process begin? As explained before, when Unix starts, it creates
   a process P0 by brutle force. P0 creates (by fork) a child process P1, which 
   is the INIT process. P1 forks many children processes, one on each terminal 
   as the LOGIN process on that terminal. Each LOGIN process opens 3 stream FILEs, 
   stdin, st
myread: read 1024 char from file descriptor 0
dout, stderr. It displays login: to its stdout and waits for a user to 
   login. After a user login, the LOGIN process becomes the user process. Typically, 
   the user process execute sh, so it's known as the sh process. 
   When sh sees an a.out command, it forks a child process to execute a.out. The sh 
   process "waits" until the child process dies. Then it prompts for another command.  

4. Process Image:
   In Unix, a process executes in two different modes; Kernel mode or User 
   mode, denoted by Kmode or Umode, for short. In each mode, a process has
   an "execution image", as shown by the following figure.

                  Images of Process i:
       ------------------------------------------ 
       Kmode :    Kcode_i  Kdata_i   Kstack_i
       ==========================================
       Umode :    Ucode_i  Udata_i   Ustack_i
       ------------------------------------------
   The index i indicates these are the images of process i. In general, the 
   Umode images of different processes
myread: read 1024 char from file descriptor 0
 are all different. While in Kmode they 
   share the same Kcode and Kdata, which are those of the Unix Kernel. However,
   Each process still has its own Kstack.
    
   A process migrates between Kmode and Umode many many times during its life
   time.

   Every process comes into existence and begins execution in Kmode. In fact,
   it does everything of interest, including to die (or terminate), in Kmode. 
   While in Kmode, it can come to Umode easily (by changing CPU's status from 
   K to U mode) However, once in Umode it cannot change CPU's status  
   arbitrarily. A Umode process can enter Kmode in only one of 3 ways:

   (1). Interrupts : Interrupts are hardware signals to the CPU. When an
                     interrupt occurs, CPU will enter Kmode to handle the 
                     interrupt, which causes the process to enter Kmode. 
   (2). Traps: Traps are error conditions, such as invalid address, illegal 
               instruction, divide by 0, etc. recognized by the CPU, causing it
          
myread: read 1024 char from file descriptor 0
     to enter Kmode to deal with the error. Since traps are caused by
               the executing process on the CPU, the process typically dies
               (with a dreadful message such as "Segmentation Fault").

   (3). System Calls:
        System call (or syscall for short) is a mechanism that allows a process
        to enter Kmode to execute Kernel functions. When the Kernel function 
        finishes, it comes back to Umode with a return value, which is normally
        0 for success or -1 for error. In case of error, the global int 
        variable errno (in errno.h) contains an ERROR code which further 
        identifies the error.

        In the following, we shall discuss these syscalls:
           fork(), wait(), exec(), exit(), chdir(), open(), close() 

5. Process Management in Unix:

5-1. fork():  Usage:   int pid = fork();
     fork() creates a child process and returns the child's pid or -1 if error.
     The following diagram shows the actions of fork().


               PROCi        
myread: read 1024 char from file descriptor 0
              |      PROCj
              --------                    |      -------
    Kmode :    Kcodei   kfork(){....}     |                    ( When Pj runs:)
               Kdatai        ^       |    |                          |
               kstacki       |       |    |      Kstackj             V
   ========================  |  ==== | ===========================   | =======
    Umode :    Ucodei  pid=fork(); <-     |      Ucodej  pid=fork();<-
               Udatai                     |      Udataj
               Ustacki                    |      Ustackj


   (1). The left hand side shows the images of a process Pi, which issues
        the syscall   pid=fork();    
   (2). Pi goes to Kmode to execute the corresponding kfork() function, in 
        which it creates a child process PROCj with Kstackj and Umode image of
        Pj, as shown in the right hand side of the diagram.
 
        The Umode image of Pj is an IDENTICAL copy of Pi's Umode image.

        Thus, Pj's Ucodej also has the statement
  
myread: read 1024 char from file descriptor 0
                 pid=fork();

   (3). After creating Pj, Pi returns to the statement  
              pid = fork();
        in Ucodei with the child's pid = j.

   (4). When Pj begins to run, it exits Kmode and returns to the same statement
              pid = fork();
        with a 0 value in ITS OWN Umode image. 

   Example 1: Consider the C program:

        main()
        {
           int pid;
           printf("THIS IS %d  MY PARENT=%d\n", getpid(), getppid()); 

           pid = fork();   // fork syscall; parent returns child pid, 
                           //               child returns 0

           if (pid < 0){   // fork() may fail. e.g. no more PROC in Kernel
               perror("fork faild");
               exit(1);
           }
           
           if (pid){ // PARENT EXECUTES THIS PART 
                  printf("THIS IS %d  MY PARENT=%d\n", getpid(), getppid());
           } 
           else{ // child executes this part
                  printf("I am    %d  my parent=%d\n", getpid(), getppi
myread: read 1024 char from file descriptor 0
d());
           }
        }


5-2. pid = wait(int *howDidChildDie);

     wait() returns a dead child's pid and its exit code=[exit#|sig#]
            As usual, it returns -1 if error, e.g. caller has no child.

     Note:  if caller has more than one child, wait() returns ANY dead child.
               exit# is the exit(VALUE) used by child to die,
               sig#  is the (signal) number that caused the child to die.
            ONLY one of the numbers will be present, WHY?

     main()
     {
       int pid, status;
       pid = fork();
       if (pid){ // PARENT:
           printf("PARENT %d WAITS FOR CHILD %d TO DIE\n", getpid(),pid);
           pid=wait(&status);
           printf("DEAD CHILD=%d, HOW=%04x\n", pid, status);
       }
       else{// child:
           printf("child %d dies by exit(VALUE)\n", getpid());
           exit(100);  //OR {int a,b; a=b/0;} ==> see how does it die
       }
     }

5-3. Execution Order:
     After fork(), the child process competes with all other processes
     fo
myread: read 1024 char from file descriptor 0
r CPU time to run. Which process will run next depends on their 
     scheduling prioirty, which changes dynamically.
 
     main()
     {
        int pid;
        pid=fork();
        if (pid){ // PARENT
           printf("PARENT %d DYING\n", getpid());
        }
        else{ // child
               printf("child %d sleeps for 2 seconds\n");
               sleep(2); // sleep for 2 seconds ==> PARENT DIES FIRST
               printf("child %d my parent=%d\n", getpid(), getppid());
        }
     }

5-4. Parent Process
     When a process dies (in Kmode), it becomes a ZOMBIE, i.e. its PROC is 
     marked as ZOMBIE and contains information, such as exit code. When the 
     parent process finds a ZOMBIE child (by wait() syscall), it collects the 
     needed information from the ZOMBIE PROC and finally lay the dead body to 
     rest, i.e. set the ZOMBIE PROC to FREE for recycle again. Thus, a process
     MUST have a parent at all times. However, because of the (independent) 
     process execution order, a p
myread: read 1024 char from file descriptor 0
rocess with children may die first. Similar 
     to humman society, such children are called orphans. The natural question
     is: who should be the "parent" of such orphans? In humman society, they 
     would be sent to grandma's house. But what if gradma also died? In Unix,
     the parent of all orphans is P1. Thus, P1 wears many hats:
     It's the grand dad of ALL user processes. It's the head of an orphange, 
     and it's also the manager of a morgue (which buries DEAD bodies). 
                  
5-4. nice(VALUE); 
     Decrease caller's scheduling priority by VALUE, allowing other processes
     to run first.

6. Change Execution Image:

   A process may use exec() to change its USER mode image to another 
   (executable) file. The exec() library functions have several members:
 
     int execl( const char *path, const char *arg, ...);
     int execlp(const char *file, const char *arg, ...);
     int execle(const char *path, const char *arg , ..., char *const envp[]);
     int execv( const char *p
myread: read 1024 char from file descriptor 0
ath, char *const argv[]);
     int execvp const char *file, char *const argv[]);

   All of them eventually issue the syscall

     int execve(const char *filename, char *const argv[], char *const envp[]);

   which is the basis of the C function

         main(int argc, char *argv[], char *env[])


   If successful, exec("filename",....) replaces the current Umode image with
   a new image generated from the executable filename. It's the SAME process 
   but with a new Umode image. The old Umode image is abandoned and therefore
   never returned to, unless exec() fails, e.g. filename is non-executable.

   This is similar to a person who goes to Heaven (Kernel) from where he/she
   builds a new house on Earth (Umode), burns down the old house (IRS allows 
   only one house per person?) and returns to the new house to begin a new life
   there. Naturally, the person must return to the same old house if the new
   house cannot be built.
    
Example #1 : Use execl(), which is of the form 
                     
myread: read 1024 char from file descriptor 0

             execl("a.out", "a.out", string1, string2, ..., 0);

----------- cc to a.out ---------------------------------
 main(int argc, char *argv[])
{
  printf("THIS IS %d IN %s\n", getpid(), argv[0]);
  execl("b.out", "b.out", "hi", 0);
  printf("SHOUDL NOT SEE THIS LINE\n");
}  

----------- cc to b.out ---------------------------------
main(int argc, char *argv[])
{
  printf("this is %d in %s\n", getpid(), argv[0]);
  while(1);
}
----------------------------------------------------------


7. Signals and Signal Handling:

(1). A signal is a number from 1 to 31, as defined in &lt;asm/signal.h&gt;

(2). Signal Sources:
     traps      : errors recognized by CPU as "traps", e.g. 
                  divide by 0, illgal instruction, invalid address, ....
     interrupts : Control_C, HangUp, ...
     pre-defined: death_of_child,...
     sent by other processes via kill()

(2). kill(pid, signal#): send signal# to pid; signal#=1 to 31.

     main()
     {
       int pid, status;
       pid=fork();
       if (p
myread: read 1024 char from file descriptor 0
id){// PARENT
                  kill(pid, 8);
                  pid=wait(&status);
                  printf("dead child=%d, how=%4x\n", pid, status);
                 }
       else{ // child
             while(1);  // while happily looping, child will die by sig# 8
           }
      }
============================================================================


(3). signal(sig#, ACTION); install a signal handler for sig#, 
            where ACTION = 0 ==> default action by Unix Kernel;
                           1 ==> ignore the signal (except #9)
                           &catcher() in user space.

#include &ltsignal.h&gt
#include &ltsys/time.h&gt

/**********************************************************
struct itimerval {
                struct timeval it_interval;
                struct timeval it_value;   
            };

struct timeval {
                long tv_sec;               
                long tv_usec;              
            };

int  setitimer(int which,  const  struct  itimerval  *value
myread: read 1024 char from file descriptor 0
, struct
              itimerval *ovalue);
**************************************************************/

struct itimerval t;

int h, m, s;

void catcher(sig) int sig;
{
  printf("in catcher, sig=%d\n", sig);
}

main()
{

 t.it_interval.tv_sec = 1;    // interval=1 second
 t.it_interval.tv_usec= 0;

 t.it_value.tv_sec = 2;       // after 2 seconds 
 t.it_value.tv_usec= 0;

   signal(SIGALRM, (void *)catcher);   // install catcher for signal 14

   setitimer(ITIMER_REAL,&t,0);        // set interval timer REAL mode

 while(1);                             // sits here in a loop;

} 

<Title>360 Week 2 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes on Assembly Programming</H1>

<Pre>
   
              360 NOTES on Assembly Programming

1. Implement C functions in Assembly:

Example 1: Functions for getting CPU registers

main()
{
   int ebp, esp;
   ebp = get_ebp();
   esp = get_esp();
   printf("ebp=%8x   esp=%8x\n", ebp, esp);
}

=============================

	.global get_esp, get_ebp

myread: read 1024 char from file descriptor 0

get_esp:
         movl	%esp, %eax
         ret

get_ebp:
	movl	%ebp, %eax
	ret
=============================
EXERCISE: Write assembly functions for getting ebx, ecx, edx, esi and edi


Examples 2. A function that computes the sum of 2 integers

main()
{ 
  int a,b,c;
  a = 100; b = 200;
  c = mysum(a,b);
  printf("c=%d\n", c);
}

==========================
# int mysum(int x, int y)

        .global mysum
mysum:
# establish stack frame
        pushl	%ebp
        movl	%esp, %ebp

        movl	 8(%ebp), %eax
        addl	12(%ebp), %eax     
         
# return to main
        leave       # same as  { movl %ebp,%esp;  pop %ebp }
        ret


2. Call C functions from Assembly:

Example 3: Access global variables
 
int a, b;

main()
{
   a = 100;  b = 200;
   sub();
}

===================================

        .global sub, a, b, printf
sub:
        pushl   %ebp
        movl    %esp, %ebp

        pushl   b
        pushl   a
        pushl   $fmt
        call    printf
        addl    $12, %esp
        
        m
myread: read 1024 char from file descriptor 0
ovl    %ebp, %esp
        popl    %ebp
        ret

fmt:	.asciz	"a=%d  b=%d\n" 
====================================

Example 4: Assembly function format:

# entry:
          pushl  %ebp
          movl   %esp, %ebp 
----------------------------------

    # Actual code of fucntion 

----------------------------------
# exit:    leave
           ret
   <Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>
                
<Pre>
                     HOWTO cat_cp_mv

int cat_file()
{
  ask for a pathname to cat

  mycat(pathname);

}

// with open() and read(), mycat() is almost trivial
 
int mycat(pathname) char *pathname;
{
 fd = myopen(pathname, 0);  // call OUR own myopen() to open file for READ

 loop:
       read 1 BLOCK, printf() to show the chars;
       UNTIL end file

 myclose(fd);
 
 return(0);
}


NOTE: For simplicity, consider cp (or mv) of a SINGLE file only.
      However, files may have DOUBLE-INDIRECT BLOCKs !!!!

int cp_file()
{
    ask for 2 pathnam
myread: read 1024 char from file descriptor 0
es, src and dest, for cp src to dest.
    
    call mycp(src, dest) to do the actual cp
}


int mycp(char *src, char *dest)
{
   AS USUAL, NEVER cp a file to itself !!

   open src for READ   ==> fd
   creat f2 if not exists;
   open dest for WRITE ==> gd; 
   loop:
         n = read(fd, buf, nbytes);
         write(gd, buf, n);
   while (n>0)
   close fd;
   close gd;
}




int mv_file()
{
    ask for 2 pathnames src and dest for mv  src to dest

    return mymv(src, dest);
}


int mymv(char *srcf1, char *dest)
{
  Case 1: same dev:
          Listen to lecture

  Case 2: differnet dev (with mounted FS):
          mycp(src, dest);
          rm src;
}







<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Project Help #2</H1>

<Pre>

                 Simulator Data Structure Diagram

   KEEP A COPY OF THIS DIAGRAM FOR REFERENCE when designing your algorithms.


1. RunningPtr

     |
     V        |---- PointerToCWD ------|
              |                        |
2  PROC[]     |
myread: read 1024 char from file descriptor 0
    3. OFT[ ]           V 4.MINODE[]              Disk dev
 ===========  |    ===========          ============       ===================
  nextProcPtr |     mode                  INODE            |         INODE   |
  pid, ppid   |     refCount             -------           =================== 
  uid, gid    |     MinodePtr            dev,ino
  cwd --------|     offset               refCount          
                  ===========            dirty
  fd[10]                                 mounted
  ------                                 mTablePtr -----------
  ------                                 filename[]          |
  ------                                                     |
  ------                                ============         |  
 ==========                               INODE              |
                                         -------             |
                                         dev,ino             |
                                         refCount            |  
              
myread: read 1024 char from file descriptor 0
                           dirty               |
                                         mounted             |
                                         mTablePtr           |
                                         filename[]          |
                                        ============         |
                                                             |
            PointAtRootInode                                 |
                   ^                                         V
                   |                                    PointAtMountTable[0]
                   |      5.   MuntTable[ ]
                   |  ------- 0 --------- 1 ----------
                   |  | dev          |            |
                   |--| MinodePtr    |            |
                      |............. |            |
                      | deviceName   |            |
                      | MinodePath   |            |
                      |              |            |
                      | nblocks      |        
myread: read 1024 char from file descriptor 0
    |
                      | ninodes      |            |
                      ---------------------------------  



This diagram shows the data structures of the file system simulator.

1. is a PROC pointer pointing at the PROC structure of the current running 
   process.  Each process has a Currnet Working Directory, cwd, which is
   initialized to point at the in-memory root inode.

2. is the PROC structure of processes. Everything in the simulator is performed
   by the current ruuning process.

3. is the Open File Table (OFT). Each OFT entry represents an instance of an 
   opened file. We shall discuss OFT later when dealing with Level-2.

4. is the in-memory inodes array, MINODE[100]. Each minode entry contains a 
   sub-structure INODE, which is the INODE struct on Disk.  Whenever a file
   (regular or DIR) is referenced, its inode must be brought into memory. In 
   order to ensure ONLY ONE copy of every inode in memory, a needed inode will
   be loaded into a MINODE slot. The (dev, ino) field ide
myread: read 1024 char from file descriptor 0
ntifies where the 
   inode came from (for writing it back to disk). The refCount keeps track of
   how many processes are using this minode. The dirty field tells whether the
   INODE has been modified or not. If an minode is dirty, the last user of the
   minode must write the INODE back to disk. The mounted flag says whether 
   this DIR has been mounted on or not. If mounted on, the mTablePtr points at
   the MountTable entry.

5. is the MountTable (MT). Each entry represetns a device that has been 
   mounted (on a DIR).  When a file system starts, it must mount a device on
   the Root DIR /. That device is called the root device. So the first thing
   our simulator does is also to mount-root.  As shown, MT[0] represents the
   root device. The dev field identifies which device this is. The MinodePtr
   points at the DIR that's mounted on. (in 4, the DIR also points back to the
   mounted device). Knowing the dev, we can always access the device to get 
   its Superblock, bitmaps, rootInode, etc. For con
myread: read 1024 char from file descriptor 0
venience, some often
   used information are kept in the MountTable for quick reference, e.g. 
   nblocks, ninodes. Here is an exmple of their usage: If process wants to 
   release an inode, it calls dealloc(ino) to deallocate the inumber of the 
   inode. The caller may pass in an ino > actual number of inodes (hence 
   exceeds the range of the inodes bitmap). We can check the ino against 
   ninodes to avoid tunning the worng bits on in the bitmap. Similarly for 
   nblocks. 



<html>
<body>
<pre>

                NOTES #11 EXT2 File System on FD

Under Linux, the command  mkfs /dev/fd0 1440  makes an EXT2 file system on a 
1.44MB floppy disk. It also reports some statistics, such as block size=1024, 
184 inodes, 1440 blocks, etc. Linux's mkfs creates an EXT2 file system with a
default lost+found directory. You may use the commands  
        mount /dev/fd0 /mnt;  rm -r /mnt/*;   umount /mnt
to make the file system empty.
 
The layout of an EXT2 file system on a floppy disk is 

   |Boot|Super| Gd |Bmap|I
myread: read 1024 char from file descriptor 0
map|Inodes blocks .....|data blocks ..........|
      0    1    2    3     4    5  ..............| .....................|

The block contents are explained below.

Block#0: Boot Block:
  B0 is the boot block, which is not used by the file system.

Block#1: Super Block:
  B1 is the Superblock, described by the super_block structure, where only the
  essential fields are (shown and) explained. You may ignore the other fields.

struct ext2_super_block {
  unsigned long  s_inodes_count;       // total number of inodes
  unsigned long  s_blocks_count;       // total number of blocks
  unsigned long  s_r_blocks_count;     
  unsigned long  s_free_blocks_count;  // current number of free blocks
  unsigned long  s_free_inodes_count;  // current number of free inodes 
  unsigned long  s_first_data_block;   // first data block in this group
  unsigned long  s_log_block_size;     // 0 for 1KB block size
  long           s_log_frag_size;
  unsigned long  s_blocks_per_group;   // 8192 blocks per group 
  unsigned long  s_
myread: read 1024 char from file descriptor 0
frags_per_group;
  unsigned long  s_inodes_per_group;    
  unsigned long  s_mtime;
  unsigned long  s_wtime;
  unsigned short s_mnt_count;          // number of times mounted 
  short          s_max_mnt_count;      // mount limit
  unsigned short s_magic;              // 0xEF53
  // A FEW MORE non-essential fields
};

Block#2: Group Descriptor Block
EXT2 divides disk blocks into GROUPs. Each group contains 8192 (contiguous)
blocks. Each group is described by a group_desc structure of 32 bytes:

struct ext2_group_desc
{
  unsigned long  bg_block_bitmap;          // Bmap block number
  unsigned long  bg_inode_bitmap;          // Imap block number
  unsigned long  bg_inode_table;           // Inodes begin block number
  unsigned short bg_free_blocks_count;     // THESE are OBVIOUS
  unsigned short bg_free_inodes_count;
  unsigned short bg_used_dirs_count;        

  unsigned short bg_pad;                   // ignore these 
  unsigned long  bg_reserved[3];
};

A FD has only 1440 blocks. So, B2 contains only 1 gr
myread: read 1024 char from file descriptor 0
oup_desc structure (The
rest are 0's).

Block#3: Block Bitmap (Bmap):
A bitmap is a sequence of bits used to represent some kind of items, e.g. disk
blocks or inode structures. Bitmaps are used to allocate/deallocate items. In a
bitmap, a 0 bit means the corresponding item is FREE, and a 1 bit means the 
corresponding item is in USE. A FD has 1440 blocks but block#0 is NOT used by
the file system. So, the Bmap has only 1439 valid bits in B3. The exact values 
of Bmap will be shown later.

Block#4: Inode Bitmap (Imap)
An inode is a data structure used to represent a file. A file system is created
with a finite number of inodes. The status of the inodes are represented by a
a bitmap, called the Imap, in B4. 
In an EXT2 FS, the first 10 inodes are reserved. Thus, the Imap of an empty FS
starts with TEN 1's, followed by 0's.

Block#5: Inodes (begin) Block
In Unix, every file is represented by a UNIQUE inode structure of 128 bytes, 
defined as follows.

struct ext2_inode {
  //*************************************
myread: read 1024 char from file descriptor 0
************************************
  unsigned short i_mode;                      // will be explained in detail 
  unsigned short i_uid;                       // ownerID
  unsigned long  i_size;                      // file size in bytes
  unsigned long  i_atime;                     // time fields  
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;                       // groupID
  unsigned short i_links_count;               // link count
  unsigned long  i_blocks;                    // IGNORE
  unsigned long  i_flags;                     // IGNORE
  unsigned long  i_reserved1;                 // IGNORE
  unsigned long  i_block[15];                 // See details below
  //**************************************************************************

  // IGNORE THE FOLLOWING
  unsigned long  i_version;
  unsigned long  i_file_acl;
  unsigned long  i_dir_acl;
  unsigned long  i_faddr;
  unsigned char  i_frag;
  unsigned char  i_fsize;
  unsigned short i_pad1
myread: read 1024 char from file descriptor 0
;
  unsigned long  i_reserved2[2
}

The fields i_block[15] record the disk blocks (numbers) of a file, which are 

    DIRECT blocks : i_block[0] to i_block[11], which point to direct blocks.
    INDIRECT block: I_block[12] points to a block, which contians 256 (ulong) 
                    block numbers.
    DOUBLE INDIRECT block: 
                    I_block[13] points to a block, which points to 256 blocks,
                    each of which point to 256 blocks.
    TRIPLE INDIRECT block: 
                    I_block[14] points to a block, which points to 256 blocks,
                    each of which points to 256 blocks, each of which points to
                    256 blocks.
    
The total number of inodes is always a multiple of 8 (so that every inodes 
block is full). The number of inode blocks is therefore
                    (total number of inodes)/8. 
For example, if the number of inodes is 184, then the inode blocks include 
B5, B6, B7, ...., B27.


Data Blocks:
Immediately after the inode blocks ar
myread: read 1024 char from file descriptor 0
e the data blocks. In the example of 184
inodes, the first real data block is B28, which is i_block[0] of the root
directory /.


EXT2 Directory Entries:
A directory contains dir_entry sturctures. In EXT2, component file names can 
vary form 1 to 255 chars long. So the dir_entries also have varying length. 

struct ext2_dir_entry_2 {
	unsigned long  inode;        // Inode number; count from 1, NOT from 0
	unsigned short rec_len;      // This entry length in bytes
	unsigned char  name_len;     // Name length in bytes
	unsigned char  file_type;    // for future use
	char   name[EXT2_NAME_LEN];  // File name: 1-255 chars, no NULL byte
};

                  HOW TO STEP THROUGH dir_entries:

Example: Assume the root directory / contains entries 
                this  is  aVeryLongName short
Then the 0th data block (i_block[0] in its inode) of this DIR file contains:
 
|2 12 1.|2 12 2..|11 12 4this|12 12 2is|13 24 13aVeryLongName|14 952 5short   |

Each record has a rec_len and a name_len field, which will be expla
myread: read 1024 char from file descriptor 0
ined later.

First, read the block into a char buf[1024].
Let DIR *dp and char *cp BOTH point at buf;
Use dp-> to access the fields of the record, e.g. print the name

                    TO MOVE TO THE NEXT entry:
        cp += dp->rec_len;       // advance cp by rec_len BYTEs
        dp = (shut-up)cp;        // pull dp along to the next record

This way, you can step through ALL the record entries of a DIR file.


************************ Mailman's Algorithm by KCW *************************
Each inode is determined uniquely by its POSITION (counting from 0,1,2,...) in
the inode area. The position PLUS 1 is called the inode number (i_number or 
ino for short), which counts from 1. (A 0 i_number means no inode). In an EXT2
FS, the root inode is inode #2.
                       
                             QUESTION:
----------------------------------------------------------------------------
 Given an i_number, such as 123, how to find the inode in the inode blocks?
 i.e. which inode block?  which inode in th
myread: read 1024 char from file descriptor 0
at inode block?
 This problem has a more general form:

                         Mailman's Algorithm:
 A city has M blocks, numbered 0,1,2,..,M-1. Each block has N houses, numbered 
 0,1,..,N-1.
 Each house has a unique BLOCK address in the form
                BA = (BLOCK, HOUSE)
 A house also has a unique LINEAR address 
                LA = 0,1,2,..,N-1, N,N+1,......

                            PROBLEM:
 Given a linear address LA, e.g. 123, determine its BLOCK address, and vice 
 versa. The solution is called the Mailman's algorithm:
 
 IF everything counts from 0,the algorithm is very simple:

                    BA = (LA / N, LA % N)
                    LA = N*BLOCK + HOUSE

 It is so simple that you may ask: What's all the fuss about?
 QUESTION: WHAT IF they do not count from 0?
============================================================================
Applications of Mailman's Algorithm:

1. Test, Set, Clear BITs in C:
   Consider  char buf[1024]; buf[] has 1024 bytes, known as buf[i], i=0,1,2,.. 
 
myread: read 1024 char from file descriptor 0
  It also has 8192 BITs numbered 0,1,2,....

   Given a bit number BIT, e.g. 1234, which byte i contains the bit, and which 
   bit j is it in that byte?
   Solution:
               i = BIT / 8
               j = BIT % 8

   To TST a bit at BIT:  if ( buf[i] & (1 << j) )

   To SET a bit at BIT:  buf[i] |=  (1 << j);
     
   To CLR a bit at BIT:  buf[i] &= ~(1 << j);
 
2. Convert i_number to inode:
   In an EXT2 FS, inodes begin in the inode_table block (block 5 for FD).
   Each inode has a unique i_number = 1,2,.....

   Given an i_number, e.g. 1234, determine which disk block# contains that
   inode, and which inode# is it in that block?

   We need to know the block# because READ/WRITE real disk is always in block,
   can't just read/write an item inside a disk block.    

   Soution:  block# = (i_number - 1)/INODES_PER_BLOCK + inode_table;
             inode# = (i_number - 1)%INODES_PER_BLOCK;

   TRY TO ANSWER FOR YOURSELF: WHY i_number-1? and WHY + inode_table
   
3. Convert disk block# to CHS = (cyl, 
myread: read 1024 char from file descriptor 0
head, sector) of a REAL disk:
   A FD has 80 cylinders, each cylinder has 2 tracks (heads), each track has
   18 sectors. A hard disk just has many MORE cylinders, heads and sectors.
 
   Given a (linear) block#, e.g. 1234, determine its (cyl, head, sector) on
   the disk. Some disk drivers takes only (cyl,head,sector) for disk I/O.
*****************************************************************************

All the struct types are defined in 
&ltlinux/ext2_fs.h&gt

==========================================================================
#include &ltstdio.h&gt
#include &ltfcntl.h&gt
#include &ltlinux/ext2_fs.h&gt

// define shorter TYPES, save typing efforts
typedef struct ext2_super_block SUPER;
typedef struct ext2_group_desc  GD;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

==============================================================================

                            EXERCI
myread: read 1024 char from file descriptor 0
SES

ASSUME: mkfs /dev/fd0 1440
Write C programs to display the specified information on the FD:
------------------------------------------------------------------------
1. super.c  : the superblock information,
2. gd.c     : the group descriptor information.
3. bmap.c   : the Bmap as a sequence of 0/1 chars (80 chars per row).
4. imap.c   : the Imap as a sequence of 0/1 chars (80 chars per row)
5. inode.c  : root inode
6. dir.c    : dir_entries of the root directory.
-------------------------------------------------------------------------

<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 NOTES #10 Linux EXT2 File System</H1>

<Pre>

The Second Extended File system (EXT2)

1. Groups

An EXT2 disk partition is divided into groups (of 8K blocks). Each group 
contains in the order: 

    Superblock 

    Group Descriptors 

    Block bitmap of the group

    Inode bitmap of the group

    Inodes of the group

    Data blocks of the group 


2. The EXT2 Superblock

  The Superblock
myread: read 1024 char from file descriptor 0
 contains information about the entire file system.
Amongst other information it contains:

Magic Number 
    This allows the mounting software to check that this is indeed the 
    Superblock for an EXT2 file system. For the current version of EXT2 this 
    is 0xEF53. 
Revision Level 
    The major and minor revision levels allow the mounting code to determine 
    whether or not this file system supports features that are only available 
    in particular revisions of the file system. There are also feature
    compatibility fields which help the mounting code to determine which new 
    features can safely be used on this file system, 
Mount Count and Maximum Mount Count 
    Together these allow the system to determine if the file system should be 
    fully checked. The mount count is incremented each time the file system is
    mounted and when it equals the maximum mount count the warning message 
    ``maximal mount count reached, running e2fsck is recommended'' is 
    displayed, 
Block Group Number
myread: read 1024 char from file descriptor 0
 
    The Block Group number that holds this copy of the Superblock, 
Block Size 
    Block size used by the file system.
Blocks per Group 
    The number of blocks in a group. Like the block size this is fixed when 
    the file system is created, 
Free Blocks 
    The number of free blocks in the file system, 
Free Inodes 
    The number of free Inodes in the file system, 
First Inode 
    This is the inode number of the first inode in the file system. 

The detailed structure of an ext2fs superblock is [include/linux/ext2_fs.h]: 

struct ext2_super_block {
  unsigned long  s_inodes_count;
  unsigned long  s_blocks_count;
  unsigned long  s_r_blocks_count;
  unsigned long  s_free_blocks_count;
  unsigned long  s_free_inodes_count;
  unsigned long  s_first_data_block;
  unsigned long  s_log_block_size;
  long           s_log_frag_size;
  unsigned long  s_blocks_per_group;
  unsigned long  s_frags_per_group;
  unsigned long  s_inodes_per_group;
  unsigned long  s_mtime;
  unsigned long  s_wtime;
  unsigned sh
myread: read 1024 char from file descriptor 0
ort s_mnt_count;
  short          s_max_mnt_count;
  unsigned short s_magic;
  unsigned short s_state;
  unsigned short s_errors;
  unsigned short s_pad;
  unsigned long  s_lastcheck;
  unsigned long  s_checkinterval;
  unsigned long  s_reserved[238];
};

s_inodes_count 
    the total number of inodes on the fs. 

s_blocks_count 
    the total number of blocks on the fs. 

s_r_blocks_count 
    the total number of blocks reserved for the exclusive use of the superuser.

s_free_blocks_count 
    the total number of free blocks on the fs. 

s_free_inodes_count 
    the total number of free inodes on the fs. 

s_first_data_block 
    the position on the fs of the first data block. Usually, this is block 
    number 1 for fs containing 1024 bytes blocks and is number 0 for other fs. 

s_log_block_size 
    used to compute the logical block size in bytes. The logical block size is
    in fact 1024 << s_log_block_size. 

s_log_frag_size 
    used to compute the logical fragment size. The logical fragment size is in
myread: read 1024 char from file descriptor 0

    fact 1024 << s_log_frag_size if s_log_frag_size is positive and 1024 >> 
    -s_log_frag_size if s_log_frag_size is negative. 

s_blocks_per_group 
    the total number of blocks contained in a group. 

s_frags_per_group 
    the total number of fragments contained in a group. 

s_inodes_per_group 
    the total number of inodes contained in a group. 

s_mtime 
    the time at which the last mount of the fs was performed. 

s_wtime 
    the time at which the last write of the superblock on the fs was performed.

s_mnt_count 
    the number of time the fs has been mounted in read-write mode without 
    having been checked. 

s_max_mnt_count 
    the maximum number of time the fs may be mounted in read-write mode before
    a check must be done. 

s_magic 
    a magic number that permits the identification of the file system. It is 
    0xEF53 for a normal ext2fs and 0xEF51 for versions of prior to 0.2b. 

s_state 
    the state of the file system. It contains an or'ed value of EXT2_VALID_FS
    (0x0001) 
myread: read 1024 char from file descriptor 0
which means: unmounted cleanly; and EXT2_ERROR_FS (0x0002) which 
    means: errors detected by the kernel code. 

s_errors 
    indicates what operation to perform when an error occurs. See section 
    Error Handling 

s_pad 
    unused. 

s_lastcheck 
    the time of the last check performed on the fs. 

s_checkinterval 
    the maximum possible time between checks on the fs. 

s_reserved 
    unused. 

Times are measured in seconds since 00:00:00 GMT, January 1, 1970. 



3. The EXT2 Group Descriptor

  Each Group is described by a data structure called the Group Descriptor.
Like the Superblock, all the group descriptors for all of the Block Groups are
duplicated in each Block Group in case of file system corruption. 

Each Group Descriptor contains the following information: 

Blocks Bitmap 
    The block number of the block allocation bitmap for this Block Group. 
    This is used during block allocation and deallocation, 
Inode Bitmap 
    The block number of the inode allocation bitmap for this Block 
myread: read 1024 char from file descriptor 0
Group. 
    This is used during inode allocation and deallocation, 
Inode Table 
    The block number of the starting block for the inode table for this Block 
    Group. Each inode is represented by the EXT2 inode data structure 
    described below. 
Free blocks count, Free Inodes count, Used directory count 

The group descriptors are placed one after another and together they make the 
group descriptor table. Each Blocks Group contains the entire table of group 
descriptors after its copy of the Superblock. Only the first copy (in Block
Group 0) is actually used by the EXT2 file system. The other copies are there,
like the copies of the Superblock, in case the main copy is corrupted. 

On disk, the group descriptors immediately follow the superblock and each 
descriptor has the following layout: 

struct ext2_group_desc
{
  unsigned long  bg_block_bitmap;
  unsigned long  bg_inode_bitmap;
  unsigned long  bg_inode_table;
  unsigned short bg_free_blocks_count;
  unsigned short bg_free_inodes_count;
  unsig
myread: read 1024 char from file descriptor 0
ned short bg_used_dirs_count;
  unsigned short bg_pad;
  unsigned long  bg_reserved[3];
};

bg_block_bitmap 
    points to the blocks bitmap block for the group. 

bg_inode_bitmap 
    points to the inodes bitmap block for the group. 

bg_inode_table 
    points to the inodes table first block. 

bg_free_blocks_count 
    number of free blocks in the group. 

bg_free_inodes_count 
    number of free inodes in the group. 

bg_used_dirs_count 
    number of inodes allocated to directories in the group. 

bg_pad 
    padding. 

The information in a group descriptor pertains only to the group it is 
actually describing. 


4. Block and Inode Bitmaps

The ext2 file system uses bitmaps to keep track of allocated blocks and inodes.
The blocks bitmap of each group refers to blocks ranging from the 0th block
to the last block in the group. The inode bitmap of each group refer to inodes
ranging from the 0th inode (inumber couts from 1) to the last inode of the
group. A 0 bit means that block/inode is FREE, and a 1 bit 
myread: read 1024 char from file descriptor 0
means it has been
allocated.


5. Inodes

   An inode is a structure that uniquely describes a file. In the EXT2 file
system, every file and directory is described by one and only one inode. 
The EXT2 inodes for each Block Group are kept in the inode table together with
a bitmap that allows the system to keep track of allocated and unallocated 
inodes. It contains the following fields: 

mode 
    This holds two pieces of information; what does this inode describe and 
    the permissions that users have to it. For EXT2, an inode can describe one
    of file, directory, symbolic link, block device, character device or FIFO. 
Owner Information 
    The user and group identifiers of the owners of this file or directory. 
    This allows the file system to correctly allow the right sort of accesses, 
Size 
    The size of the file in bytes, 
Timestamps 
    The time that the inode was created and the last time that it was modified,


The detailed inode structure is as follows.

struct ext2_inode {
  unsigned sho
myread: read 1024 char from file descriptor 0
rt i_mode;
  unsigned short i_uid;
  unsigned long  i_size;
  unsigned long  i_atime;
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;
  unsigned short i_links_count;
  unsigned long  i_blocks;
  unsigned long  i_flags;
  unsigned long  i_reserved1;
  unsigned long  i_block[EXT2_N_BLOCKS];
  unsigned long  i_version;
  unsigned long  i_file_acl;
  unsigned long  i_dir_acl;
  unsigned long  i_faddr;
  unsigned char  i_frag;
  unsigned char  i_fsize;
  unsigned short i_pad1;
  unsigned long  i_reserved2[2];
};

i_mode 
    type of file (character, block, link, etc.) and access rights on the file. 

i_uid 
    uid of the owner of the file. 

i_size 
    logical size in bytes. 

i_atime 
    last time the file was accessed. 

i_ctime 
    last time the inode information of the file was changed. 

i_mtime 
    last time the file content was modified. 

i_dtime 
    when this file was deleted. 

i_gid 
    gid of the file. 

i_links_count 
    number of links poi
myread: read 1024 char from file descriptor 0
nting to this file. 

i_blocks 
    number of blocks allocated to this file counted in 512 bytes units. 

i_flags 
    flags (see below). 

i_reserved1 
    reserved. 

i_block 
    pointers to blocks (see below). 

i_version 
    version of the file (used by NFS). 

i_file_acl 
    control access list of the file (not used yet). 

i_dir_acl 
    control access list of the directory (not used yet). 

i_faddr 
    block where the fragment of the file resides. 

i_frag 
    number of the fragment in the block. 

i_size 
    size of the fragment. 

i_pad1 
    padding. 

i_reserved2 
    reserved. 

As can be seen, an inode contains, EXT2_N_BLOCKS (15) pointers to block. 
Of theses pointers, the first EXT2_NDIR_BLOCKS (12) are direct pointers to 
data blocks. The following entry points to a block of pointers to data 
(indirect). The following entry points to a block of pointers to blocks of 
pointers to data (double indirection). The following entry points to a block 
of pointers to a block of pointers to a bloc
myread: read 1024 char from file descriptor 0
k of pointers to data
(triple indirection).

For SPECIAL files (I/O devices such as /dev/fd0, /dev/hda1, etc.) they
do not need data block pointers. Only iblock[0] contains the device's
(major, minor) ID numbers.


The inode flags may take one or more of the following or'ed values: 

EXT2_SECRM_FL 0x0001 
    secure deletion. This usually means that when this flag is set and we 
    delete the file, random data is written in  the blocks previously allocated
    to the file. 

EXT2_UNRM_FL 0x0002 
    undelete. When this flag is set and the file is being deleted, the file 
    system code must store enough information to ensure the undeletion of the 
    file (to a certain extent). 

EXT2_COMPR_FL 0x0004 
    compress file. The content of the file is compressed, the file system code
    must use compression/decompression algorithms when accessing the data of 
    this file. 

EXT2_SYNC_FL 0x0008 
    synchronous updates. The disk representation of this file must be kept in 
    sync with it's in core represent
myread: read 1024 char from file descriptor 0
ation. Asynchronous I/O on this kind of 
    file is not possible. The synchronous updates only apply to
    the inode itself and to the indirect blocks. Data blocks are always written
    asynchronously on the disk. 

Some inodes have a special meaning: 

EXT2_BAD_INO 1 
    a file containing the list of bad blocks on the file system. 

EXT2_ROOT_INO 2 
    the root directory of the file system. 

EXT2_ACL_IDX_INO 3 
    ACL inode. 

EXT2_ACL_DATA_INO 4 
    ACL inode. 

EXT2_BOOT_LOADER_INO 5 
    the file containing the boot loader. (Not used yet it seems.) 

EXT2_UNDEL_DIR_INO 6 
    the undelete directory of the system. 

EXT2_FIRST_INO 11 
    this is the first inode that does not have a special meaning. 


6. Directories

A directory is a file containing a list of entries of the following format: 

struct ext2_dir_entry_2 {
        unsigned long  inode;                  /* Inode number */
        unsigned short rec_len;                /* Directory entry length */
        unsigned char  name_len;       
myread: read 1024 char from file descriptor 0
        /* Name length */
        unsigned char  file_type;            
        char    name[EXT2_NAME_LEN];           /* File name */
};


inode 
    points to the inode of the file. 

rec_len 
    length of the entry record. 

name_len 
    length of the file name. 

name 
    name of the file. This name may have a maximum length of EXT2_NAME_LEN 
    bytes (255 bytes as of version 0.5). 

As in all Unix file systems. the first two entries in a directory are "." and
".." which represent to the current directory and the parent directory.


Whenever possible, ext2 uses the following rules to allocate new inodes and 
data blocks: 

    the inode for a new file is allocated in the same group of the inode of 
    its parent directory. 

    inodes are allocated equally between groups. 

    a new block is allocated in the same group as its inode. 

    allocate consecutive sequences of blocks. 
<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #6</H1>

<Pre>
                 
myread: read 1024 char from file descriptor 0
  CS360 NOTES on FILE OPERATIONS

1. File Operations in Unix consists of 5 levels, from LOW to HIGH:
   
1.1. Hardware Level:
     This is the lowest level of file operations. It prepares the hardware 
     device, e.g. disk drive, for file systems
     Examples: fdisk : divide a hard disk into partitions.
               mkfs  : create a file system on a disk, also known as format.
               fsck  : check and repair file systems.
     Many "comercial" file system tools, such as DiskManager, DiskDoctor, etc.
     belong to this catagory.

1.2. System Call Level:
     Every Operating System provides support for BASIC file operations. 
     Unix has the following file operation functions in its kernel:

          kmount(), kumount();            (for mount/umount file systems)

          Kmkdir(), Krmdir(), Kchdir(),   (obvious)
          klink(),  kunlink(),ksymlink(), (for link/remove files) 
          Kchmod(), Kchown(), ktouch()    (change file MODE, owner, time)  

          Kcreat(), Kopen(),          
myread: read 1024 char from file descriptor 0
    (create/open file for R,W,RW,..) 
          Kread(),  Kwrite(),             (read/write opened files) 
          Klseek();                       (change R/W byte position)
          Kclose()                        (close opened files)

          kopendir(), kreaddir(), kclosedir(), (READ directories)
          kreadlink();                    (READ symbolic link files)

          kstat(),  kfstat(), klstat(),   (get file status/information)

     The prefix K emphasizes that these are functions inside the Unix Kernel.

     
                        SYSTEM CALLS:

     Processes use System Calls (syscall for short) to access Kernel functions.
     More will be on this later.  For the time being, consider how to READ a 
     file.
     
     Assume myfile is an existing file. The following C program shows HOW TO
     READ the file (contents).

           #include    &lt;fcntl.h&gt;
           int fd, n;   char myBuffer[1024]; 
           main()
           {
              fd = open("myfile", flags, mode); whe
myread: read 1024 char from file descriptor 0
re flag = O_RDONLY|O_WRONLY|O_RDWR|many others
                                                      mode = permission bits for new file

              if (fd < 0)                  fd is called a FileDescriptor.
                 exit(1);                  if fd < 0, open() call has failed.
                   
              n = read(fd, myBuffer, nbytes);  where nbytes = number of bytes you wish to read.
                                               data will be read into myBuffer[]. 
                                               n = ACTUAL # of bytes read.
              
             lseek(fd, (long)POSITION, 0);     This moves the read Pointer to POSITION bytes from 
                                               the file beginning. NOTE: It's a LONG.
 
             close(fd);                        This closes an opened file.

           }


Examples:  
          #define BLKSIZE 1024

          int fd; char buffer[BLKSIZE];

          fd = open("/dev/fd0", 0);       /* open floppy drive 0 for READ */
     
myread: read 1024 char from file descriptor 0
     lseek(fd, (long)BLKSIZE, 0);    /* skip 1024 bytes ==> to BLOCK#1 */
          read(fd, buffer, BLKSIZE);      /* read one block into buffer */
          lseek(fd, (long)4*BLKSIZE, 0)   /* move to beginning of Block#4 */
          read(fd, buffer, BLKSIZE);      /* read one block into buffer */
          .........................

     The functions open(), read(), write(), lseek(), close() in a User mode 
     program are Library functions.  Each such Library function will issue a
     syscall, causing the process to switch from User mode to Kernel mode.
     Once in K mode, the process will be directed to the corresponding Kenrel
     function, e.g. open() goes to Kopen(), read() goes to Kread(), etc.  
     When the process finishes executing the Kernel function, it exits Kernel 
     and returns to User mode.

     Every syscall causes the process to enter K mode and then back to U mode.
     Switching between Umode and Kmode takes a lot of actions (and time). Data
     transfer between Kmode and Umo
myread: read 1024 char from file descriptor 0
de is especially "expensive". Although it is
     permissible to issue
                         read(fd, buffer, 1);
     syscall to read just ONE byte, it is NOT wise to do so because that one 
     byte would come with a terrible price. Every time you have to cross the 
     boarder to enter the wonderful world of Kernel, do as much as you can 
     rather than in piece meal in order to make the journey worthwhile. In the
     case of READ/WRITE files, the best way is to match what the Kernel does. 
     The kernel reads/writes disks by BLOCK size, which ranges from 1KB to
     8KB. For instance, in Linux, the default BLOCK size is 4KB for hard disks
     and 1KB for floppy disks. 

1.3  Library I/O Functions:
    
     Syscalls allow us to read/write chunks of data, which are just a sequence
     of bytes. They do not know, nor care, about the meaning of the data. 
     However, a user (program) often needs to read/write individual chars or
     lines. If so, the user program would have to do these from/to
myread: read 1024 char from file descriptor 0
 a beffered 
     data area by itself. Most users would consider this "too much"!

     The C library provides a set of standard I/O functions for convenience, as
     well as for run-time efficiency. The library I/O functions include:

     FILE I/O      :  fopen(), fread(); fwrite(), fseek(), fclose();
                      fflush(), 
     char mode I/O :  getc(), putc(), getchar(), putchar(), ungetc()
     line mode I/O :  gets(), puts(), fgets(), fputs();

     formatted I/O :  scanf(), fscanf(), sscanf();
                      printf(), fprintf(), sprintf()

     With the exceptions of sscanf()/sprintf(), which read/write memroy 
     locations, all other library I/O functions are built on top of syscalls 
     in that they ultimately issue syscalls for "actual" data transfer through
     the Operating System Kernel.

1.4. User Commands Level:

     Instead of writing programs, users may use Unix commands to manipulate
     files. Examples of user commands are

            mkdir, rmdir, cd, pwd, ls;
    
myread: read 1024 char from file descriptor 0
        rm, cat, cp, mv, chmod, .....

     Each user command is in fact an executable program (except cd), which 
     typically calls library I/O functions, which in turn issue syscalls to 
     invoke the corresponding kernel functions. Thus, the processing sequence 
     is either
            Command ==> Library I/O function ==> Syscall ==> | Kernel Function
        or
            Command ===========================> Syscall ==> | Kernel Function

1.5. sh Script Files:

     Although much more convenient than syscalls, commands must be entered
     manually, which is often tedious and time-consuming.

     sh scripts are files written in the sh programming language. The sh 
     language includes all valid Unix commands. It also includes additional 
     statements (if, do, for, while, case, etc.) to control the executions.  
     In practice, sh scripts are used extensively in Unix system programming.
     In addition to sh, many other script languages, such as Perl, are also in
     wide use. sh program
myread: read 1024 char from file descriptor 0
ming will be covered later. 


<tITLE>CS460</TITLE>

<BODY bgcolor="#00CCCC" TEXT="#000000" LINK="#990000" VLINK="#0000FF" ALINK="#3300FF"> 

<H1>CS360 CLASS NOTES</H1>
<H2>
<P>
<img src="redball.gif" alt ="*">
<A HREF="planF08.html">Course Plan : Fall, 2008</a>
<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_final_signup.html">Final Demo Signup</a>

<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_460_ta.html">TA Information</a>
<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_grade.html">Lab Grades</a>
<P>
<img src="redball.gif" alt=*">
<A HREF="ta_files/cs360_grade_exam.html">Exam Grades</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes1.html">Notes #1: Introduction to Unix</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="lab1.html">Lab Assignment #1</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes2.html">Notes #2 : Program Development</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes3.html">Notes #3 : Function Calls</a>
<P>
<img src="redball.gif" alt =
myread: read 1024 char from file descriptor 0
"*">
<A HREF="LAB2Pre.html">Lab#2 Pre-work</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="ass.html">Notes #4 : Assembly Programming</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LAB2.html">Lab Assignment #2</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="PROC.html">Notes #5 : Process Management in Unix</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LABsh.html">Lab Assignment #3 : sh Simulator</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="fileops.html">Notes #6 : File Operations</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="syscall.html">Notes #7 : System Calls</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="libio.html">Notes #8 : Library I/O Functions</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="pre4.html">Lab #4 Pre-Work; DUE : in Lab, Sept. 24, 2008</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="IP.07.html">Notes #9 : Newtork Programming</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB4.tcp.html">LAB #4 : File Operations across Networks</a>
<P>
<img src="redball.gif"
myread: read 1024 char from file descriptor 0
 alt = "*">
<A HREF="sh.html">Notes #10 : sh programming</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="ext2fs.html">Notes #11 : EXT2 File System Info</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="ext2fd.html">Notes #12 : EXT2 FS on Floppy Disk</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB5pre.html">LAB #5 Pre-work (DUE : 10-15-08)</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="lab508.html">LAB #5 show block (DUE : 10-15-08)</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="review.html">REVIEW FOR EXAM #1</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="proj08.html">Project Specification</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="project.help.html">Project Organization</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="diagram.html">Project Data Structures</a>

<P>
<img src="redball.gif" alt = "*">
<A HREF="util.html">Project HELP: Utility functions</a>

<P>
<img src="redball.gif" alt = "*">
<A HREF="mkdir_creat.html">Project HELP: HOW TO mkdir_creat</a>
<P>
<img src="redball.
myread: read 1024 char from file descriptor 0
gif" alt = "*">
<A HREF="stat_ls_cd_pwd.html">Project HELP: HOW TO cd_stat_ls_pwd</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="rmdir_rm.html">Project HELP: HOW TO rmdir_rm</a>
<h2>Project Level-2 Help Files</h2>
<P>
<img src="redball.gif" alt = "*">
<A HREF="open_close.html">Project HELP: HOW TO open_close files</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="read_ext2.html">Project HELP: HOW TO read</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="write_ext2.html">Project HELP: HOW TO write</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="cat_cp_mv.html">Project HELP: HOW TO cat_cp_mv</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="mount_umount.html">Project HELP: HOW TO mount_umount</a>




<TITLE>CS360 LAB ASSIGNMENT #1</Title>
<Body bgcolor="#FFFFd8" text="#000000">
<H1>CS360 LAB ASSIGNMENT #1</H1>
<Pre>
                     CS360 ASSIGNMENT #1
              DUE & DEOM: Week of Sept 1, 2008

1. OBJECTIVES
   Partition table, fdisk, structures in C, read/write special files

2 Partition Tab
myread: read 1024 char from file descriptor 0
le:

A disk is usually divided into several partitions. The partitions are recorded
in a partition table in the very first sector of the disk, called the Master Boot 
Record (MBR). Each sector is 512 bytes long. Inside the MBR, the partition table 
begins at the offset 0x1BE. The Partitin Table contains 4 entries, each 16 bytes 
long as defined in the following C structure.

struct partition {
	unsigned char drive;            /* 0x80 - active */

	unsigned char head;             /* starting head */
	unsigned char sector;           /* starting sector */
	unsigned char cylinder;         /* starting cylinder */

	unsigned char sys_type;         /* partition type */

	unsigned char end_head;         /* end head */
	unsigned char end_sector;       /* end sector */
	unsigned char end_cylinder;     /* end cylinder */

	unsigned long start_sector;     /* starting sector counting from 0 */
	unsigned long nr_sectors;       /* nr of sectors in partition */
};

As can be seen, sector and cylinder are all unsiged chars (8
myread: read 1024 char from file descriptor 0
 bits). However, the
cylinder value is actually 10 bits. The highest 2 bits of cylinder value are in  
the leftmost 2 bits of sector, which is only 6 bits.
 
Each partition has a type, which indicates the kind of file system of the 
partition. Consult Linux's fdisk to see the partition types.

If a partition is EXTEND type (type==5), the partition may be further divided 
into more partitions. The extended partitions forms a link-list as the 
following diagram shows. 

Assume P4 is EXT type:
P4's beginSector = MBR
                    P5's beginSector
                    P6's MBR's sector# = MBR
                         (r.e. to P4)     P6's begin sector#
                                          P7's MBR r.e. to P4 --> etc.

Since use fdisk on any hard disk is risky, we shall use a floppy disk for this
assignment. Download the file ~cs360/samples/LAB1/floppyImage.gz to Linux. 
Uncompress and dump it to flopy disk by
                gunzip floppyImage.gz           ( unzip to floppyImage ) 
                dd if
myread: read 1024 char from file descriptor 0
=floppyImage  of=/dev/fd0  ( dump to a FD         )

Then, run       fdisk /dev/fd0  
                 'p' : to print the partition table
                 'q' : to quit fdisk
to see the partition table on the floppy disk. 


                      REQUIREMENTS

Write a C progrom to display the partition table of the FLOPPY disk in 
(1). RAW form, i.e. as per the partiton struct entries (%20), then 
(2). Linux fdisk 'p' output form (%40),
(3). including ALL the extend partitions (%40) <== YOU BETTER DO THIS !!!!.

Turn in a floppy disk containing your work. Also, sign up for demonstration
in SLOAN 327 on Wednesday.
==============================================================================

3. HELP INFO: UNIX System calls for reading/writing files
                   int fd = open("filename", mode);
                   lseek(fd, (long)position, 0); 
                   read(fd, buffer, nbytes);
                   write(fd, buffer, nbytes);
                   close(fd);

The following C program writes/reads flop
myread: read 1024 char from file descriptor 0
py disk sectors

#include &ltfcntl.h&gt
char buf[512];
int sector;

main()
{
   int fd, r;
   sector = 10;                           // sector # 10 (count from 0)  

   fd = open("/dev/fd0", O_WRONLY);       // open /dev/fd0 for WRITE
   strcpy(buf, "cs360 is fun");           // create a string in buf[]
   lseek(fd, (long)sector*512, 0);        // seek to the sector 10
   r = write(fd, buf, 512);               // write 512 bytes to fd
   printf("r=%d bytes written\n", r);     // show number of bytes written
   close(fd);                             // close the file descriptor fd

   fd = open("/dev/fd0", O_RDONLY);       // open /dev/fd0 for READ
   lseek(fd, (long)sector*512, 0);        // seek to sector 10           
   r = read(fd, buf, 512);                // read 512 bytes into buf
   printf("r=%d read  buf=%s\n", r, buf); // show result
   close(fd);                             // close opened file
}

4. Sample Solution:
   ~cs360/samples/LAB1/lab1.bin






<Title>360 PROJECT HELP</Title>
<Body bgcolo
myread: read 1024 char from file descriptor 0
r="#FFFFFF" text="#000000">

<H1>LAB Assignment #5</H1>

<Pre>

/ *************** DUE & DEMO : Oct. 15, 2008 ********************
 
 Write a C program, showblock, which displays the disk blocks of a file 
 in an EXT2 file system. The program runs as follows

       showblock   DEVICE    PATHNAME

e.g.   showblock  /dev/fd0   /a/b/c/d
OR     showblock  ext2Image  /x/y/z    (ext2Image is an EXT2 image file)

 It locates the file named PATHNAME and prints the disk blocks (direct, 
 indirect, double-indirect) of the file.
**************************************************************************/ 

               HOWTO Traverse EXT2 File System Tree

1. REVIEW The Mailman's Algorithm

2. Traverse the EXT2 FS tree
   Given a device (/dev/fd0), containing an ext2 FS, and a pathname, e.g. 
                   /cs360/is/fun
   of a file, find the file.

   NOTE!!! To find a file amounts to finding its INODE. 
           From the inode, you have ALL the information of a file.

  
3. ALGORITHM
  
1. Open the device for 
myread: read 1024 char from file descriptor 0
READ. 
   Read in Superblock (blk #1 for FD to verify it's indeed an ext2 FS. (HOW?)

   (With the SuperBlock read in, you might as well print some of its important
    fields, e.g. nblocks, ninodes, ngroups, inodes_per_group, number of free 
    inodes and blocks, etc.
   )

2. Read in the group descriptor block (block #2 for FD) and access Group0 
   Descriptor. From its bg_inode_table entry, determine where INODEs begin on 
   the disk.  Call it the InodesBeginBlock.  

3. Read in InodeBeginBlock to get the inode of /, which is INODE #2.
   NOTE: inode number counts from 1.

4. Break up pathname into components and let the number of components be n,
   Example:
                            |<----- n = 3  ---->|
         /cs360/is/fun  ==> cs360     is      fun 

   Denote the components by name[0] name[1] name[n-1]

   YOU HAVE DONE THESE BEFORE!!!

6. Start from the root INODE in (3), search for name[0] in its data block(s).
   For DIRs, you may assume that (the number of entries is small so that) it 
   o
myread: read 1024 char from file descriptor 0
nly has DIRECT data blocks. Therefore, search only the direct blocks for 
   name[0].

   Each data block of a DIR inode contains DIR structures of the form 

     [ino rlen nlen .   ] [ino rlen nlen ..  ] [ino rlen nlen NAME ] ....
     [ino rlen nlen NAME] [ino rlen nlen NAME] [ino rlen nlen NAME ] ....
     
   where each NAME is a string (without terminating NULL !!!) of nlen chars. 
   You may use nlen to extract the NAME string, and rlen to advance to the 
   next DIR structure (Listen to lecture in class). 

   If name[0] exists. you can find its inode number.

7. Use the inode number, ino, to locate the corresponding INODE:
   Recall that ino counts from 1.  Use the Mailman's algorithm

               (ino - 1) / 8    and   InodeBeginBlock    
               (ino - 1) % 8 
               
   to read in the INODE of /cs360

   NOTE: the number 8 comes from : for FD, blockSize=1024 and inodeSize=128. 
         If BlockSize != 1024, you must adjust the number 8 accordingly.

   From the INODE of /cs360, 
myread: read 1024 char from file descriptor 0
you can easily determine whether it's a DIR.
   
   (READ how to use S_ISDIR(), S_ISREG() macros by  man stat)
  
   If it's not a DIR, there can't be anything like /cs360/is ...., so give up.

   If it's a DIR and there are more components yet to search (BAD NEWS!)
   you must go on.

   The problem now becomes:
       Search for name[1] in the INODE of /cs360
   which is exactly the same as that of Step (6).

8. Since Steps 6-7 will be repeated n times, you should implement a function
 
     int search(INODE * inodePtr, char * name)
         {
            // search for name string in the data blocks of this INODE
            // if found, return name's inumber
            // else      return 0
         }


7. Then, all you have to do is call search() n times, as sketched below.

   Assume:    n,  name[0], ...., name[n-1]   are globals

   ip --> INODE of /

   for (i= 0; i &lt; n; i++){
       inumber = search(ip, name[i])  
       if (inumber == 0) : can't find name[i], BOMB OUT!
       --------------------
myread: read 1024 char from file descriptor 0
-----------------------------------
       use inumber to read in its INODE and let ip --> this INODE 
   }
  
   // if you reach here, you must have ip --> the INODE of pathname.


8. Extract information from ip --> as required.
   Pat yourself on the back and say: Good Job!

9. EXTRA CREDITS (50%):
   Make your showblock work (CORRECTLY!) for hard disk.

10. SAMPLES SOLUTION in samples/LAB5:
            showblock.bin
    Run it under Linux as
            showblock.bin /dev/XYZ pathname    where XYZ=fd0  for floppy drive,
                                               hda2 for Partition2 of HD, etc.
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#FFFFFF" text="#000000">

<H1>LAB Assignment #5</H1>

<Pre>

/ *************** DUE & DEMO : Week of Oct. 13 2008 ********************
 
 Write a C program, showblock, which displays the disk blocks of a file 
 in an EXT2 file system. The program runs as follows

       showblock   DEVICE    PATHNAME

e.g.   showblock  /dev/fd0   /a/b/c/d
OR     showblock  ext2Image  
myread: read 1024 char from file descriptor 0
/x/y/z    (ext2Image is an EXT2 image file)

 It locates the file named PATHNAME and prints the disk blocks (direct, 
 indirect, double-indirect) of the file.
**************************************************************************/ 

               HOWTO Traverse EXT2 File System Tree

1. REVIEW The Mailman's Algorithm

2. Traverse the EXT2 FS tree
   Given a device (/dev/fd0), containing an ext2 FS, and a pathname, e.g. 
                   /cs360/is/fun
   of a file, find the file.

   NOTE!!! To find a file amounts to finding its INODE. 
           From the inode, you have ALL the information of a file.

  
3. ALGORITHM
  
1. Open the device for READ. 
   Read in Superblock (blk #1 for FD to verify it's indeed an ext2 FS. (HOW?)

   (With the SuperBlock read in, you might as well print some of its important
    fields, e.g. nblocks, ninodes, ngroups, inodes_per_group, number of free 
    inodes and blocks, etc.
   )

2. Read in the group descriptor block (block #2 for FD) and access Group0 
   Descriptor
myread: read 1024 char from file descriptor 0
. From its bg_inode_table entry, determine where INODEs begin on 
   the disk.  Call it the InodesBeginBlock.  

3. Read in InodeBeginBlock to get the inode of /, which is INODE #2.
   NOTE: inode number counts from 1.

4. Break up pathname into components and let the number of components be n,
   Example:
                            |<----- n = 3  ---->|
         /cs360/is/fun  ==> cs360     is      fun 

   Denote the components by name[0] name[1] name[n-1]

   YOU HAVE DONE THESE BEFORE!!!

6. Start from the root INODE in (3), search for name[0] in its data block(s).
   For DIRs, you may assume that (the number of entries is small so that) it 
   only has DIRECT data blocks. Therefore, search only the direct blocks for 
   name[0].

   Each data block of a DIR inode contains DIR structures of the form 

     [ino rlen nlen .   ] [ino rlen nlen ..  ] [ino rlen nlen NAME ] ....
     [ino rlen nlen NAME] [ino rlen nlen NAME] [ino rlen nlen NAME ] ....
     
   where each NAME is a string (without terminating 
myread: read 1024 char from file descriptor 0
NULL !!!) of nlen chars. 
   You may use nlen to extract the NAME string, and rlen to advance to the 
   next DIR structure (Listen to lecture in class). 

   If name[0] exists. you can find its inode number.

7. Use the inode number, ino, to locate the corresponding INODE:
   Recall that ino counts from 1.  Use the Mailman's algorithm

               (ino - 1) / 8    and   InodeBeginBlock    
               (ino - 1) % 8 
               
   to read in the INODE of /cs360

   NOTE: the number 8 comes from : for FD, blockSize=1024 and inodeSize=128. 
         If BlockSize != 1024, you must adjust the number 8 accordingly.

   From the INODE of /cs360, you can easily determine whether it's a DIR.
   
   (Remember S_ISDIR(), S_ISREG() ?)
  
   If it's not a DIR, there can't be anything like /cs360/is ...., so give up.

   If it's a DIR and there are more components yet to search (BAD NEWS!)
   you must go on.

   The problem now becomes:
       Search for name[1] in the INODE of /cs360
   which is exactly the sa
myread: read 1024 char from file descriptor 0
me as that of Step (6).

8. Since Steps 6-7 will be repeated n times, you should implement a function
 
     int search(INODE * inodePtr, char * name)
         {
            // search for name string in the data blocks of this INODE
            // if found, return name's inumber
            // else      return 0
         }


7. Then, all you have to do is call search() n times, as sketched below.

   Assume:    n,  name[0], ...., name[n-1]   are globals

   ip --> INODE of /

   for (i= 0; i &lt; n; i++){
       inumber = search(ip, name[i])  
       if (inumber == 0) : can't find name[i], BOMB OUT!
       -------------------------------------------------------
       use inumber to read in its INODE and let ip --> this INODE 
   }
  
   // if you reach here, you must have ip --> the INODE of pathname.


8. Extract information from ip --> as required.
   Pat yourself on the back and say: Good Job!

9. EXTRA CREDITS (50%):
   Make your showblock work (CORRECTLY!) for hard disk.

10. SAMPLES SOLUTION in samples
myread: read 1024 char from file descriptor 0
/LAB6:
            showblock.bin
    Run it under Linux as
            showblock.bin /dev/XYZ pathname    where XYZ=fd0  for floppy drive,
                                               hda2 for Partition2 of HD, etc.
<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #8</H1>

<Pre>
           CS 360 NOTES #8  Library I/O Functions

1. WHY Library I/O functions?

   Although system calls are the basis for read/write files, they are often
   inconvenient to use. For examples, users may wish to read/write files in 
   logical units most suited to the application, e.g. as lines, chars, etc. 

   Library I/O functions are provided for this purpose. Although not 
   absolutely essential, they provide added convenience and overall 
   efficiency.

2. What are Library I/O functions?

   Almost every OS that supports C also provides Library functions for
   file I/O.  In Unix, Library I/O functions are built on top of the 
   syscall functions. In order to illustrate their intimate 
myread: read 1024 char from file descriptor 0
relationship, 
   we first list a few of them:
      
    Syscall Functions:  open(),  read(),  write(), lseek(),  close();
    Library Functions; fopen(), fread(), fwrite(), fseek(), fclose();

   From their strong similrities, you can almost guess that every library 
   I/O function has its root in a corresponding syscall function. This is
   indeed the case as fopen() relies on open(), fread() makes use of read(),
   etc. The following C programs illutrate their usage.
       
        System Calls                      Library I/O Functions 
  -----------------------------------|----------------------------------------
   #include &lt;fcntl.h&gt;                |     #include &lt;stdio.h&gt;
                                     | 
   int fd, gd;                       |     FILE *fp, *gp;
   char buf[BLKSIZE];                |     char buf[BLKSIZE];
                                     |
   main()                            |     main()  
   {                                 |     {
     int n, total=0;     
myread: read 1024 char from file descriptor 0
            |        int n, total=0;
     fd = open("file1", O_RDONLY);   |        fp = fopen("file1", "r");
     if (fd < 0) exit(1);            |        if (fp == NULL) exit(1); 
     gd = open("file2", O_WRONLY);   |        gp = fopen("file2", "w");
     if (gd < 0) exit(2);            |        if (gp == NULL) exit(2);
     while (n=read(fd, buf, BLKSIZE))|        while (n=fread(buf,1,BLKSIZE,fp))
     {                               |        {
        write(gd, buf, n);           |             fwrite(buf, 1, n, gp);
        total += n;                  |             total += n;
     }                               |        }
     printf("total=%d\n:,total);     |        printf("total = %d\n", total);
                                     |
     close(fd); close(gd);           |        fclose(fp); fclose(gd);
   }                                 |    }  
   ----------------------------------------------------------------------------

    Both programs copy file1 to file2. Since you already know how syscalls
myread: read 1024 char from file descriptor 0

    work, we shall only discuss the program that uses Library I/O functions.

    (1). fopen() uses a string for Mode, where "r" stands for READ, "w" for 
         WRITE. It returns a pointer to a FILE structure. The FILE structure 
         contains a buffer, whose size usually matches that of BLKSIZE. In 
         addition, it also has pointers, counters and status variables for 
         manipulating the buffer.

         fopen() first allocates and initialize a FILE structure in (heap area
         of) the UserImage. It then issues an open() syscall for the file. If 
         the open() syscall succeeds, it records the returned fd in the FILE 
         structure, and returns a pointer to the FILE structure. Otherwise, it
         frees the FILE structure and returns a NULL pointer.

         It is important to note that the FILE structure, which is allocated/
         freed dynamically, is in the process' UserImage. This means that calls
         to Library I/O functions are ordinary function calls, not 
myread: read 1024 char from file descriptor 0
syscalls.  
         
    (2). The programs terminates if any of the fopen() calls has failed. As 
         mentioned above, fopen() returns a NULL pointer on failure.

    (3). Then it uses a while loop to copy the file.  Each iteration of the
         while loop tries to read BLKSIZE bytes from the source file, and 
         write n bytes to the target file, where n is the returned value from 
         fread().

         The general forms of fread() and fwrite() are

                 n = fread(buffer, size, nitems, FILEptr);
                 n = fwrite(buffer,size, nitems, FILEptr);
         
         where size is the data object size in bytes,  nitems is the number of 
         data objects to be READ or WRITTEN, and n is the actual number of 
         objects read or written. These functions are intended for R/W 
         structured data objects. For example, suppose that the buffer area 
         contains data objects of the type
                     struct OBJECT{.....}
         We may use 
           
myread: read 1024 char from file descriptor 0
      n = fwrite(buffer, sizeof(struct OBJEC), M, FILEptr);
         to wirte M objects to a file.  Similarly,
                 n = fread(buffer, sizeof(struct OBJECT), N, FILEptr);
         reads N such objects from a file.

         The above program tries to read/write BLKSIZE bytes at a time. So, it
         has size = 1 and nitems = BLKSIZE. As a matter of fact, any comination
         of size and nitems such that size*nitems = BLKSIZE would also works. 
         However, using a size > 1 may cause problem on the last fread() 
         because the file may have fewer than size bytes left. In that case, 
         the returned n is zero but there are still bytes remaining. To deal 
         with the "tail" part of the surce file, we may add the following 
         lines of code after the while loop:
                 
                 fseek(fp, (long)total, 0);
                 n = fread(buf, 1, size, fp);
                     fwrite(buf,1, n, gp);
                 total += n;
         
         fseek() wor
myread: read 1024 char from file descriptor 0
ks in exactly the same way as lseek(). It positions the 
         file's R/W pointer to the byte location total. From there, we read 
         the file as 1-byte objects. This will read all the remaining bytes 
         and write them to the target file.

    (4). After the copying is done, both files are closed by calling fclose().


3. Algorithms of fread(), fwrite() and fclose()

3-1. The algorithm of fread() is as follows:

     (1). On the first call to fread(), the FILE structure's buffer is empty.
          fread() uses the saved file descriptor fd to issue a
                  n = read(fd, fbuffer, BLKSIZE);
          syscall to fill the local fbuffer. Then, it initializes fbuffer's 
          pointers, counters and status variables to indicate that there is a 
          block full of data in the local buffer.
          It then tries to satisfy the fread() call from the local buffer by 
          copying data to the program's buffer area. If the local buffer does 
          not have enough data, it iss
myread: read 1024 char from file descriptor 0
ues additional read() syscalls to fill 
          the local buffer, until the needed number of bytes is satisfied (or 
          end of file is reached). After copying data to the program's buffer 
          area, it updates the local buffer's pointers, counters, etc. getting
          ready for next fread() request.  It then returns the acutal number of
          objects read to the calling place.

     (2). On each subsequent call to fread(), it tries to satisfy the call from
          the FILE structure's local buffer. It issues a read() syscall to 
          refill the local buffer whenever the buffer becomes empty.

          Thus, fopen() accepts calls from user program on one side and issues
          read() syscalls to the Kenrel on the other. Except for the read() 
          syscalls, all processing of fread() are performed in the User Mode. 
          It enters the Kernel mode only when needed and it does so in a way 
          that matches the Kernel's behavior for best efficiency. It provides 
   
myread: read 1024 char from file descriptor 0
       automatic buffering mechanism so that user programs do not have to 
          worry about such detailed operations.

3-2 fwrite():
 
     The algorithm of fwrite() is similar to that of fread() except for the 
     data movement direction.  Initially the FILE structure's local buffer is 
     empty. On each call to fwrite(), it writes data to the local buffer, and 
     adjust the buffer's pointers, counters and status variable to keep track 
     of the number of bytes in the buffer. If the buffer becomes full, it 
     issues a write() syscall to write the entire buffer to Kernel. 
     
3-3. USE syscalls OR Library Functions?
          
     Based on the above discussion, we can now answer the question of whether 
     to use syscalls or Libray functions to do file I/O?

     fread() relies on read() to copy data from Kernel to the local buffer,
     from which it copies data to the program's buf area. In contrast, read() 
     copies data from Kernel directly to the program's buf area.  Thus, for 

myread: read 1024 char from file descriptor 0
     read/write data in units of BLKSIZEs, read() is inherently more efficient
     than fread() because it only needs one copying operation instead of two. 
     Therefore, in the above C programs, the one that uses syscalls is actually
     more efficient than the other that uses Library I/O functions.  However, 
     if the read/write is not in units of BLKSIZE, fread() and fwrite() may be
     far more efficient. For example, if we insists on R/W one byte at a time,
     fread() and fwrite() would be far better because they enter Kernel Mode 
     only to fill or flush the local buffer, not on every byte. Here, we have 
     implicitly assumed that entering Kernel mode is more expensive than 
     staying in User mode. This is indeed true. 

3-4. Algorithm of fclose():

     fclose() first flushes the local buffer if the file was opened for WRITE.
     Then it issues a close() syscall to close the file descriptor.  Finally 
     it frees the FILE structure and resets the FILE pointer to NULL.

3-5. Other 
myread: read 1024 char from file descriptor 0
Modes for fopen():

     The Mode parameter in fopen() may be specified as

       "r", "w", "a" : for READ, WRITE, APPEND, or with a +, which means to 
                       create the file if it does not exist.
       "r+" : for R/W, without truncating the file.
       "w+" : for R/W, but truncate the file first.
       "a+" : for R/W by appending.

     However, when a file is fopened for both R/W, there may be restrictions on
     the use of mixed fread() and fwrite() calls. The specification requires 
     that at least one fseek() or ftell() be used between every pair of fread()
     and fwrite(). 

     Example: This program yields different results when run under HP Unix and 
              Linux.

              #include &lt;stdio.h&gt;
              FILE fp; char buf[1024]; 
              main()
              { 
                  fp = fopen("t.c", "r+");   /* for both R/W */
                  fread(buf, 1, 20, fp);     /* read 20 bytes */ 
                  fwrite(buf,1, 20, fp);     /* write to the 
myread: read 1024 char from file descriptor 0
same file */
              }


     Linux gives the right result, which modifies the bytes from 20 to 39. But
     HP Unix appends 40 bytes to the end of the original file.

     The difference stems from the non-uniform treatment of R/W pointers in the
     two systems.  Recall that fread()/fwrite() issue read()/write() syscalls
     to fill/flush the local buffer.  While read()/write() use the R/W pointer 
     in the file's OFTE, fread()/fwrite() use the local buffer's R/W pointer in
     the FILE structure.  Without a fseek() to synchronize these two pointers,
     the results depend on how are they used in the implementations. In order 
     avoid any inconsistencies, follow the man pages. For the example program, 
     the results become idnetical (and correct) if you insert a line

                  fseek(fp, (long)20, 0);

     between the fread() and fwrite().

4. Additional Library I/O functions:

4-1. Line mode I/O:
          retString = fgets(buf,nchars,fp); 
          retString = fputs(string,fp)
myread: read 1024 char from file descriptor 0
;
     Examples:
          #include &lt;stdio.h&gt;
          FILE *fp,*gp;
          char buf[256]; char *s="this is a string";
          main()
          {
             fp = fopen("source", "r");
             gp = fopen("target", "w");
             fgets(buf, 256, fp);    /* read a line of upto 255 chars to buf */
             fputs(buf, 256, gp);    /* write string to target file */

          }
    
     When fp is stdin or stdout, fgets() and fputs() are shortened to
             gets(buf);     /* assume char buf[] is big enough */
             puts(string);  /* print string to stdout */

4-2. Char Mode I/O:
          int c;         /* NOTE the int type */       
          c = getc(fp);  /* get a char from fp, return EOF on end of file */
              ungetc(c, fp); /* push c back to stream */

          putc(c, fp);   /* put a char to fp */
     
     The reason for the int type of c is that the EOF symbol is usually an int
     value. 

   For fp = stdin or stdout,  c = getchar();  putchar(c); may be 
myread: read 1024 char from file descriptor 0
used instead.
   For run time efficiency, getchar() and putchar() are often NOT the shortened
   versions of getc() and putc(). Instead, they may be implemented as Macros
   in order to avoid an extra function call.
   Examples:

     (1). /* file copy using getc(), putc() */
          #include &lt;stdio.h&gt;
          FILE *fp,*gp;
          main()
          {
            int c;  /* for testing EOF */
            fp=fopen("source", "r");
            gp=fopen("target", "w");
            while ( (c=getc(fp)) != EOF )
               putc(c,gp);
            fclose(fp); fclose(gp);
          }

    (2). /* Linux's man pages contain lots of 0x08 code. It is used as follows:
             0x08TT0x08HH0x08II0x08SS  high light the word THIS.
             t_0x08h_0x08a_0x08t_0x08  display the _ under that.
             However, a _ not immediately followed by 0x08 is part of the text.

             The following program eliminates the 0x08 code from the outputs 
             of man. EXPLAIN HOW DOES IT WORK ? */

    
myread: read 1024 char from file descriptor 0
         #include &lt;stdio.h&gt;
             main()
             {  int c, nextc;
                while ( (c=getchar()) != EOF ){
                   if (c == 0x08){
                       c = getchar();
                       continue;
                   }
                   if (c == '_'){
                       nextc=getchar();
                       if (nextc == 0x08)
                       continue;
                       ungetc(nextc,stdin);
                   }
                   putchar(c); 
                }
             }


4-3. FORMATTED I/O:
     These are perhaps the most commonly used I/O functions.
     Foratted Inputs: ( FMT=format string )
                      scanf(FMT, &items);    /* from stdin */     
                     fscanf(fp, FMT, &items);
                     sscanf(buf,FMT, &items);  
     Formatted Outputs:     
                      printf(FMT, items);   /* to stdouot */
                     fprintf(fp, FMT, items);
                     sprintf(buf,FMT, items);
     
     Note 
myread: read 1024 char from file descriptor 0
that sscanf() and sprintf() are not really I/O functions but
     string assemble/extraction funcions.
      

4-4. Other Functions:

     fseek(), ftell(), rewind()
     feof(), ferr(), fileno()

     freopen(), fdopen()
     setbuf(), setvbuf()
     popen()
   





<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 HELP #5</H1>

<Pre>
   
            360 PROJECT HELP :  HOWTO_MKDIR_CREATE

make_dir()
{
1. Ask for a pahtname, e.g. /a/b/c  or a/b/c, etc.

2.  if (pathname[0] == '/') 
        dev = root->dev;
     else
        dev = cwd->dev;
3. Let  
     parent = dirname(pathname);   parent= "/a/b"
     child  = basename(pathname);  child = "c"

4. Get the In_MEMORY minode of parent:

         ino  = getino(&dev, parent);
         pip  = iget(dev, ino); 

   Then, verify :
         parent INODE is a DIR AND
         child des NOT exists in the parent directory;
               
5. Call 
          r = mymkdir(pip, child);
 
6.  return(r);

} 


int mymkdir(MINODE *pip, char *name)
{
1. 
myread: read 1024 char from file descriptor 0
pip points at the parent minode[] of "/a/b", name is a string "c") 

2. allocate an inode and a disk block for the new directory;
       call   inumber=ialloc(dev),      bnumber=balloc(dev)
   where dev=pip->dev, i.e. SAME dev as the parent directory.

3. call mip = iget(dev,inumber) to load the inode into a minode[] (in order to
   wirte contents into the intended INODE in memory).

4. Write contents into mip->INODE, including:
        (same as the root directory in mkfs)
        INOODE.i_block[0] = bnumber; 
        all other INODE.i_block[] = 0;
        mip->dirty = 1;  /* mark dirty */

5. call  iput(mip);  
   which should write the new INODE out to disk.

  // C CODE:
  //**********************************************************************
  mip = iget(dev,inumber);

  mip->INODE.i_mode = 0x41ED;		/* DIR and permissions */
  mip->INODE.i_uid  = running->uid;	/* Owner Uid */
  mip->INODE.i_gid =  running->gid;	/* Group Id */
  mip->INODE.i_size = 1024 ;		/* Size in bytes */

  mip->INODE.i_links_count 
myread: read 1024 char from file descriptor 0
= 2;	/* Links count */

  mip->INODE.i_atime=mip->INODE.i_ctime=mip->INODE.i_mtime = time(0L); 

  mip->INODE.i_blocks = 2;     	/* Blocks count in 512-byte blocks */
  mip->dirty = 1;               /* mark dirty */

  for (i=0; i<15; i++)
    mip->INODE.i_block[i] = 0;
  mip->INODE.i_block[0] = znumber; 

  iput(mip);
  //**********************************************************************


6. Write the . and .. entries into a buf[ ] of BLOCK_SIZE; 
   write buf[] to the disk block allocated to this directory;

// C CODE:
//****************************************************************  
  dp = (DIR *)buf;

  dp->inode = inumber;		/* Inode number */
  strncpy(dp->name, ".", 1);    /* File name */
  dp->name_len = 1;		/* Name length */
  dp->rec_len = 12;		/* Directory entry length */

  cp = buf; 
  cp += dp->rec_len;            /* advance by rec_len */
  dp = (DIR *)cp;

  dp->inode = parent->ino;      /* Inode number of parent DIR */
  dp->name_len = 2;		/* Name length */
  strncpy(dp->name, "..", 2);
myread: read 1024 char from file descriptor 0
   /* File name */
  dp->rec_len = BLOCK_SIZE - 12;/* last DIR entry length to end of block */

  put_block(dev, bnumber, buf);


7. Finally, enter name into parent's directory 
   Read parent's data block into buf[];

     !!! LISTEN TO LECTURE CAREFULLY ON HOW TO DO THESE !!!:

// EXT2 DIR entries: Each DIR entry has rec_len and name_len.
// (1). rec_len = name_len+8 raised to the next multiple of 4 bytes.
//      So,       ideal_len = [(name_len + 8 + 3)/4] * 4
// (2). When deleting an entry, first zero out its inode number, then absorb
        its rec_len to the previous entry's rec_len ==> which effectively
        "hides" the deleted entry.

        If the deleted entry is the first in a data block, then there is no
        previous entry to absorb its rec_len. However, the entry is "deleted"
        since its inode number is zero. The idel_len of such entries is 0.

// (3). (2) ==> when entering a name into DIR, should look for an entry whose
//      rec_len - ideal_len >= new entry's ideal_len. Then, 
myread: read 1024 char from file descriptor 0
reduce this entry's
//      rec_len to its ideal_len and enter the new entry in the remaining space

//      The new entry's rec_len = remain = this entry's (rec_len - ideal_len).
// (4). When scaning a DIR block, must check for block ending; allocate new
//      data block if needed.


(As said before, you may assume directories only have direct data blocks.)
        
8. Write parent's data block back to disk;

9. inc parent inodes's link count by 1; touch its atime and mark it DIRTY

10. iput(pip);

}  

creat_file()
{
  This is similar to mkdir() except : its inode's mode field is set to
  a REGULAR file, permission bits to (default) rw-r--r--, and no data 
  block is allocated for it.
} 


int mycreat(parent,name) MINODE *parent; char *name;
{
    Same as my_mkdir() except NO data block and do NOT inc parent's link count.
}  




<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 HELP INFO</H1>
<Pre>
   
                 HOWTO_MOUNT_UMOUNT

// ASSUME: newfs  is a file containing an E
myread: read 1024 char from file descriptor 0
XT2 filesys image.

mount()    /*  Usage: mount filesys mount_point OR mount */
{

1. Ask for filesys (a pathname) and mount_point (a pathname also).
   If mount with no parameters: display current mounted filesystems.

2. Check whether filesys is already mounted: 
   (you may store the name of mounted filesys in the MOUNT table entry). 
   If already mounted, reject;
   else: allocate a free MOUNT table entry (whose dev == 0 means FREE).

3. open filesys for RW; use its fd number as the NEW dev;
   Check whether it's an EXT2 filesys: if not, reject.

4. find the ino, and then the minode of mount_point:
    call  ino  = get_ino(&dev, pathname);  to get ino:
    call  mip  = iget(dev, ino);           to load its inode into memory;    

5. Check mount_point is a DIR.  
   Check mount_point is NOT busy (e.g. can't be someone's CWD)

6. Record NEW dev in the MOUNT table entry;

   (For convenience, store the filsys name in the Mount table, and also
                     store its ninodes, nblocks)

7. Mark mount_p
myread: read 1024 char from file descriptor 0
oint's minode as being mounted on and let it point at the
   MOUNT table entry, which points back to the mount_point minode.

8. return 0;

}
  

umount(filesys) char *filesys;
{

1. Search the MOUNT table to check filesys is indeed mounted.

2. Check whether any file is still active in the mounted filesys;
      e.g. someone's CWD or opened files are still there,
   if so, the mounted filesys is BUSY ==> cannot be umounted yet.
   HOW to check?      ANS: by checking all minode[].dev

3. Find the mount_point's inode (which should be in memory while it's mounted 
   on).  Reset it to "not mounted"; then 
         iput()   the minode.  (because it was iget()ed during mounting)

4. return(0);

}  
  

                  IMPLICATIONS of mount:

With mounting, you must modify the
 
               ino = get_ino(&dev, pathname)

function to support "cross mounting point" operations.

Assume :    mount newfs /a/b/c   ==> newfs has been mounted on /a/b/c.
 
Case 1: When traversing the pathname /a/b/c/x/y, once you reac
myread: read 1024 char from file descriptor 0
h /a/b/c,
        you should see that /a/b/c has been MOUNTed on (because its mounted
        flag = 1). You should

        Use the minode's mountTable pointer to locate the MOUNT table entry.
        From newfs's  dev number, you can get its / inode into memory.
        THEN, continue to look for x/y under this / inode.

Case 2: Assume that you are at the directory
               /a/b/c/x/
        and you are trversing upward. e.g.
               cd  ../../
        which will cross mount point at /a/b/c.
        THINK ABOUT HOW TO HANDLE THIS CASE. LISTEN TO LECTURE.

<TITLE>CS360 NOTES#2</Title>
<Body bgcolor="#00CCCC" text="#000000">

<H1>CS360 NOTES #1 : Introduction to Unix</H1>

<Pre>

1. The Unix File System Tree:
   The Unix file system is organized as a tree, as shown below.


            |--> bin 

            |--> dev

            |--> etc

     / ---> |--> lib

            |--> sbin
                           |--> bin
            |--> tmp       |--> include --> .h files 
                         
myread: read 1024 char from file descriptor 0
  |--> lib
            |--> usr ----->|--> local
                           |--> man
            |--> user      |--> X11 ------>
       
            |--> vmunix 


   Each NODE of the tree is a FILE. Unix files have the following types:

2. Unix File Types:

   (1). Directory files : 
        These are directories. A directory may contain other directories 
        and (non-directory) files.

   (2). Non-directory files : 
        Non-directory files are either REGULAR or SPECIAL files (SEE BELOW).
        Note that Non-directory files can only appear as leaf-nodes in the 
        tree.

        (2).1  REGULAR files : 
               Regular files are also called ORDINARY files. They contain 
               either ordinary text or executable binary codes.

        (2).2  SPECIAL files : 
               Special files are entries in the /dev directory. They represent
               I/O devices, and are further classified as . 

               CHAR  special files, e.g. /dev/tty0, /dev/modem.
               BLOCK
myread: read 1024 char from file descriptor 0
 special files, e.g. /dev/fd0,  /dev/hda.
               Other types such as Network special files.

   (3). Soft LINK files:
        These are Regular files whose contents are pathnames of other 
        files. As such they are used to reference other files.
        Example: the Unix command
                 ln   -s   aVeryLongFileName   myLink
        sets up  myLink  as a soft-link to  aVeryLongFileName.  Access to 
        myLink will be re-directed to the actual file aVeryLongFileName.

3. Pathname:

   The ROOT node of a Unix file system tree, symbolized by /, is called the 
   "root directory".

   Each node of the tree is represented by a PATHNAME of the form

             /a/b/c/d    OR    a/b/c/d

   So, each Unix file is specified by a pathname.

*   A pathname is ABSOLUTE if it begins with a /.  
*   A pathname is RELATIVE if it does not begin with a /. 
 
    A relative pathname starts from the Current Working Directory (CWD).
    When a user login to Unix, the CWD is usually set to his/hers HOME
myread: read 1024 char from file descriptor 0
 
    directory.  The CWD can be changed by using the cd  command.  
    The pwd command prints the absolute pathname of the CWD.
            
4. Contents of Directories Under / :  

   /bin : commonly used system commands, e.g ls, date,...
   /dev : Special files.
   /etc : Unix system maintenance files.
   /lib : Unix system libraries.
   /sbin: Unix system administration commands.
   /tmp : temporary files.
   /usr : /usr/bin:      more executable files such as  cc,  gzip.
          /usr/include : .h files
          /usr/lib:      specific library files.
          /usr/man     : on-line manual directory.
          /usr/X11     : X-Window system.

   /user: user home directories.
   /vmunix : bootable Unix system image file.


5. Login Process:

(1). User Account:
     Each user is assigned an account by the system administrator. In a stand-
     alone Unix system, user accounts are maintained in a file named     
                        /etc/passwd.
     In a network system composed of many Unix machines, 
myread: read 1024 char from file descriptor 0
such information is 
     usually maintained on a Server machine, which provides other Unix machines
     with a single copy of the user account information. 
 
     A user account typically contains the following fields, separated by :

     root:aXuoPkB4hz:0:0:root:/root:/bin/bash
     kwang:Pir2NYB4Bqi9I:501:100:k.c.wang,cs faculty:/home/kwang:/bin/bash
     ----- ----------------- --- ------------------- ----------- --------------
  username: password :gid:uid:    full name      : HOME dir  : programToExecute

(2). Login Process:
     
     A PROCESS is a sequence of executions regarded as a single entiry by the 
     system. In Unix, every activity is carried out by a process.  
     When Unix starts, it generates a special process, P1, which executes the 
     file   /etc/init.  For this reason, P1 is also called the INIT process. 
     It is the parent of all user processes in the following manner:

     P1 reads some system configuration files to find out the terminals 
     supported by the system.  
myread: read 1024 char from file descriptor 0
For each terminal, it generates a child process 
     on that terminal. Then, it waits for any of the terminal process to 
     terminate.  When a terminal process terminates (by user logout), P1 
     regenerates another child process on that terminal. 

     Each child process opens 3 (stream) FILEs on its own terminal. These FILEs
     are known as 

          stdin : the terminal's Keyboard, for inputs;
          stdout: the terminal's Display, for outputs;
          stderr: also the Display, for error outputs;

     Then the child process executes /etc/getty, which displays the message  
          login:  
     on its stdout, awaiting a user to login.  
     At this moment, the login process is not yet associated with any user.

     When a user tries to login, the login process validates his/her username 
     and password in /etc/passwd. If the user has a valid account, the login 
     process takes on the user's uid and gid, thereby becoming the user's 
     process.  It then sets the CWD to the user'
myread: read 1024 char from file descriptor 0
s HOME directory and executes 
     the program specified in the user's account. That program is usually a 
     version of the Unix shell, e.g. bash, csh, etc.
    
     The Unix shell is a command interpreter.  It displays a prompt
         %     (OR some other symbol, which can be set by the usr)
     and waits for the user to input commands.

     A command is simply an executable program. When the user enters a command,
     the sh process (i.e. the user process that's executing the sh) will

       (1). generate a child process to perform the command;
       (2). wait for the child process to terminate;
       (3). prompt the user for commands again;  
            The sh process terminates when it sees logout or END_OF_FILE.
   
     NOTE that the command is NOT executed by sh itself but by a child process.

     Using this feature of sh, a user can start many processes, each performing
     a different task.  For example, the command (line)

            %   ls & date & a.out  &
                --   ---
myread: read 1024 char from file descriptor 0
-   ----- ----- 
                C1    C2     C3   NoWait

     will start 3 children processes, C1, C2, C3, which execute ls, date, a.out
     respectively, and cause the sh to prompt again without waiting for any of
     the child processes to terminate.  This is called MULTI-TASKING.

     In this example, all 4 processes will run CONCURRENTLY (which means IN 
     PARALLEL in a logical sense). Among them, the sh runs in the FOREGROUND 
     while others run in the BACKGROUND.  Only the foreground process can 
     receive inputs from stdin.
     The  fg  command can be used to raise a background process to foreground.
     The  ps  command displays all the ProcessId (PID) of a user.


6. REVIEW QUESTIONS:

(1). The   ls -l   command lists the contents of a directory:

drwxr-xr-x   root   bin     2048  Dec 23 09:22 bin/
lrwxrwxrwx   root   root      23  Dec 20 20:15 kwang -> /home/kwang/public_html
-rw-r--r--   root   root  433387  Dec  8 21:52 vmlinuz
-rwxr-xr-x   kwang  kwang  21400  Jan 10 07{30 a.out


myread: read 1024 char from file descriptor 0
EXPLAIN THE MEANING OF EACH field?

(2). What are the permission bits of a file, and what do they do?
     
(3). Each user has a UserId (uid) and a GroupId (gid).  
     How does a user get hid/her uid and gid?
     What are the uid and gid used for? 

(4). The owner of a file can use the Unix command
         chmod  0766  fileName  
     to change the mode of fileName. What are the resulting permissions?

(5). What does the x bits of a directory mean?

(6). Unix has a special user, called the SuperUser or the Root, who can access
     any file. What's the reason for having such a Super user?

(7). How does a user acquire a Unix process?

(8). How many processes will be executing with the sh command?
         %  a & b & c & d &
     Which one is the foreground process?

(9). The Unix command    ls | more
     sets up 2 processes, one executes ls and the other executes more, in such 
     a way that the outputs of the first process ls are PIPEd to the second 
     process more. 
     How many processes will be
myread: read 1024 char from file descriptor 0
 executing with the sh command?
         %  a | b | c | d 
 








<TITLE>CS360 NOTES#3</Title>
<Body bgcolor="#00FFCC" text="#000000">

<H1>360 NOTES #2 : PROGRAM DEVELOPMENT</H1>

<Pre>

1. OBJECTIVES
   To understand the steps involved in program development.

2. THE STEPS:

(1). Source file : A text editor, such as vi or emacs, may be used to create
     one or more source program files in some language(s). Typical languages
     are C and Assembly.

(2). Consider C programs first. Let the source of a C program be written as
     two files, t1.c and t2.c,  as shown below:

/********  t1.c file *************************************************/
     extern int g;                      /*  IMPORT g    */
     int      sum;                      /* global variable */
     main(int argc, char *argv[ ])      /* main function */
     {
       int a,b;                         /* local variables */
       a = 1;
       b = 2;
       g = 100;                         /* reference extern variable */
       sum = mys
myread: read 1024 char from file descriptor 0
um(a,b);                /* call mysum(), passing a,b */
       printf("sum=%d g=%d\n",sum, g);  /* call printf() */
     }
/**********************************************************************/

/*******  t2.c file **************************************************/
     int g;                             /* global variable  */
     int mysum(int x, int y)            /* function heading */
     {
        return x+y+g;                   
     }              
/*********************************************************************/

(3). To convert these source files into an executable, we typically use the 
     cc command (In Linux, cc is linked to gcc, so they are the same).

        cc  t1.c t2.c       =====> this generates an executable file  a.out

(4). WHAT'S cc or gcc?
     cc is a program, which consists of 3 major steps:
     
     1. Convert C source files to Assembly code files:
        The first step of cc is to invoke the C COMPILER, which translates
        the .c files into .s files containing A
myread: read 1024 char from file descriptor 0
SSEMBLY code for the 
        target machine.  

     2. Convert ASSEMBLY Code to OBJECT code:
        Every machine has its own set of machine instructions. Users may 
        write programs in an ASSEMBLY language for a specific machine.

        An ASSEMBLER is a program, which translates assembly code into 
        machine code in binary form. The resulting .o files are called 
        OBJECT code. 

        The second step of cc is to invoke the ASSEMBLER to translate the
        .s files into .o files.

        Each .o file consists of 3 parts:
         
              a CODE section consisting of machine instructions;
              a DATA section consisting of all GLOBAL and static variables; 
              a SymbolTable  containing all variable and function names
                             and their attributes.

     3. LINKING: 
        A program may be composed of several pieces of .o files, which are 
        usually dependent on one another.  In addition, the .o files may call
        C library f
myread: read 1024 char from file descriptor 0
unctions (e.g. printf), which are NOT present.

        The last step of cc is to invoke the LINKER, which puts all the .o 
        files and the needed library functions together into a single 
        executable binary file, a.out. More specifically, the LINKER does the 
        following:

        .Combine all the code sections of the individual .o files into a
         single CODE section,

        .Combine all the data sections into a single DATA section,

        .Use the SymbolTables to resolve the cross references among the
         inidvidual .o files. 

         For instance, when the compiler sees sum = mysum(a,b), it does NOT 
         know where mysum is. So it leaves a blank in the .o file for the
         entry address of mysum. When the linker puts t1.o t2.o together, it 
         knows where mysum is since mysum is recorded in the SymbolTable
         of t2.o. So the linker can replace the blank in t1.o with the address
         of mysum. Similarly for other symbols that are cross referenced.
myread: read 1024 char from file descriptor 0


        If everything goes well, the linker will write the resulting combined 
        file as a.out, which is the executable binary.
 
3. STATIC Vs. DYNAMIC Linking:
   There are two ways to create a.out, known as static and dynamic linking.
   In static linking, the linker includes every needed library function in 
   a.out. This makes a.out self-sufficient but usually very large.
     
   In dynamic linking, the library functions are not included in a.out but 
   calls to such functions are recorded in a.out as a directives to the LOADER.
   When a.out is to be executed, the system LOADER will load both a.out and 
   its needed libaray files into memory. 

   The main advantages of dynamic linking are:
       .The size of every a.out is reduced.
       .Once loaded into memory, the library functions can be SHARED.
      . Modifying library functions does not have to re-linking any a.out file.
 
   This kind of libraries are known as Dynamic Linking Libraries (DLLs).

4. WHAT's in a.out?
   a.out is the e
myread: read 1024 char from file descriptor 0
xecutable binary file, which usually has the format:
   ---------------------------------------------------------------------------
     header      : The header of a.out contains its sizes in bytes: 
                       tsize = size of Code section;
                       dsize = size of Data section;
                       bss_size=size of bss section;
                       Needed library functions (if dynamic linked).

     Code Section: this is the combined code area of a.out; it always begins
                   with the standard C startup file crt0.o, which calls main. 

     Data Section: The Data section contains INITIALIZED global and static data
                   objects. Examples of static data are static variables and 
                   format strings in printf(fmt, .....).

     bss (Block Started by Symbol) Section: un-initialized statics and globals
   ---------------------------------------------------------------------------
   NOTE that the bss section is NOT included in a.out. However,
myread: read 1024 char from file descriptor 0
 its size
   is recorded in the header of a.out as bss_size.

5. Execution of a.out
   The sh command
       %  a.out ONE TWO THREE 
   executes a.out with the strings ONE TWO THREE as command-line parameters.
   As explained before, sh will create a child process to execute a.out.
   
   After creation, The child process does the following

   (1). It reads the header of a.out to determine the Total memroy size needed:
             TotalSize = tsize + dsize + bss_size + stackSize
        where the stackSize is usually a default value of say, 4K bytes.

   (2). It then allocates a memory area of TotalSize bytes. Conceptually, we
        may assume that the allocated memory area is a single piece of
        contiguous memory. It then loads a.out (without the header) into this 
        memroy area, with the Code section at the Low address end. The High
        address end will be the stack area. Thus, the stack grows downward.

   (3). The main() function of  a.out  may be written as 
              main(int arg
myread: read 1024 char from file descriptor 0
c, char *argv[ ], char *env[ ])
        As will be shown later, parameters are passed through the stack. 

   (4). It then starts to execute crt0.o, whcih calls main().
  
   (5). The execution image of a process is shown by the figure:

            LowAddress                                 HighAddress 
                      |  CODE  |  DATA | HEAP | STACK |

        where the HEAP is for dynamic memory allocations (by malloc() in C or
        new() in C++) and STACK is the run-time stack.
        Subject to a certain maximum size limit, both HEAP and STACK may be 
        expanded automatically by the Unix operating system.

   (6). Termination:
        The process that executes a.out may terminate in ONE of 4 ways:

        1. The process calls exit(bye_value), which does some clean-up work 
           (such as flush stdout, close I/O stream FILEs) and then issues an 
           _exit(value) system call, which causes the process to enter the Unix
           Kernel to die. For instance, when the process ret
myread: read 1024 char from file descriptor 0
urn from main() to
           crt0.o, it calls exit(0). Alternatively, the process may call
           exit(byte_value) anywhere in a.out to terminate (without going back
           to crt0.o). 

        2. Inside a.out, the process may call _exit(value) anywhere to enter 
           Kernel to die IMMEDIATELY. Reason: if you want to die in a such a 
           hurry, why bother to clean up your room first?
           
           When a process dies, it records the byte_value in the _exit() call
           as the "cause of death" on its body, notifies its parent that it is
           dying and then becomes a ZOMBIE. The parent (either the original 
           parent or P1) will find the ZOMBIE, get its pid and "cause of death"
           value via the 
                         dead_child_pid = wait(&cause_of_death);
           system call, where cause_of_death has 2 bytes containing
                              |exitValue|signal#|
           Naturally, only one of the bytes would be non-zero, WHY?

        3.
myread: read 1024 char from file descriptor 0
 While executing, the process encounters an error (in YOUR a.out of
           course), which is recognized and "caught" by the CPU. The process is
           forced into the Unix kernel by a "trap". Once in kernel, it converts
           the trap error (type) into a magic number called a SIGNAL number and
           delivers the signal to itself, causing it to die. In this case, the
           ZOMBIE's "cause of death" is the signal number, and we may say that
           the process has died abnormally. 

           Examples: Try to run these C programs
                      int *p;
                      main(){   *p = 1;  }

                      int a,b,c;
                      main(){   c = a/b; }

                      main(){   main();  }

           What do you see and WHY?


        4. Killed by a signal, which may originate from hardware (interrupts)
           or sent by another process via the 
                      kill pid 
           command, which uses the kill(pid, singal#) system call.
      
myread: read 1024 char from file descriptor 0
     Example:  If you run the C program:
                        main()
                        {
                           while(1);
                        }       
           What would happen and how do you get out the mess?





<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #3</H1>

<Pre>
            360 NOTES #3 Function Calls in C

Consider the program:

         main()
         { int a,b,c;
           a = 1; b = 2; c = 3;
           c = mysub(a,b);
           printf("c=%d\n", c); 
         }

         int mysub(int x, int y)
         {
           int u, v;
           u = 4; v = 5;
           return(x+y+u+v);
         }

The topics here are:
     ----------------------------------------------
     Function call conventions in C and stack usage.
     ----------------------------------------------

(1). When we execute a.out, a process image is created in memory, which looks 
     (logically) like the following:
   
     lowAddress                      HighAddress
     
myread: read 1024 char from file descriptor 0
     -----------------------------
          | Code | Data |  stack      |
          ----------------------------- 
(2). CPU registers:

     Every CPU has:

        PC register, which points to the next instruction
                     to be executed by the CPU.
        SP register, which points to the current top of 
                     the stack. (esp register)
        FP register, which points to the stack Frame of the
                     current active function (ebp register).
        A register for return value (eax register).

(3). Our main() is called by the C startup code, crt0.o. When crt0.o calls 
     main(), it pushes the return address (its current PC contents) onto stack,
     and enters main(). When main() is entered, the stack contains:

     HighAddress      ---------->              LowAddress
  
       --------------------------------------------- 
       XXXX|PC|
       --------------------------------------------- 
            ^ 
            SP 

     with SP pointing at the returnPC (w
myread: read 1024 char from file descriptor 0
here crt0.o called main().

(4). Upon entry, every C function does the following
     (4).1  push FP into stack;   this saves the FP register
     (4).2  let  FP point at the stack top, i.e. point at the saved FP.
     (4).3  shift SP downward to allocate space for local variables.
   
     For this example, there are 3 local variables, a,b,c, each 4 bytes long. 
     The stack becomes:

     HighAddress      ---------->              LowAddress
                  a  b  c 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  |
       --------------------------------------------- 
               ^         ^ 
               FP        SP 
               
(5). a=1; b=2; c=3;  The values 1,2,3 go to the locations of a,b,c, which are
     at -4, -8, -12 bytes from where FP is pointing at, respectively. 
     These are expressed as -4(FP), -8(FP), -12(FP) in assembly code.

(6). main() calls mysub() by  c = mysub(a,b);

     The compiled code for the function call consists of:

         PUSH
myread: read 1024 char from file descriptor 0
 parameters in reverse order:
              push b's value onto stack, push a's value onto stack,
         CALL mysub
              which pushes the current PC (contents) onto stack and replaces PC
              with the address of mysub, causing the CPU to enter mysub().
 
     When control just enters mysub(), the stack becomes

     HighAddress      ---------->              LowAddress
                  a  b  c 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  | 2| 1|PC|
       --------------------------------------------- 
                                  ^ 
                                  SP 

(7). mysub() is written in C.  Its actions are the same as those of main():
        push FP; 
        let FP point at the saved FP, and
        shift SP downward to allocate locals u,v. 
     Then the stack becomes
         
     HighAddress      ---------->              LowAddress
                  a  b  c               u  v 
       --------------------------------------------- 
  
myread: read 1024 char from file descriptor 0
     XXXX|PC|FP|  |  |  | 2| 1|PC|FP|  |  |
       --------------------------------------------- 
                                     ^     ^ 
                                     FP    SP 
(8). While in mysub(), 
 
               -----------------------------
               WHERE ARE x,y? WHERE ARE u,v?
               -----------------------------

     For this example, the parameters a, b are at 8(FP) and 12(FP), i.e at 
     where FP points at + 8 bytes, + 12 bytes.  Local variables u, v are at 
     -4(FP) and -8(FP).

     The stack area visible to a function (parameters and locals) is called 
     a stack FRAME (like a frame of movie). Thus, FP is called the stack
     FramePointer.
 
(9). Return from called function:

     When mysub executes return(expression); it puts the value of the 
     expression in the return value register (eax for 486/Pentinum CPUs).
     Then, it deallocates the local variables by

       .copy FP into SP;   stack top now contains the saved FP.
       .pop stack into FP; t
myread: read 1024 char from file descriptor 0
his restores FP, leaving the return PC on top of 
                           the stack.
       .RET   RET pops the stack top into PC register, causing the CPU to 
              execute from the "return address" saved earlier.

(10). Upon return, the caller function copies the contents of the return value
      register into c, then it pops the parameters a,b off the stack (by adding
      8 to SP). This restores the stack to the same situation before the call.
  
      Then it continues to the next statement.





<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                HOWTO open_close_lseek

int open_file()
{
  1. ask for a pathname and mode to open:
         You may use mode = 0|1|2|3 for R|W|RW|APPEND

  2. get pathname's inumber:
         ino = getino(&dev, pathname);

  3. get its Minode pointer
         mip = iget(dev,ino);  

  4. check mip->INODE.i_mode to verify it's a REGULAR file and permission OK.
     (Optional : do NOT check FILE 
myread: read 1024 char from file descriptor 0
type so that we can open DIRs for RW)
     
     Check whether the file is ALREADY opened with INCOMPATIBLE type:
           If it's already opened for W, RW, APPEND : reject.
           (that is, only multiple R are OK)

  5. allocate an OpenFileTable (OFT) entry and fill in values:
         oftp = falloc();       // get a FREE OFT
         oftp->mode = mode;     // open mode 
         oftp->refCount = 1;
         oftp->inodeptr = mip;  // point at the file's minode[]

  6. Depending on the open mode 0|1|2|3, set the OFT's offset accordingly:

      switch(mode){
         case 0 : oftp->offset = 0; 
                  break;
         case 1 : truncate(mip);        // W : truncate file to 0 size
                  oftp->offset = 0;
                  break;
         case 2 : oftp->offset = 0;    // RW does NOT truncate file
                  break;
         case 3 : oftp->offset =  mip->INODE.i_size;  // APPEND mode
                  break;
         default: printf("invalid mode\n");
                  return(-1)
myread: read 1024 char from file descriptor 0
;
      }

   7. find the SMALLEST i in running PROC's fd[ ] such that fd[i] is NULL
      Let running->fd[i] point at the OFT entry

   8. update INODE's time field. 
      for W|RW|APPEND mode : mark Minode[] dirty

   9. return i as the file descriptor
}


truncate(MINODE *mip)
{
  1. release mip->INODE's data blocks;
     a file may have 12 direct blocks, 256 indirect blocks and 256*256
     double indirect data blocks. release them all.
  2. update INODE's time field

  3. set INODE's size to 0 and mark Minode[ ] dirty
}
 
      
int close_file(int fd)
{
  1. verify fd is within range.

  2. verify running->fd[fd] is pointing at a OFT entry

  3. The following code segments should be fairly obvious:
     oftp = running->fd[fd];
     running->fd[fd] = 0;
     oftp->refCount--;
     if (oftp->refCount > 0) return 0;

     // last user of this OFT entry ==> dispose of the Minode[]
     mip = oftp->inodeptr;
     iput(mip);

     fdalloc(oftp);   (optional, refCount==0 says it's FREE)
     return 0; 
}

long
myread: read 1024 char from file descriptor 0
 lseek(int fd, long position)
{
  From fd, find the OFT entry. 

  change OFT entry's offset to position but make sure NOT to over run
  either end of the file.

  return originalPosition
}

int pfd()
{
  This function displays the currently opened files as follows:

       filename  fd  mode  offset
       --------  --  ----  ------ 
       /a/b/c     1  READ   1234       
  
  to help the user know what files has been opened.
}
<Title>360 Week 1 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
	<H1>360 Course Plan</H1>
	<Pre>                CPTS 360 COURSE PLAN
                    
                    Fall, 2008

COURSE TITLE : CPTS 360 Systems Programming

Reference    : Advanced Programming in the UNIX Environment, 
               W. Richard Stevens, Addison-Wesley, 1992.
CLASS NOTES  : www.eecs.wsu.edu/~cs360/

INSTRUCTORS  : K. C. Wang, Professor of EECS, Sloan 321
                           335-3769, kwang@eecs.wsu.edu
                           Office Hours: MW 9:10-10:00 AM
               TA: To
myread: read 1024 char from file descriptor 0
 be posted
   
PREQUISITES  : CPTS 250
  Basic knowledge and working experience in Unix commands.
  Ability to program in C or C++.

COURSE CONTENTS:
  Introduction to the Unix Operating System: 
     Files, directories, special files, logical organization of 
     Unix file system; user account, login process and command
     execution.

  Program development
     Source files;  compiler, assembler and object files; 
     linker, library and executable files; loader and execution 
     images. Symbolic debugger and run-time support.

  Execution image of C programs
     Code, data and stack segments; function calling convention, 
     stack frames and parameter passing; long jumps.

  File I/O
     System calls and low-level file I/O; open, close, read, write, 
     lseek, file descriptors and file sharing. Execution of User 
     mode and Kernel mode images, implementation and implications 
     of system calls.

  File Control
     Permissions and access control, fcntl, chown, chmod, hard 
     and soft li
myread: read 1024 char from file descriptor 0
nks, file status and statistics. 
     I/O redirection, pipes, filters and applications.

  Standard I/O Library
     Streams and high-level file I/O; user space buffering, 
     relationship with low-level I/O,  char and line mode I/O. 
     Formatted I/O.

  File system implementation
     Inodes and file representation; mkfs and physical file 
     system layout; traversal of the file system tree; booting 
     system images.

  Processes
     Concept and implementation of processes, process execution 
     environment, user mode and kernel mode images, process
     states transitions. Processes in the Unix system; init, 
     login and user processes.

  Process Control
     fork, vfork, wait, exit, kill, exec operations. traps and 
     signal handling.

  Process Synchronization and Communication
     Signals, pipes, semaphores, messages and shared memory 
     segments. Sockets.
   
  Networking
     Introduction to Internet; host, address resolution, 
     routing; protocols, client and server; ftp, r
myread: read 1024 char from file descriptor 0
login, nfs, 
     and nis, Socket Programming. 

  Project: Implement an ETX2 File System Simulator

  Misc Topics: sh and Perl programming, Unix system adm. 

COMPUTER SYSTEMS: (Sloan 327) 
     Pentinum based PCs running Linux.
     Other HP Unix systems and work stations for general usage.

LABORATORY: 
     Time : Wed 7:10-10 PM Place: Sloan 233
     (Firt Week: NO LAB)
---------------------------------------------------------------------
GRADING:
   Exam                      %30  (Date and form will be set later).
   Programming Assignments   %30
   Project                   %40   
---------------------------------------------------------------------

</Pre>
</Body>
<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes </H1>

<Pre>
         Lab #4 Pre-work: DUE: Sept 24, 2008 in Lab


Download the server.c andd client.c files for samples/LAB4.
Compile and test run the server and client on IP hosts.
============================================================
MODIFY the programs 
myread: read 1024 char from file descriptor 0
to do the following :
       client : send 2 numbers to server
       server : return the SUM of the 2 numbers to client
===========================================================
<Title>360 PROJECT FILE</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 PROJECT</H1>
<Pre>
                    CPTS 360 PROJECT

               Date Assigned: Oct 13, 2008

 *****************************************************************************
  1.   DUE and DEMO: Wednesday to Thursday in Close Week.
       Sign up for demo time slots. Turn in a floppy disk AND a hard copy.
  2.   May work in 2-person teams. However, a comprehensive ORAL exam will 
       be given to EACH individual during the DEMO.  The ORAL exam score 
       will be a major part of your FINAL grade.
 ****************************************************************************

                     A. OBJECTIVE:
   Design and implement a Linux EXT2 file system simulator. 

                     B. SPECIFICATIONS:
1. Files:
   Files are exactly the 
myread: read 1024 char from file descriptor 0
same as they are in the Linux file system, i.e.
   we shall use the same EXT2 file system data structures for

      SuperBlock, GroupDescriptor, Bit-maps, Inode, Directory

   EXCEPTIONS:
      Only DIR and REG file types; no SPECIAL files.
      File size : No triple-indirect blocks.
      
   
2. Disks:
    Disks are REAL floppy disks OR "virtual disks" simulated by Linux files.  
    Disk I/O are simulated by Linux read()/write() operations on a BLKSIZE 
    basis. You may use Linux's, mkfs (mke2fs) to create EXT2 file systems.

3. File names:
   As in Unix, each file is identified by a pathname, e.g. /a/b/c or x/y/z.

   If a pathname begins with "/",  it's relative to the / directory.
   Otherwise, it's relative to the Current Working Directory (cwd) of the 
   running process (see Processes below). 

4. Processes:
   Every file operation is performed by a process. A process has a unique uid and pid.
   The simulator starts with TWO processes:
       A process P1 with uid=0 (for SUPERUSER), and
       A
myread: read 1024 char from file descriptor 0
 process P2 with uid=1 (for ordinary user).
   The initial CWD of both processes are initially /
  
   P1 runs first. P2 is in a readyQueue, which contains ALL processes
   that are ready to run.

   All processes executes the same code (i.e. the Simulator), in which it

       loop forever{
            prompt for a command;
            execute the command;
       }
 
   Each command is performed by the current running process. 
   
   Process management commands are:

      switch : switch process (to run another READY process).

      fork : create a child process with the SAME uid (and its own pid).
             As in Unix, the child process shares opened files with its parent.

      kill, exit: cause process to terminate.

5. File System Commands and Operations:
   Unlike Unix (Kernel), file operations will be executed as commands.
   The required commands are listed below. LEVEL 1 is the MINIMUM requirements 
   for passing.
    
              -------  LEVEL 1 ------------ 
               mount_root;
  
myread: read 1024 char from file descriptor 0
             mkdir, rmdir, ls, cd, pwd;
               creat, rm;       
               stat, chmod, touch;

              -------  LEVEl 2 -------------
               open,  close,  read,  write
               pfd,   lseek
               cat,   cp,     mv

              -------  LEVEl 3 ------------ 
               mount, umount,             
               Process Management Commands 
               File permission checking
              -----------------------------
      
   Unless as noted below, all commands behave exactly the same as they do in 
   Unix.
 
      pfd   : Show the valid fd's of the current process.

      write : Prompt for fd and a string of chars, then write the chars 
              to the file and show the number of chars written.

      read  : Prompt for fd and n, then read the file and DISPLAY the 
              chars that are read.
============================================================================
                       SAMPLE PROGRAMS:
                       ~cs360/sam
myread: read 1024 char from file descriptor 0
ples/
 
       simulator.bin: The File System Simulator for EXT2 FS. 
                        Under Linux, use  
                              mkfs /dev/fd0 1440
                        to make an EXT2 FS on a FD.

                    Then, run the simulator to see what I expect of YOUR work.
============================================================================


<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 PROJECT HELP </H1>
<Pre>
                     EECS 360 PROJECT HELP #1
    
Given: mkfs ======> make an EXT2 file system on /dev/fd0 (or a Linux file).


                     PROJECT ORGANIZATION

1. type.h (samples/type.h file)
          define constants, e.g. BLKSIZE, NPROC, NMINODE, NOFT, etc.
          define types for SUPER, INODE, DIR => same as in Linux
                
            MOUNT ==>   ---------------------------------------
                               dev       : disk identifier (fd number)
                               MinodePtr : pointer to mounted M
myread: read 1024 char from file descriptor 0
inode

                               deviceName: pathname of mounted device  
                               MinodePath: pathname of mounted Minode
                          ---------------------------------------

            MINODE ==> In_Memory Inodes = ------
                                           INODE
                                          -------
                                          dev,ino
                                          refCount
                                          dirty
                                          mounted
                                          mountTablePtr
                                          (lock:optional)
                                           -------

            OFT   ===> OpenFileTable = --------- 
                                       mode: R|W|RW|A 
                                       refCount
                                       MinodePtr
                                       offset
                                       file's s
myread: read 1024 char from file descriptor 0
tring name (optional)
                                       -------   

            PROC  ===> Process Structure = ptrs to other PROC's;
                                           pid, ppid, 
                                           uid;
                                           cwd ---> currentWorkingDir
                                           fd[NFD] = openfilePointers
                                           -------------------------- 
                
2. global.c ===> Ths file defines global variables, e.g.
                 MINODE *root;      pointer to root inode in memory.
                 PROC   *running;   pointer to current running process.
                 MINODE minode[100] in-memory inodes
                 etc

3. include.c ==> #include  "type.h"
                 #include  "global.c"
                 #include  "utility.c"
                 #include  "mountroot.c"
 
                 #include  "mkdir_creat.c"
                 #include  "cd_ls_pwd.c"
                 #include  "rmdir_rm.c"
  
myread: read 1024 char from file descriptor 0
               #include  "other_level_1.c"

                 #include  "open_close_pfd.c"
                 #include  "write.c"
                 #include  "read.c"
                 #include  "cat_cp_mv.c"

                 #include  "mount_umount.c"
                 #include  "fork_switch_exit.c"
                 #include  "check_permission.c"

4. main.c:

   #include "include.c"

   init(){ 
           initialize the simulator system's data structures:
                MOUNT  mountTable[10];
                MINODE Minode[100];
                OFT    oft[100];
                PROC   proc[10];
            
           mount the rootdevice;  e.g. default to /dev/fd0
           Run porc[0] as the current process P0  with  cwd = /;
   }

             
   main()
   {
     init(); 
     while (1){
       print the current process ID;
       prompt for a commandString; ===>  mkdir, creat, cd, ....
              get paramter strings: e.g. mkdir pathaname

       cmdIndex = findCommand(commandString); ===> return 0,1,2,.
myread: read 1024 char from file descriptor 0
...

       switch(cmdIndex){
           case 0: mkdir(pathname);         break;
           case 1: creat_file(pathanme);    break;
           .......................................
           default: print INVALID command;
       }
   }

       
5. IMPLEMENT and TEST the commands in successive steps:

6. utility.c:
   This file implements the commonly used functions that are needed
   by the commands. It is suggested that you implement the following: 

(1). get_block(dev, buf, blkno);  read block to buf;
     put_block(dev, buf, blkno);  write block from buf


(2). Alocate/Deallocate functions:

     ialloc()/ idealloc() ===> allocate/deallocate an inode
     balloc()/ bdealloc() ===> allocate/deallocate a  file block;
     
     mialloc()/midealloc() ==> allocate an in memory inode 
     falloc()/fdealloc()   ==> allocate OFTE entry.

(3). ulong search(INODE *ip, char *name)
     search a DIR inode (data blocks) for name; 
     return ino if found, return 0 if not 

(4). THE MOST FUNDAMENTAL FUNCTION IS:

myread: read 1024 char from file descriptor 0

         ino = getino(&dev, char *pathname);

     which returns the ino of pathname.  The beginning dev is either / or
     the running proc's CWD, as in
                if (pathname[0] == '/')
                   dev = root->dev;
                else
                   dev = cwd->dev;
    However, while traversing the pathname, dev may change to that of a 
    mounted device.  So bring in &dev to keep track of the changes. 
    Alternatively, you may write ino = getino(char *pathname) and use a 
    global variable dev to record the CURRENT device number. 

    Upon return from getino(), we have (dev, ino) of the file.

    THIS IS SIMILAR TO YOUR showblock.c


(5). MINODE *iget(dev, ino) ==>   Return ptr to in-memory inode=(dev,ino);
                                  load the inode into a minode[] if necessary.
             iput(minodePtr); ==> Release the inode;  WRITE BACK TO DISK
                                                      IF refCount=0 and dirty.

(6). Others as needed:

     Given ip->inode 
myread: read 1024 char from file descriptor 0
in memory, find its parent's ino;

     Given a parent ip->inode in memory, and a child stringName,
           search for the childName.
           search for an unused directory entry.



              HOW TO GENERATE THE simulator EXECUTABLE

                       METHOD 1:

As shown above, main.c includes ALL the needed .c files. So
         cc -o simulator main.c
would generate the simulator executable. In this approach, the .h file
can only be included ONCE. 


                    METHOD 2: Use make
The is the preferred method of managing a LARGE set of C programs.
To use the make facility, you need to create a Makefile (or makefile) containing
instructions for make to follow.  make reads the Makefile, compiles the .c 
files (as needed) and link the .o files into an executable.

NOTE: in this approach, each .c file must include the .h file and use
      extern to declare any needed (global) variables.
 
To learn more about makefile contents, read Linux's /usr/info/make.info-1, etc.
Here, we show a makef
myread: read 1024 char from file descriptor 0
ile for the project.

#            # starts a comment line, which is ignored by make

# ***************************************************************************
#                    Example Makefile
#            Save these as Makfile or makefile Then run  make
# ***************************************************************************

# Variable H defines the head file (string)

H = type.h

# Variable OBJ defines the string containing .o file names
# NOTE: this is ONE line, but splitted into several lines for easier to read

OBJS = global.o alloc_dalloc.o util.o mount_umount.o mkdir_creat.o \
       stat.o cd_ls_pwd.o rmdir_rm.o open_close.o read.o write.o \
       cp_mv.o cs_fork.o main.o

# simulator:  is a rule, which says simulator DEPENDS on $(OBJ), the (string)
# value of the OBJ variable
    
simulator : $(OBJS)

# This rule tell make how to generate simulator: by    cc $(OBJ s.s
# NOTE !!! Each ACTION rule must begin with a TAB char, NOT a bunch of spaces.

	cc  -o simulator $(OBJS) s.s


# Thes
myread: read 1024 char from file descriptor 0
e tell make how to generate each .o file from a corresponding .c file.
# Each .o file DEPENDs on $(H), whcih means: The .o file will be generated 
# again if $(H) are changed. This certainly makes sense since each .c file
# depends on the TYPEs in type.h.

global.o : $(H)

alloc_dalloc.o : $(H)

util.o :  $(H)

mount_umount.o :  $(H)

mkdir_creat.o : $(H)

stat.o : $(H)

cd_ls_pwd.o : $(H)

rmdir_rm.o : $(H)

open_close.o : $(H)

read.o : $(H)

write.o : $(H)

cp_mv.o : $(H)

cs_fork.o : $(H)

main.o : $(H)


# make clean  ==>  remove the executable and all the .o files
clean :
	rm simulator *.o



<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                      HOWTO read

int read_file()
{
  Preparations:
   ask for a fd  and  nbytes to read
   verify that fd is indeed opened for READ or RW

   return(myread(fd, buf, nbytes));
}
 

// myread() behaves exactly the same as Unix's read(fd, buf, nbytes) syscall
// it tries to read nbytes from fd to 
myread: read 1024 char from file descriptor 0
buf[ ], and returns the actual number of
// bytes read.

int myread(int fd, char *buf, int nbytes)
{
 1. size = fileSize - OFT's offset //number of bytes remain in file.

 2. while (nbytes > 0 && size > 0){
     compute LOGICAL BLOCK lbk and startByte in that block from offset;
           lbk       = oftp->offset / BLOCK_SIZE;
           startByte = oftp->offset % BLOCK_SIZE;
     
     // I only show how to read DIRECT BLOCKS. YOU do INDIRECT and D_INDIRECT
 
     if (lbk < 12){              // direct block
        blk = mip->INODE.i_block[lbk];
     }
     else if (lbk >= 12 && lbk < 256 + 12) { 
          //  indirect blocks 
     }
     else{ 
          //  double indirect blocks
     } 

     /* get the data block into readbuf[] */
     get_block(mip->dev, blk, readbuf);

     /* copy from startByte to buf[], at most remain bytes in this block */
     char *cp = readbuf + startByte;   
     remain = BLOCK_SIZE - startByte;  // number of bytes remain in readbuf[]

     while (remain > 0){
            *cq+
myread: read 1024 char from file descriptor 0
+ = *cp++;             // cq points at buf[ ]       
             oftp->offset++; 
             count++;                  // count=0 for counting
             size--; nbytes--;  remain--;
             if (nbytes <= 0 || size <= 0) 
                 break;
     }
 
     // if one data block is not enough, loop back to OUTER while for more ...

 }

 show ("myread : read %d char from file %d\n", count, fd);  

 return count;    // count is a actual number of bytes read
}
<html>
<body>
<pre>

                 360 Review Questions

1. What happens when you login to Unix?

2. Write C statements for a struct containing
         ---------------------------------------    
         NEXT  : a pointer to the SAME struct
         ID    : an integer                         
         NAME  : an array of 256 chars              
         ---------------------------------------    
   Write C statements to print the contents of a list.

3. What's cc? (Steps and what does each step do)
   Dynamic Vs. static linking?

4. Given 
myread: read 1024 char from file descriptor 0
a C program,

        int g;
        int h = 1;

        main(int argc, char *argv[])      int A(        )
        {                                 {                            
           int a,b,c;                        int u,v;
           a = 2; 
           b = 3;                            HERE:       
           c = A(a,b,"hello");      
        }                                 }  

   (0). Complete the function heading of A(....)
   (1). Which variables are global? local?   
   (2). Which variables are in a.out?
   (3). In the run-time memory of a.out, where are the variables?

   (4). Execution is at HERE:  Show the stack contents from HERE to main()'s 
                               argc and argv.

5. A simple function in assembly:
            .global sub
   sub:

   ENTRY:   pushl   %ebp
            movl    %esp, %ebp
   
   BODY:
            movl    $1234, %eax
            movl     1234, %eax            

   EXIT:
            movl    %ebp, %esp
            popl    %ebp
            ret

   (0). Wh
myread: read 1024 char from file descriptor 0
at's purpose of .global sub ?
   (1). What's the purpose of the statements at ENTRY?
   (2). What's the difference between the 2 statements in BODY?
   (3). What does the EXIT part do?

6. int pid, dead, how;

   pid = fork();              What does it do?

   if (pid){ // do this }     which process does this?
   else{     // do that }     which process does that?

   dead = wait(&how);         IF CALLED BY THE ABOVE 2 processes, dead=? how=?

7. What does  int   r = execve("a.out", argv, env);    do?
   How does the system find a.out?
   Draw a diagram to show exactly what's argv?
   What's the value of r? (It can only have ONE possible value !!!)

8. a.out is the binary executable of the C program
     main(int argc, char *argv[], char *env[])
     {
       execve(argv[0], argv, env);
     }
   What would happen?
   HOW TO GET OUT THE MESS?

9. When run  a.out > outfile, how does sh do the I/O re-direction?

10. You can use the Unix command  mkdir /a/b/c  to make a directory.
    Write a C statement for th
myread: read 1024 char from file descriptor 0
e mkdir command.
    
11. open,  read,  write are system calls
   fopen, fread, fwrite are library I/O functions.

   What's their RELATIONSHIP? 
   WHY do wee need lib I/O functions?

   Write C code to
     open a file for READ; read the SECOND block of 1024 bytes into a buf[]
     open a file for WRITE (CREAT if needed); write a string of chars to it.

12. stat():
    What does it do?
    HOW TO determine a files's type, e.g. REG or DIR?
    HOW TO get the file size, creation time?
    How to print creation time in calendar form?
    How to tell whether 2 pathnames are really the SAME file?

13. HOW TO use opendir(), readdir()?

14. Network Programming using TCP
    What's IP? what's TCP? HOW DOES TCP achieve reliable data transfer?
    What's an IP address, a Port Number?
    Network (bytes) order Vs. host order?
    Compare a socket (number) with a file descriptor?

    In a TCP Server-Client model, to establish a "virtual" connection,

       What should the Server do?   |    What should the Client do? 
myread: read 1024 char from file descriptor 0

            
          (After Server accepted a Client connection)                      
       How does the Server know where is the Client?
            HOW DO THEY communicate with each other?

    HOW TO let the Server deal with multiple Clients?

15. mkfs:
    What's a bit map?
    Assume : char buf[1204], block 4 of a FD contains a bit map for inodes.
             INODE my_inode is an INODE struct.

    Write C code for the following:
   (1). read disk block 4 into buf[].
   (2). serach for a FREE inode (number) in the bit map, change it to BUSY
        and return the inode number.
   (3). copy the inode on disk to my_inode.


16. showblock:

    ASSUME: char buf[1024] contains a data block of a directory, such as that of /
    Write C code to 
      (1). search for a name string "abcde" in that data block.
      (2). while searching, print the names of the DIR entries in that block.









<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP : HOWTO rmdir_rm</
myread: read 1024 char from file descriptor 0
H1>

<Pre>

int rmdir()
{
  1. ask for a pathname to rmdir
  2. get its inumber :  
         ino = getino(&dev, pathname) 
  3. get a pointer to its Minode[] :   
         mip = iget(dev, ino);

  4. check DIR type */
       if NOT : iput(mip); retunr -1;
 
  5. check ownership 
       super user : OK
       not super user: uid must match

  5. check for BUSY or mounted on ?
       test refCount and mounted flag

  6. check whether it's empty
     First, check link count (inks_count > 2 means not empty);
     However, links_count == 2 may still have FILEs, so go through its data 
     block(s) to see whether it has any entries in addition to . and ..

  7. Assume empty:
       get parent DIR's ino and Minode (pointed by pip);
       remove child's entry from parent directory:

       rm_child(pip, me, child);   pip->parent Minode, me=my_inumber
                                   child = nameString to remove

  8. deallocate its block and inode
     for (i=0; i<12; i++){
         if (mip->INODE.i_block[i]==0)

myread: read 1024 char from file descriptor 0
             continue;
         bdalloc(mip->dev, mip->INODE.i_block[i]);
     }
     idalloc(mip->dev, mip->ino);
     mip->refCount = 0;

     decrement pip's link_count by 1; 
     touch pip's atime, mtime fields;
     mark pip dirty;
     iput(pip);
     return(0);
}


int rm(pathname) char *pathname;
{
   1. get its ino and inode */
          ino = getino(&dev, temp);

   2. get its Minode pointer
          mip = iget(dev, ino);

   3. check busy:
          check refCount

   4. check FILE type */

   5. check ownership

   6. get parent's ino and Minode pointer
          pino = getino(&dev, parent);
          pip  = iget(dev, pino);

   7. remove name from parent directory */
          rm_child(pip, ino, child);

   8 deallocate direct and indirect data blocks */
     for (i=0; i<12; i++){
        if (mip->INODE.i_block[i]) 
            bdalloc(mip->dev, mip->INODE.i_block[i]);
      }
    
     deallocate indirect data blocks AND the indirect blocks themselves 
     NOTE: you MUST allow files to have D
myread: read 1024 char from file descriptor 0
OUBLE indirect blocks

   9. deallocate its inode :
         idalloc(mip->dev, mip->ino);
   
   10. mip->refCount = 0;

   11. dispose of parent's Minode
       touch pip; mark pip dirty;
       iput(pip);
   
   return(0);
}



// rm_child() is common to both rmdir and rm. It remove an entry [me, child]
   from the parent's data block. WATCH the clever tricks used here.

int rm_child(parent, me, child)
    MINODE *parent; unsigned long me; char *child;
{
   1. Search parent INODE's data block(s) for an entry eqaul to me
   2. Erase my name from parent directory:
       if first entry in block ==> set my ino to 0;   
       if NOT first entry in block ==> absorb my rec_len to the previous entry;
          (this effectively makes my_entry disappear;
           no need to change parent's fileSize)
   3. Write the parent's data block back to disk
}




<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 NOTES #10 Sh Programming</H1>

<Pre>
1. sh scripts:
   A sh script is a text file
myread: read 1024 char from file descriptor 0
 containing sh statements for sh to execute.
   Example: Text edit a file, mysh,  containing
            -----------------------------------
            #! /bin/bash
            # comment line
            echo hello
            -----------------------------------
   Use chmod +x mysh to make it executable. Then run mysh. It will print hello.

2. Command-line parameters:
   Similar to running C programs, sh scripts can be invoked with parameters, 
   as in      mysh one two three

   $# = the number of such parameters, which are known as $1 to $9. $0 is the
        program name itself.
   $* = ALL command-line parameter (strings) $1 $2 ....
   
   Example:
            ------------------
            echo $#
            echo $1 $2
            echo $*
           -----------------
   mysh                      ====> print  0 
                 
   mysh one two three        ====> print  3
                                           one two
                                           one two three
2. sh Statements

2-1.
myread: read 1024 char from file descriptor 0
 sh statements include all Unix commands, with I/O re-directions.
     Examples:    ls           ; ls > outfile 
                  date         
                  cp f1 f2
                  mkdir new
                  cat filename

2-2. Simple sh (built-in) statements
     echo This is a line              # display This is a line
     echo "This is     a   line"      # display This is    a   line
     echo -n hi                       # display hi without NEWLINE  
     echo    there                    # display hithere
     
     shift, eval (will be explained later).

2-3. Command Substitution:
     When sh sees $(cmd), it executes cmd first, and SUSTITUTEs $(cmd)
     with the RESULT (string) of the execution.

     echo $(date)       ==> display current date string
     echo $(ls)         ==> display the result of ls command 


3. Sh Variables:
   Sh has many built-in variables, e.g. PATH, HOME.
   You may use any symbol as sh variable. No declaration is necessary.
   sh variable values are STRINGs !!! If 
myread: read 1024 char from file descriptor 0
A is a variable, $A is its value.
   Examples
      echo A   ==>  A
      echo $A  ==>        (null string if A is not set)
      A="this is fun"     # set A value
      echo $A  ==> this is fun
      B=A
      echo $B   ==> A     (B was assigned the string "A")
      B=$A                (B takes the VALUE of A)
      echo $B   ==> this is fun

      echo -n "enter yes or no "
      read ANS            # sh reads an input line from stdin; try read A1 A2 with "one two three"
      echo $ANS

      local X             # X is local to this sh; not available in child sh
      export Y            # variable Y will be passed to child sh process

4. Quotes:
   Sh has many special chars, such as $, /, *, >, <, etc.  
   To use these as ordinary chars, use \ to quote them, as in
         echo \$A     ==> $A
     OR  echo '$A'    ==> $A    (NO substitution within SINGLE quotes)

         echo " this is $A"     (DOUBLE quotes will substitute $A !!!)

5. sh statements
5-1. if-else-fi statement
     if [ condition ]
     
myread: read 1024 char from file descriptor 0
  then
          statements
       else                # as usual, the else part is optional
          statements
     fi

Example:
echo ------------------------------
echo This sh script copies f1 to f2
echo "     then removes f2"        # Use double-quotes " " to include spaces
echo ------------------------------

# $# is the number of command line parameters, which are known as 
# $1,$2,$3,...., $9    As usual, $0 is the name of the execcutable itself.
# Here, $# must be 2. If not show Usage and exit

# By default, all values in sh are strings, so they can be compared by
#  if [ s1 = s2 ];  if [ s1 != s2 ];   if [ s1 \< s2 ]; if [ s1 \> s2 ]; etc.
# Note the spaces between the tokens

# In contrast, the operators -eq, -ne, -lt, -gt compare them as (integer)
# NUMBERS, thus
#  if [ "123" = "0123" ]  is false (since they differ as strings)
#  if [ "123" -eq "0123" ] is true. Since everything is string, you may use
#  if [ 123 -eq 0123 ] OR  if ["123" -eq 0123 ]

# Here we compare them as STRINGs; 
if [ $# !=
myread: read 1024 char from file descriptor 0
 2 ] 
then
     echo Usage: copy file1 file2
     exit 1
fi

# $1 is the first parameter string, $2 the second, etc.

echo You are copying $1 to $2 
echo in the directory $(pwd)     # COMMAND SUBSTITUTION

echo copying $1 to $2 ....
     cp  $1  $2                 # this is the actual copy operation
echo done

echo show $2 has been created ....
  ls -l $2
echo now try to remove $2

# if $2 exists as a file:
if [ -e $2 ]  
 then 
   echo removing $2 .....
   rm $2
fi
echo
echo all done
echo Let\'s go on .....      # QUOTE the special char ' by \ 

# ***************** DO THESE:  ****************************
# In sh, the following tests can be used:
# if [ -e name ]      test whether file name exists
# if [ -f name ]      test whether name is a (REG) file
# if [ -d name ]      test whether name is a DIR
# if [ -r name ]      test whether name is readable; also -w,-x
# if [ f1 -ef f2 ]    test whether f1, f2 are the SAME file
#.........................................................

                   EXERCISES
myread: read 1024 char from file descriptor 0
:

# MODIFY the above sh program to do these:

#1. Check whether f1 exists. If not, echo a message and exit;

#2. Check whether f2 exists.  
#      If f2 already exists:
#         echo a message:     OK to over-write f2 (y/n)?
#         read user's response by    read ANS
#         if $ANS = "y" ===> go on, else exit.

#3. Ask for a directory name (relative to user's $HOME)
#   DIR to do the copying. Then copy f1 to f2, all in that 
#   directory.

#   read DIR
#   cd $DIR  will cd to that directory
#   (cd $DIR; sh commands; .....)  ==> commands grouping
#                                   
#   Alternatively, you may stay in the current directory 
#   but generate the right file names from $1 and $2.
#   basename a/b/c/d  ====> d 
    
# ******************************************************

5-2. for statement in sh:

       for VARIABLE in string1 string2,...., stringn
         do
            commands
         done

   Examples:
      for FRUIT in  apple  orange  banana  cherry
        do
           echo $
myread: read 1024 char from file descriptor 0
FRUIT     ===> apple  orange  banana  cherry 
        done 

      for NAME in $* 
        do
          echo $NAME      ==>  all command-line param strings
          if [ -f $NAME ]; then
             echo $NAME is a file
          fi
          if [ -d $NAME ]; then
             echo $NAME is a DIR
          fi
        done


5-3. while [ condition ]
       do
          commands
       done

  -------------------------------------------------------------------
                  Example:
   echo '$#' = $#         # echo the number of parameters 
   I=0                    # set I to "0" (STRING !!!!) 
   while [ $1 ]           # while $1 is not the empty string
   do
      echo $1             # echo current $1
      I=$(expr $I + 1)    # use expr to change I from "0" to "1"
      shift               # shift once, $2 becomes $1, $3 becomes $2, ... etc.
   done
          
   echo I = $I            # total number of parameters 
  --------------------------------------------------------------------

5-4 Other Flow-
myread: read 1024 char from file descriptor 0
Control statements:

    until [ "$ANS" = "give up" ]
    do
        echo -n "enter your answer : "
        read ANS
    done
   
    case statement (SELF-STUDY)

5-5. break and continue statements:
     They work exactly the same as they do in C

6 sh Processing Steps:

  Assume:   A='$B'    B='new.*'    C=newdir
   For each command line, e,g,
        cp  $A `pwd`/$C
   sh evaluates the variables in the following order:

   (1). Parameter substitution: (only scan ONCE) ==>
        cp  $A `pwd`/$C          Replace $A, $C ===> becomes  
        cp  $B `pwd`/newdir      NOTE that $A is replaced only ONCE.
    
   (2). Command substitution:
        cp  $B `pwd`/newdir     Perform `pwd` ===>   becomes
        cp  $B /a/b/c/newdir    (assuming CWD=/a/b/c)

   (3). Blank Interpretation:
        Use the value of $IFS (usually space,tab and newline) to
        break up the chars into non-blank words. ==> 
        cp  $B /a/b/c/newdir    NO change here.
       
   (4). File name generation:
        Each word is scanne
myread: read 1024 char from file descriptor 0
d for file pattern characters *, ?, [..]
        to generate a list of filenames, which replace the word.

        cp  $B /a/b/c/newdir    There are no file pattern chars, so no change.
                                This is the final command to sh.
        ------------------------------------------------------------- 
                         
7. eval  is a sh built-in command, which is executed by sh itself without
   forking a new process.   Each  eval  evaluates the input string ONCE 
   and use the results as inputs to sh. 

   Example 1: Assume execution of do_it generates output lines
                   A=a\nB=b\nC=c\n

            Then,  eval $(do_it)

            generates A=a\nB=b\C=c\n as inputs to sh AS IF you have
            entered the lines
                               A=a  
                               B=b
                               C=c
            Thus, sh will set the variables A,B,C to a,b,c, respectively.
             
   Example 2: Assume: A='$B'     B='new.*'     C=newdir
     
myread: read 1024 char from file descriptor 0
       Then    eval echo $A  ==> generates  
                         echo $B      to sh, resulting   ===>  new.*

   Now, consider this command:

        eval cp $A `pwd`/$C     ===> eval  first converts this to
             cp $B `pwd`/newdir ===> and uses this as inputs to sh.
   
   With these inputs, sh will do the substitutions of Steps (1) to (3).
   The command at Step (4) is

             cp new.* /a/b/c/newdir 

   Step 4 : The command line has a file wild-card char *.
            sh will replace the word  new.* by the filenames 
            new.X, new,Y,... (assuming they exist) and finally 
            executes

            cp new.X new.Y ...  /a/b/c/newdir

4. Within a pair of double quotes, parameter and command substituions occur 
   but blank interpretation and file name generation do not.
 
8. sh FUNCTIONS (by examples)
    --------------------------------------------------------
     # check_file() is a function, NOT the entry point

              check_file()     
              {
          
myread: read 1024 char from file descriptor 0
      local A=localVariable    # A is local to this function

                if [ -f $1 ]; then
                   return 0
                fi
                return 1
              }

     # Here is the entry point of the program
     # Usage : thisFile  f1 f2  f3 ......

              for FILE in $*             # for FILE in $1 $2 ....
              do
                  check_file  $FILE      # call check_file() 
                  if [ $? = 0 ]          # returnCode == 0 ?
                     then
                         echo $FILE is a regular file
                     else
                         echo $FILE is not regular
                  fi
              done
     -------------------------------------------------------------

9. Utility Programs and sh Programming
   
   expr is a utility program. It is used as
        expr x Operator y
   It evaluates the the expression (x Operator y), where Operator is
   any valid operator in C, e.g.
         expr 3 + 5  ==>  8
         expr 3 \* 5 ==> 15   #NOTE
myread: read 1024 char from file descriptor 0
: * must be quoted 
         expr 5 % 3  ==>  1   etc

   There are many utility programs, such as basename, grep, sed, cut, etc. 
   which are used so often that they have become almost an indispensible part 
   of sh programming. You are free to develop your own utility programs and,
   if they prove to be useful enough, include them in the Unix command set.
   Many Unix commands originated this way. As they say: Necessity is the
   Mother of all inventions.

   For example, suppose you want to have a myinc operator, which
   increments a sh (COUNTing) variable by one.  You may write it as

       main(int argc, char *argv[])
       {  
          int i = 0;
          if (argc > 1)
             i = atoi(argv[1]) + 1;;
          printf("%d",i);
       }

   Then, use myinc to replace  expr  for incrementing $I by 1.

10. I/O Redirection:

   When entering a sh command, we may instruct sh to re-direct I/O
   to files other than the default stdin, stdout, sterr. I/O redirections
   have the following form and m
myread: read 1024 char from file descriptor 0
eaning:
      -------------------------------------------------
      >  file   stdout goes to file, which will be created if non-existing.
      >> file   stdout append to file
      <  file   use file as stdin; file must exist and have r permission.
      << word   take inputs from "here" file until a line containing only 
                "word" is encountered. 
                Try these:
                ---------------------------------------------
                echo << END    
                  keep entering lines until a line with only
                  END
                --------------------------------------------
                cat << DONE
                  keep entering lines until
                DONE
                -------------------------------------------

      >&2      dup (see below) the fd=2 and use the result as stdout.

      <&3      dup fd=3 and use the result as stdin
      --------------------------------------------------
      A digit may preceed any of these to mean: use that f
myread: read 1024 char from file descriptor 0
d instead of 
      stdin or stdout.  Examples:
                2> file           stderr to file
                2>> file          stderr append to file
                2>&1              dup 1 and use it as 2 ==> merge 1 and 2

8-1. dup and dup2 syscalls:

     int dup(int fd);
     
     dup() duplicates a file descriptor by creating a new fileDescriptor
     using the lowest fd number. It returns the new fd,  or -1 if failed.

     -------------------------------------------------------------      
     Example 1:  int fd = open("infile", 0);  /* open for READ */
                   close(0);    /* This frees fd[0]*/
                   dup(fd);     /* dup fd into fd[0] */

               /*** from here on stdin is the same as fd */
                   sscanf(FMT, &items);  will input from infile.

     ------------------------------------------------------------
     Example 2:  int gd = creat("outfile", 0644);
                     close(1);  /* this frees  fd[1] */
                     dup(gd);   /* dup gd i
myread: read 1024 char from file descriptor 0
nto fd[1] */
               /** from here on stdout is really gd ***/
                     printf("hello world\n");  will go to outfile.
     ------------------------------------------------------------

     int dup2(int old_fd, int new_fd);

         duplicates  old_fd  into  fd[new_fd].  It closes new_fd first, 
         if necessary.  dup2(gd, 0) is equivalent to  close(0); followed
         by  dup(gd);

     ------------------------------------------------------------
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                 HOWTO STAT_CD_LS_PWD

1. HOW TO stat:

   struct stat mystat; 
   char *pathname = "/a/b/c/d";
 
   r = do_stat(pathname, &mystat); 

int do_stat(char *pathname, struct stat *stPtr)
{
  1. Get inode of pathname into an MINODE:
         ino = getino(&dev, pathname); 
         mip = iget(dev, ino);          // iget() returns a pointer to minode[]
         
  3. Copy entries of INODE into stat struct;

     As you can see
myread: read 1024 char from file descriptor 0
, everything needed by the stat struct is in MINODE.
     Write C statements to copy from mip->INODE to stPtr->fields.

       struct ext2_inode {
	i_mode;		/* File mode */
	i_uid;		/* Owner Uid */
	i_size;		/* Size in bytes */
	i_atime;	/* Access time */
	i_ctime;	/* Creation time */
	i_mtime;	/* Modification time */
	i_dtime;	/* Deletion Time */
	i_gid;		/* Group Id */
	i_links_count;	/* Links count */
	i_blocks;	/* Blocks count */
        .................................
        i_block[15];    // Allocated disk blocks 
      }

      struct stat {
        st_dev;      // dev
        st_ino;      // ino

        st_mode;     // i_mode
        st_nlink;    // i_links_count
        st_uid;      // i_uid
        st_gid;      // i_gid
        st_rdev;     // IGNORE THIS
        st_size;     // i_size
        st_blksize;  // 1024
        st_blocks;   // i_blocks
        st_atime;    // i_atime
        st_mtime;    // i_mtime
        st_ctime;    // i_ctime
      };

  4. Print the entries of the stat struct;
 
myread: read 1024 char from file descriptor 0
 5. iput(mip);      // dispose of the in memory inode; see NOTE below.
     return 0 for success;
}
============================================================================
NOTE: In general,   mip = iget(dev, ino); and
                          iput(mip);
      should occur in pairs, with only a few exceptions:

       cd()   : iget(new CWD) but iput(old CWD)
       open() : iget() but close() does iput().
       mount(): iget() but umount() does input().
============================================================================
2. HOW TO ls:

int do_ls(char *pathname) 
{
 
  1. If pathname==NULL, ls CWD.

  2. YOU MAY USE do_stat() OR work on the INODE of pathname directly.
  
  3. In either case, USE YOUR myls LAB program here.

  4. return 0 for SUCCESS

}


3. HOW TO cd:

int do_cd(char *pathname)
{
  1. if pathname==NULL ==> cd to root (default HOME dir) AS SHOWN:

     if (pathname[0] == 0){
        iput(rnning->cwd);                 // dispose of CWD
        running->cwd = iget(rootdev, 2);   // 
myread: read 1024 char from file descriptor 0
OR running->cwd = root; 
                                           //    root->refCount++;
        return 0;
     }
     

  2. Get INODE of pathname into a MINODE:
         ino = getino(&dev, pathname);     // return BAD if ino==0

  3. Get inode into an MINODE slot.
         mip = iget(dev, ino);

  4. Check DIR type ==> if NOT DIR: 
                           iput(mip); YELL at user; return BAD;

  5. Dispose of original running->cwd (by iput(running->cwd) ); 
     Change running->cwd to point at this Minode in memroy;
     return 0 for OK;
}


3. HOW TO pwd:

int do_pwd()
{ pwd(running->CWD); }

pwd(wd) MINODE *wd;
{ 
   Write this function as a recursive fucnction, which

   1. if wd is already the root:
         print /; return;

   2. Get parent's MINODE pointer wd; 
          (HOW? get i_block[0]; then iget(dev, ino of ..))
      Call pwd(wd) again with parent's MINODE pointer;

   3. Print wd's name followed by a /;
          (HOW TO get the name string of a MINODE?)

          2 ways: if you record
myread: read 1024 char from file descriptor 0
ed the pathname of a file in its MINODE,
                  then it's the basename() of that string.
          OR    : You have this guy's ino and its parent's MINODE.
                  Search the parent DIR for an entry with this ino. Then, you
                  have its name. I PREFER THIS method !!!

   4. FOR LEVEL-3: If you implement MOUNTing, make sure your recursion can
                     cross mounting points.
}


<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #7</H1>

<Pre>

         360 Notes #7 System Calls for File Operations

1. What are syscalls?

   Syscall is a mechanism that allows a process to enter Kernel mode to 
   perform operations not allowed in User mode. Operations such as open files,
   read/write files, fork, exec, even termination, must all be done in Kernel.
   In this set of notes, we shall focus on Unix syscalls for file operations.
   
2. Where to find these information:

   Under Linux, the man pages of all syscalls are listed in /usr/
myread: read 1024 char from file descriptor 0
man/man2/.
   The Unix command man 2 NAME displays the man pages of NAME in man2/. 
   Similarly, man 8 mkfs displays the man pages of mkfs in /usr/man/man8/. 

   DO: practice using man to read Linux's man pages.
 
3. How to use these functions?

   Include them in your C program, just like ordinary function calls. A return 
   value >=0 means OK, -1 means BAD. An implicitly defined global int variable,
   errno, records the error code.  Each error code number has a corresponding
   string description, as the following program shows.

            #include &lterrno.h&gt
            main()
            {
              if (mkdir("newdir", 0777) < 0){
                 printf("errno=%d : %s\n", errno, strerror(errno));
              }
            }

    If you run the program twice, the second time it will print
                   errno=17 : File exists
    as it should.
    ************************************************************** 
                 EXERCISES: (Some already in LAB#2)
       Write a C program 
myread: read 1024 char from file descriptor 0
to test :  
               mkdir, rmdir, chdir, creat, unlink, rename, chmod
    **************************************************************

4. READ and LEARN how to use these syscalls on your own:

   access : check user's permissions for a file : R_OK,W_OK,X_OK,F_OK. 
            int access(const char *pathname, int mode);

   chdir  : change directory
            int chdir(const char *path);

   chmod  : change permissions of a file
            int chmod(const char *path, mode_t mode);

   OTHERS : chown, chroot, setuid


   mkdir  : create a directory
            int mkdir(const char *pathname, mode_t mode);

   rmdir  : remove a directory (must be empty)
            int rmdir(const char *pathname);

   link   : make a new name for a file
            int link(const char *oldpath, const char *newpath);


   unlink : delete a name and possibly the file it refers to
            int unlink(const char *pathname);

   symlink: create a symbolic link for a file
            int symlink(const char *oldpath, co
myread: read 1024 char from file descriptor 0
nst char *newpath);

   rename : change the name of a file
            int rename(const char *oldpath, const char *newpath);
  
                       SPECIAL ONES:

   mount  : int  mount(const  char  *specialfile, const char * dir , 
                       const char *filesystemtype, unsigned long mountflags , 
                       const void * data);

   umount : int umount(const char *dir);

   mknod  : make special files, e.g.  mknod /dev/fd2 b 2 2


5. To be covered in details in class:

      open, creat, umask
      read, write, lseek
      close

      opendir : DIR *opendir(const char *name);
      readdir : int readdir(unsigned int fd, struct dirent *dirp, unsigned int count);
      readlink: int readlink(const char *path, char *buf, size_t bufsiz);

      stat :  int stat(const char *file_name, struct stat *buf);
              int fstat(int filedes, struct stat *buf);
              int lstat(const char *file_name, struct stat *buf);


6. The stat Systen Call

6-1. Link Files:
   In Unix, every f
myread: read 1024 char from file descriptor 0
ile has a pathname, such as /a/b/c. However, Unix allows 
different pathnames to represent the same file. These are known as LINK files.
There are two kinds of LINKs, HARD link and SOFT link. 

HARD Links: 
     The command    ln  oldpath  newpath 

creates a HARD link from newpath to oldpath. The corresponding syscall is

          link(char *oldpath, char *newpath)

NOTE: Hard links can only be applied to non-DIR files. 
      (What would happen if DIRs could  be hard linked ?) 

Hard linked files share the same inode, whose nlink field records the number of
hard links to the inode. Converse to link, the syscall
 
        unlink(char *pathname)

finds the inode of pathname and decrements its nlink by 1. The file is truly 
removed only if nlink becomes 0. This is what the rm command does.
    
SOFT Links:  
     The command   ln -s  oldpath newpath  

creates a SOFT or Symbolic link from newpath to oldpath. The corresponding
syscall is 
             symlink(char *oldpath, char *newpath)

The newpath is (almo
myread: read 1024 char from file descriptor 0
st a regular) file, which contains the oldpath string. It
acts like a detour road sign, which directs the traffic to the real destination
(oldpath). Unlike hard links, soft links can be applied to any file, such as

             ln -s   aVeryLongPathname                 a
             ln -s   aFileWhichMayBeChangedOften       b

One drawback of soft link is that the target file may NOT exist. If so, the
detour would direct the poor driver to fall off a cliff. In Linux, such death
traps are displayed in (the appropriate color of) RED under the ls -l command.

Also, if foo -> /a/b/c is a soft link file, the open("foo", 0) syscall, as 
implemented, will open the target file /a/b/c, not the link file foo itself. 
So, the open()/read() syscalls would NOT read any soft link file. Instead, the
syscall, readlink(), must be used to read the contents of a soft link file. 

 
A Brief Summary about Links:
           Command                               Syscall used
  =====================================================
myread: read 1024 char from file descriptor 0
==================
    ln     oldpath newpath             link(char *oldpath, char *newpath)
    ln -s  oldpath newpath          symlink(char *oldpath, char *newpath)
  =======================================================================

6-2. File Status:
   Every file has a UNIQUE inode, whcih contain ALL the information about the
file. The syscalls, stat/lstat/fstat, return the info of a file. (

9-2-1. INODE:
     Every file is represented by a unique INODE data strucutre, which is shown
here for reference.:

struct ext2_inode {
  unsigned short i_mode;
  unsigned short i_uid;
  unsigned long  i_size;
  unsigned long  i_atime;
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;
  unsigned short i_links_count;
  unsigned long  i_blocks;
  unsigned long  i_flags;
  unsigned long  i_reserved1;
  unsigned long  i_block[15];
  // several other unimportant fields
};

6-2.2  The man pages of stat:
    Use  man stat  to read the man pages of the stat system cal
myread: read 1024 char from file descriptor 0
l, which is 
shown below.
=============================================================================
STAT(2)                    System calls                   STAT(2)

NAME
       stat, fstat, lstat - get file status

SYNOPSIS
       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;unistd.h&gt;

       int stat(const char *file_name, struct stat *buf);
       int fstat(int filedes, struct stat *buf);
       int lstat(const char *file_name, struct stat *buf);

DESCRIPTION
       These  functions  return  information  about the specified
       file.  You do not need any access rights to  the  file  to
       get  this  information  but  you need search rights to all
       directories named in the path leading to the file.

       stat stats the file pointed to by file_name and  fills  in
       buf.

       lstat  is  identical to stat, except in the case of a sym-
       bolic link, where the link itself is stat-ed, not the file
       that it refers to.

       fstat  i
myread: read 1024 char from file descriptor 0
s identical to stat, only the open file pointed to
       by filedes (as returned by open(2)) is stated in place  of
       file_name.


       They  all return a stat structure, which contains the fol-
       lowing fields:

            struct stat {
                dev_t         st_dev;      /* device */
                ino_t         st_ino;      /* inode */
                mode_t        st_mode;     /* protection */
                nlink_t       st_nlink;    /* number of hard links */
                uid_t         st_uid;      /* user ID of owner */
                gid_t         st_gid;      /* group ID of owner */
                dev_t         st_rdev;     /* device type (if inode device) */
                off_t         st_size;     /* total size, in bytes */
                unsigned long st_blksize;  /* blocksize for filesystem I/O */
                unsigned long st_blocks;   /* number of blocks allocated */
                time_t        st_atime;    /* time of last access */
                time_t    
myread: read 1024 char from file descriptor 0
    st_mtime;    /* time of last modification */
                time_t        st_ctime;    /* time of last change */
            };

       The value st_size gives the size of the file (if it  is  a
       regular file or a symlink) in bytes. The size of a symlink
       is the length of the pathname it contains, without  trail-
       ing NULL.

       The value st_blocks gives the size of the file in 512-byte
       blocks.  (This may be smaller than st_size/512  e.g.  when
       the file has holes.)  The value st_blksize gives the "pre-
       ferred" blocksize for efficient file system I/O.  (Writing
       to a file in smaller chunks may cause an inefficient read-
       modify-rewrite.)

       Not all of the Linux filesystems implement all of the time
       fields.   Some  file system types allow mounting in such a
       way that file accesses do  not  cause  an  update  of  the
       st_atime field. (See `noatime' in mount(8).)

       The  field  st_atime  is changed by file accesses, e.g. by
  
myread: read 1024 char from file descriptor 0
     exec(2), mknod(2), pipe(2), utime(2) and read(2) (of  more
       than zero bytes). Other routines, like mmap(2), may or may
       not update st_atime.

       The field st_mtime is changed by file modifications,  e.g.
       by  mknod(2),  truncate(2), utime(2) and write(2) (of more
       than zero bytes).  Moreover, st_mtime of  a  directory  is
       changed  by  the  creation  or  deletion  of files in that
       directory.  The st_mtime field is not changed for  changes
       in owner, group, hard link count, or mode.

       The  field  st_ctime  is  changed by writing or by setting
       inode information (i.e., owner, group, link  count,  mode,
       etc.).

       The  following  POSIX macros are defined to check the file
       type:

              S_ISREG(m)  is it a regular file?

              S_ISDIR(m)  directory?

              S_ISCHR(m)  character device?

              S_ISBLK(m)  block device?

              S_ISFIFO(m) fifo?

              S_ISLNK(m)  symbolic link? (Not in PO
myread: read 1024 char from file descriptor 0
SIX.1-1996.)

              S_ISSOCK(m) socket? (Not in POSIX.1-1996.)

       The following flags are defined for the st_mode field:

       S_IFMT     0170000   bitmask for the file type bitfields
       S_IFSOCK   0140000   socket
       S_IFLNK    0120000   symbolic link
       S_IFREG    0100000   regular file
       S_IFBLK    0060000   block device
       S_IFDIR    0040000   directory
       S_IFCHR    0020000   character device
       S_IFIFO    0010000   fifo

       S_ISUID    0004000   set UID bit
       S_ISGID    0002000   set GID bit (see below)
       S_ISVTX    0001000   sticky bit (see below)

       S_IRWXU    00700     mask for file owner permissions
       S_IRUSR    00400     owner has read permission
       S_IWUSR    00200     owner has write permission
       S_IXUSR    00100     owner has execute permission
       S_IRWXG    00070     mask for group permissions
       S_IRGRP    00040     group has read permission
       S_IWGRP    00020     group has write permission
       S_IXGRP 
myread: read 1024 char from file descriptor 0
   00010     group has execute permission
       S_IRWXO    00007     mask for permissions for others (not in group)
       S_IROTH    00004     others have read permission
       S_IWOTH    00002     others have write permisson
       S_IXOTH    00001     others have execute permission

RETURN VALUE
       On success, zero is returned.  On error, -1  is  returned,
       and errno is set appropriately.


SEE ALSO
       chmod(2), chown(2), readlink(2), utime(2)
=============================================================================

6-2.3 File Type and Permissions:
    Among the fileds of the stat structure, only the st_mode field needs
    some explanation:

       mode_t        st_mode;     /* copied from i_mode of INODE */

    The TYPE of st_mode is unsigned short (2 bytes or 16 bits). 
    The 16 bits have the following meaning:

       |Type|   |permissions|
       ----------------------
       |tttt|fff|uuu|ggg|ooo| 
       ----------------------

    The leading 4 bits are file types, which can
myread: read 1024 char from file descriptor 0
 be interpreted as (Octals)

       S_IFMT     0170000   bitmask for the file type bitfields
       S_IFSOCK   0140000   socket
       S_IFLNK    0120000   symbolic link
       S_IFREG    0100000   regular file
       S_IFBLK    0060000   block device
       S_IFDIR    0040000   directory
       S_IFCHR    0020000   character device
       S_IFIFO    0010000   fifo
 
    The next 3 bits are flags, which indicate special usage of the file 

       S_ISUID    0004000   set UID bit
       S_ISGID    0002000   set GID bit 
       S_ISVTX    0001000   sticky bit 

    The remaining 9 bits are PERMISSION bits for file protection:

        owner  group  other
         rwx    rwx    rwx
    
    By interpreting these bits, YOU may disaplay the st_mode field as
       -rwxr-xr-x             (REG file) 
       drwxr-xr-x             (DIR)
       lrw-r--r--             (LNK file)

==============================================================================
6-3. HOW TO read DIR Entries:
   Read the man pages of   
    
myread: read 1024 char from file descriptor 0
        opendir, readdir, readlink  
to learn how to use these syscalls to open a DIR file for read, and then read 
the contents of a DIR file (as DIR entry strings). Alos, learn how to read the
contents of a (soft) LNK file itself.
<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>type.h for Project</H1>

<Pre>

/*	type.h for CS360 Project             */

#include &lt stdio.h >
#include &lt fcntl.h>
#include &lt linux/ext2_fs.h>
#include &lt libgen.h>
#include &lt string.h>
#include &lt sys/stat.h>

// define shorter TYPES, save typing efforts
typedef struct ext2_group_desc  GD;
typedef struct ext2_super_block SUPER;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

#define BLOCK_SIZE        1024
#define BITS_PER_BLOCK    (8*BLOCK_SIZE)
#define INODES_PER_BLOCK  (BLOCK_SIZE/sizeof(INODE))

// Block number of EXT2 FS on FD
#define SUPERBLOCK        1
#define GDBLOCK      
myread: read 1024 char from file descriptor 0
     2
#define BBITMAP           3
#define IBITMAP           4
#define INODEBLOCK        5
#define ROOT_INODE        2

// Default dir and regulsr file modes
#define DIR_MODE          0040777 
#define FILE_MODE         0100644
#define SUPER_MAGIC       0xEF53
#define SUPER_USER        0

// Proc status
#define FREE              0
#define BUSY              1
#define KILLED            2

// Table sizes
#define NMINODES          50
#define NMOUNT            10
#define NPROC             10
#define NFD               10
#define NOFT              50

// Open File Table
typedef struct Oft{
  int   mode;
  int   refCount;
  struct Minode *inodeptr;
  long  offset;
} OFT;

// PROC structure
typedef struct Proc{
  int   uid;
  int   pid;
  int   gid;
  int   ppid;
  struct Proc *parent;
  int   status;

  struct Minode *cwd;
  OFT   *fd[NFD];
} PROC;
      
// In-memory inodes structure
typedef struct Minode{		
  INODE    INODE;               // disk inode
  ushort   dev;
  unsigned long ino;
  ushort   refCount;
  usho
myread: read 1024 char from file descriptor 0
rt   dirty;
  ushort   mounted;
  struct Mount *mountptr;
  char     name[128];           // name string of file
} MINODE;

// Mount Table structure
typedef struct Mount{
        int    ninodes;
        int    nblocks;
        int    dev, busy;   
        struct Minode *mounted_inode;
        char   name[256]; 
        char   mount_name[64];
} MOUNT;
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HOWTO #3</H1>

<Pre>
   The util.c file contains utility functions that are needed by most other  
   functions.  It is suggested that you implement the following.

1. get_block(dev, blk, buf) 
   put_block(dev, blk, buf)    These require no explanation.


2. token_path(char *pathname)
{
  This function breaks up a pathname, such as /a/b/c/d, into components
  a   b   c   d  and  determines the number of components n.
  The components will be used to search for the inode of pathname. 
}


3. dirname() and basename():
   Use these functions to divide a pathname into dirname an
myread: read 1024 char from file descriptor 0
d basename
   NOTE: They are in clib but both functions destroy the parameter string
  
4. unsigned long getino(int *dev, char *pathname)
{
  This is the most important function of the project. It converts
  a pathname, such as /a/b/c/d OR x/y/z, into its (dev, inumber), i.e. 
  the returned value is its inumber and dev is its dev number. 

  NOTE: while traversing a pathname, the starting dev number is the dev of / 
  OR the dev of (running's) CWD. If you have only one device, the dev number 
  will not change. But when crossing MOUNTed file systems (for Level-3), the
  dev number may change. The dev parameter is used to keep the CURRENT dev 
  number.

  This function depends on search(), which searches an DIR's data block for 
  a component name, and returns the component's inmuber. Modify *dev if the
  dev number changes.
  
  You have already done these in showblock.c
}   

5. unsigned long search(MINODE *mip, char *name)
{
   This function searches the data blocks of a DIR inode (inside an Minode[])
   
myread: read 1024 char from file descriptor 0
for name. You may assume DIRECT data blocks only.
}


6. MINODE *iget(int dev, unsigned long ino)
{
  Once you have the (dev, ino) of an inode, you may load the inode into a slot
  in the Minode[] array. To ensure uniqueness, you must search the Minode[] 
  array to see whether the needed INODE is already loaded.

  If you find the needed INODE already in a Minode[] slot, just inc its 
  refCount by 1 and return the Minode[] pointer.

  If you do not find it in memory, you must allocate a FREE Minode[i], load
  the INODE from disk into that Minode[i].INODE, initialize the Minode[]'s
  other fields and return its address as a MINODE pointer,
}


7. iput(MINODE *mip)
{
  This function releases a Minode[]. Since an Minode[]'s refCount indicates
  the number of users on this Minode[], releasing is done as follows:
    First, dec the refCount by 1. If (after dec) refCount > 0 ==> return;
    else:
      if Minode[].dirty == 0 ==> no need to write back, so return;
      Otherwise, (dirty==1) ==> must write the INOD
myread: read 1024 char from file descriptor 0
E back to disk.
   
  To write an INODE back to disk:
     Use Minode's (dev, ino) to determine which dev and which INODE on disk,
  i.e. which disk block and which inode in that block.
  Read that block in, copy Minode's INODE into the INODE area in that block
  and write the block back to disk.
} 


8. int findmyname(MINODE *parent, unsigned long myino, char *myname) 
{
   Given the parent DIR (MINODE pointer) and my inumber, this function finds 
   the name string of myino in the parent's data block. This is similar to 
   SERACH() mentioned above.
}


9. int findino(MINODE *mip; unsigned long *myino, *parentino)
{
  For a DIR Minode, extract the inumbers of . and .. 
  Read in 0th data block. The inumbers are in the first two dir entries.
}
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                     HOWTO write    

int write_file()
{
  1. Preprations:
     ask for a fd   and   a text string to write.

  2. verify fd is indeed opened for W
myread: read 1024 char from file descriptor 0
 or RW or APPEND mode

  3. copy the text string into a buf[] and get its length as nbytes.

     return(mywrite(fd, buf, nbytes));
}



// mywrite behaves exactly the same as Unix's write(fd, buf, nbytes) syscall.
// it writes nbytes from buf[] to the file fd

int mywrite(int fd, char *buf, int nbytes) 
{
  while (nbytes > 0 ){

     compute LOGICAL BLOCK (lbk) and the startByte in that lbk:
          lbk       = oftp->offset / BLOCK_SIZE;
          startByte = oftp->offset % BLOCK_SIZE;

    // I only show how to write DIRECT data blocks, you figure out how to 
    // write indirect and double-indirect blocks.

     if (lbk < 12){                         // direct block
        if (ip->INODE.i_block[lbk] == 0)    // if no data block yet
            mip->INODE.i_block[lbk] = balloc(mip->dev);
        blk = mip->INODE.i_block[lbk];
     }
     else if (lbk >= 12 && lbk < 256 + 12){ 
            // indirect blocks
     }
     else{
            // double indirect blocks */
     }

     /* all cases come to here
myread: read 1024 char from file descriptor 0
 : write to the data block */
     get_block(mip->dev, blk, wbuf);   // read disk block into wbuf[ ]  
     char *cp = wbuf + startByte;      // cp points at startByte in wbuf[]
     remain = BLOCK_SIZE - startByte;  // number of bytes remain in this block

     while (remain > 0){               // write as much as remain allows  
           *cp++ = *cq++;              // cq points at buf[ ]
           nbytes--; remain--;         // dec counts
           oftp->offset++;             // advance offset
           if (offset > i_size)        // especially for RW|APPEND mode
               mip->INODE.i_size++;    // inc file size (if offset>filesize)
           if (nbytes <= 0) break;     // if already nbytes, break
     }
     put_block(mip->dev, blk, wbuf);   // write wbuf[ ] to disk
     
     // loop back to while to write more .... until nbytes are written
  }

  mip->dirty = 1;       // mark mip dirty for iput() 
  show ("wrote %d char into file fd=%d\n", nbytes, fd);           
  return nbytes;
}
<TITLE>CS3
myread: read 1024 char from file descriptor 0
60 NOTES</Title>
<Body bgcolor="#FFFFd8" text="#000000">
<H1>CS360 NOTES</H1>
<Pre>
                   360 NOTES on TCP/IP

1. IP stands for Internet Protocol. TCP (Transmission Control Protocol) is a 
   protocol built on top of IP. TCP/IP is the backbone of InterNet. Currently 
   there are 2 versions of IP, known as IPv4 and IPv6. IPv4 uses 32-bit address
   and IPv6 uses 128-bit address. The discussion here is based on IPv4, which 
   is still the predominat version IP in use.

2. Host and IP address:
   A host is a machine that runs IP. Every host is identified by a unique 
   32-bit number called the IP address. For human convenience, this 32-bit 
   number is usually expressed in a "dotted" notation, such as 134.121.64.1  
   A host is also known by a host name, e.g. dns1.eecs.wsu.edu. Host name and 
   IP address are "equivalent" in the sense that, given one, we can find the 
   other (by a Domain-Name-Server, DNS). 

   An IP address is divided into two parts: | networkID | hostID |.
   Depending on 
myread: read 1024 char from file descriptor 0
networkID, IP addresses are classified as

                                             Decimal Notation:
   Class A : |0xxxxxxx|    24 bits          |    1-126
             | netID  |    host ID          |

   Class B : |10| 14 bits   |   16 bits     |    128-191  
             |   NetID      |   HostID      |
   
   Class C : |110 21 bits            |8 bits|    192-223
             |       netID           |host  |
   ------------------------------------------------------- 
   Class D : |1110x|  multicast group ID    |
   Class E : |11110|  reserved              |

   Data packets intended for an IP address are first sent to a "Router" with 
   the same NetworkID.  That router will forward the packets to a specific
   host by using the HostID.

3. What is IP ?  
   IP is a protocol for sending/receiving data packets between hosts. IP 
   operates in a best-effort manner, i.e. it just sends the packets out, but 
   does NOT guarantee that they will be delivered to their destinations, NOR 
   in order. So, IP 
myread: read 1024 char from file descriptor 0
may be unreliable. 

4. IP Packet Format:
   An IP packet consists of

      | Header |SourceIP|DestIP|<-----  DATA ---->|
         12       4        4   | upto 64K-24 bytes|
        
   The Header part contains more information, e.g. total length, TCP/UDP, TTL, 
   check-sum for error detection, etc. about the packet so that a receiving
   host would know what to do with the packet. For example, an IP packet is
   simply dropped if its check-sum indicates an error or its TTL has expired.

5. Routers:
   IP hosts may be located far apart. It is usually not possible to send data 
   packets from one host to the other DIRECTLY. "Routers" are special IP hosts 
   that receive and forward packets. Therefore, IP packets may go through 
   many routers, or "hops",  before arriving at a destination. 


6. UDP (User DataGram Protocol)
   UDP operates on top of IP. It is used to send/receive "datagrams". Like
   IP, UDP doe NOT guarantee reliability but it is fast and efficient. It is 
   used in situations where reli
myread: read 1024 char from file descriptor 0
ablility is not essential.
   Example:

      ping mail.wsu.edu     OR    ping 134.121.1.8
   
   ping is a program that sends a UDP packet to a host, which "echo" the UDP 
   packet back to the sender with a round-trip time.
      
7. TCP (Transmission Control Protocol)
   TCP also operates on top of IP but guarantees reliable data transfer. It is
   a connection-oriented protocol for sending/receiving "data streams". 

   A common analogy is that UDP is similar to "telegram" (or USPS), and TCP is
   similar to "telephone".

8. Port Number:
   At each IP host, many applications may be using UDP/TCP at the same time. 
   Each application is uniquely identified by a triple
        Application = (HostIP, Protocol, PortNumber)
   where Protocol is either UDP or TCP, and PortNumber is a unique 2-byte 
   unsiged integer assigned to the application. In order to use UDP or TCP at 
   a host, an application (process) must choose or obtain a PortNumber first. 
   The first 1024 port numbers (0 to 1023) are reserved. 
myread: read 1024 char from file descriptor 0
 

9. Network and Host (byte) Order:
   Machines may use either "big-endian" or "little-endian" byte-ordering. On 
   the "Internet", data are always in "network order", which is "big-endian".

   A set of library functions htons()/htonl(), ntohs()/ntohl() are used to 
   convert data between host-order and network-order. 

10. Server-Client Model:
    In network programming, we typically run a Server at a host first. The 
    Server waits for Client requests and serves the requests. In UDP, the 
    Server simply waits for "datagrams" from a Client. In TCP, the Server 
    waits for a Client to "connect".

    Then, we run the Client from a client host, In UDP, the client simply sends
    each request as a UDP datagram to the Server. Then it receives a reply 
    datagram from the Server. In TCP, the Client requests to connect to the 
    Server first. Then the Server and Client can exchange "continuous" streams
    of data.

In the following, we shall show how to do network programming using TCP.

11. Netwo
myread: read 1024 char from file descriptor 0
rk Programming:
    Unix (Linux) Kernel provides TCP/IP support. User interface to TCP/IP is
    through "sockets". To the user (program), creating a socket is similar to 
    opening a file for RW. It returns a file descriptor so that the same 
    read()/write() system calls can be used to transfer data.   

12. Sockets Programming

    First, we need the following C structs defined in netdb.h and sys/socket.h

12-1.The socket address data structure:

    struct sockaddr_in {
       u_short        sin_family; /* protocol identifier; usually AF_INET */
       u_short        sin_port;   /* port number. 0 means let kernel choose */
       struct in_addr sin_addr;   /* IP address. INADDR_ANY=the current host.*/
       char           sin_zero[8];}; /* Unused, always zero */
    }

    struct in_addr {
        u_long s_addr;
    };

12-2. The hostent struct in &lt;netdb.h&gt; is as shown (man gethostbyname):
        
        struct hostent {
               char    *h_name;        // DOT name string of host
      
myread: read 1024 char from file descriptor 0
         char    **h_aliases;    // alias list 
               int     h_addrtype;     // host address type
               int     h_length;       // length of address
               char    **h_addr_list;  // list of addresses (long IP address)
        }
        #define h_addr  h_addr_list[0]  // for backward compatibility 

        // NOTE: h_addr is defined as a char * but it points at the IP_address,
        //       which is a 4-byte number in network (big-endian) order.
        // ulong NIP = *(ulong *)h_addr is the IP_address in network order.
        // ulong HIP = ntohl(NIP) is NIP in host order (INTEL=little-endian).
        // inet_ntoa(NIP) converts NIP to a string in DOT notation.

13. An ECHO Server/Client Program using TCP

    Shown below are the C source files of an ECHO server and a client.
    These files are also available in ~samples/LAB4/. 

    First, run the server at a host as        server [hostname]
    where hostname is either the DNS name or IP address of the host machine. 
    If
myread: read 1024 char from file descriptor 0
 no hostname is given, the default "localhost" (127.0.0.1) will be used.

    The Server first displays the server's hostname, IP address and port number
    Then it waits for a client to connect.

    Next, run the client at another host as   client ServerName ServerPort

    (You may also run both on the SAME host but in separate X-windows).

    After connecting to the server, the client asks the user for an input 
    string, sends it to the server, which simply echos the string back.

    When the client ends (by Enter or Control-C), the server loops back
    to accept another connection, etc.

    The sequence of actions between the server and the client are shown
    in the following diagram.

                                ACTIONS OF 
            Server                                       Client:
   --------------------------------      ---------------------------------
1. Display hostname, IP, Port#      ===> 1. MUST know Server's name|IP,Port#
2. Construct a server_addr struct        2. Construct
myread: read 1024 char from file descriptor 0
 a server_addr struct 
3. Create a TCP socket with Port#        3. Create a TCP socket sock
4. Bind socket to server_addr info             
5. Listen at socket by listen() syscall
6. newsock = accept()               <==  4. connect() to Server via sock
   ------------------------------------------------------------------------
                           Send/Receive Data
7. READ from newsock      <------------------  WRITE to  sock
   WRITE to  newsock      ------------------>  READ from sock
   ------------------------------------------------------------------------
8. loop to 6 to accept next client             close(sock);

//**************************************************************************
//           This Server-Client package uses TCP sockets.
//              This is the ECHO SERVER server.c file. 
//**************************************************************************

#define  MAX 256

#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;

// Define variables:
struct sockaddr_in  serve
myread: read 1024 char from file descriptor 0
r_addr, client_addr, name_addr;
struct hostent *hp;

int  sock, newsock;                  // socket descriptors
int  serverPort;                     // server port number
int  r, length, n;                   // help variables

// Server initialization code:

int server_init(char *name)
{
   printf("==================== server init ======================\n");   
   // get DOT name and IP address of this host

   printf("1 : get and show server host info\n");
   hp = gethostbyname(name);
   if (hp == 0){
      printf("unknown host\n");
      exit(1);
   }
   printf("    hostname=%s  IP=%s\n",
               hp->h_name,  inet_ntoa(*(long *)hp->h_addr));
  
   //  create a TCP socket by socket() syscall
   printf("2 : create a socket\n");
   sock = socket(AF_INET, SOCK_STREAM, 0);
   if (sock < 0){
      printf("socket call failed\n");
      exit(2);
   }

   printf("3 : fill server_addr with host IP and PORT# info\n");
   // initialize the server_addr structure
   server_addr.sin_family = AF_INET;               
myread: read 1024 char from file descriptor 0
   // for TCP/IP
   server_addr.sin_addr.s_addr = htonl(INADDR_ANY);   // THIS HOST IP address  
   server_addr.sin_port = 0;   // let kernel assign port

   printf("4 : bind socket to host info\n");
   // bind syscall: bind the socket to server_addr info
   r = bind(sock,(struct sockaddr *)&server_addr, sizeof(server_addr));
   if (r < 0){
       printf("bind failed\n");
       exit(3);
   }

   printf("5 : find out Kernel assigned PORT# and show it\n");
   // find out socket port number (assigned by kernel)
   length = sizeof(name_addr);
   r = getsockname(sock, (struct sockaddr *)&name_addr, &length);
   if (r < 0){
      printf("get socketname error\n");
      exit(4);
   }

   // show port number
   serverPort = ntohs(name_addr.sin_port);   // convert to host ushort
   printf("    Port=%d\n", serverPort);

   // listen at port with a max. queue of 5 (waiting clients) 
   printf("6 : server listening ....\n");
   listen(sock, 5);
   printf("===================== init done =======================\n");
}

m
myread: read 1024 char from file descriptor 0
ain(int argc, char *argv[])
{
   char *hostname, line[MAX];

   if (argc < 2)
      hostname = "localhost";
   else
      hostname = argv[1];
 
   server_init(hostname); 

   // Try to accept a client request
   while(1){
     printf("server: accepting new connection ....\n"); 

     // Try to accept a client connection as descriptor newsock
     length = sizeof(client_addr);
     newsock = accept(sock, (struct sockaddr *)&client_addr, &length);
     if (newsock < 0){
        printf("server: accept error\n");
        exit(1);
     }
     printf("server: accepted a client connection from\n");
     printf("-----------------------------------------------\n");
     printf("        IP=%s  port=%d\n", inet_ntoa(client_addr.sin_addr.s_addr),
                                        ntohs(client_addr.sin_port));
     printf("-----------------------------------------------\n");

     // Processing loop
     while(1){
       n = read(newsock, line, MAX);
       if (n==0){
           printf("server: client died, server l
myread: read 1024 char from file descriptor 0
oops\n");
           close(newsock);
           break;
      }
      
      // show the line string
      printf("server: read  n=%d bytes; line=[%s]\n", n, line);

      strcat(line, " ECHO"); // ASSUME line[MAX] still has room for " ECHO"

      // send the echo line to client 
      n = write(newsock, line, MAX);

      printf("server: wrote n=%d bytes; ECHO=[%s]\n", n, line);
      printf("server: ready for next request\n");
    }
 }
}


//*********************** ECHO CLIENT client.c file *************************

#define MAX 256

#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;


// Define variables
struct hostent *hp;              
struct sockaddr_in  server_addr; 

int sock, r;
int SERVER_IP, SERVER_PORT; 

int client_init(char *argv[])
{
  printf("======= clinet init ==========\n");

  printf("1 : get server info\n");
  hp = gethostbyname(argv[1]);
  if (hp==0){
     printf("unknown host %s\n", argv[1]);
     exit(1);
  }

  SERVER_IP   = *(long *)hp->h_addr;
  SERVER_P
myread: read 1024 char from file descriptor 0
ORT = atoi(argv[2]);

  printf("2 : create a TCP socket\n");
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock<0){
     printf("socket call failed\n");
     exit(2);
  }

  printf("3 : fill server_addr with server's IP and PORT#\n");
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = SERVER_IP;
  server_addr.sin_port = htons(SERVER_PORT);

  // Connect to server
  printf("4 : connecting to server ....\n");
  r = connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
  if (r < 0){
     printf("connect failed\n");
     exit(1);
  }

  printf("5 : connected OK to \007\n"); 
  printf("---------------------------------------------------------\n");
  printf("hostname=%s  IP=%s  PORT=%d\n", 
          hp->h_name, inet_ntoa(SERVER_IP), SERVER_PORT);
  printf("---------------------------------------------------------\n");

  printf("========= init done ==========\n");
}


main(int argc, char *argv[ ])
{
  int n;
  char line[MAX], ans[MAX];

  if (argc < 3){
     printf("Usage : client
myread: read 1024 char from file descriptor 0
 ServerName SeverPort\n");
     exit(1);
  }

  client_init(argv);

  printf("********  processing loop  *********\n");
  while (1){
    printf("input a line : ");
    bzero(line, MAX);                // zero out line[ ]
    fgets(line, MAX, stdin);         // get a line (END with \n) from stdin 
    line[strlen(line)-1] = 0;        // kill \n at end
    if (line[0]==0)                  // exit if NULL line
       exit(0);

   // Send ENTIRE line to server
    n = write(sock, line, MAX);
    printf("client: wrote n=%d bytes; line=(%s)\n", n, line);

    // Read a line from sock and show it
    n = read(sock, ans, MAX);
    printf("client: read  n=%d bytes; echo=(%s)\n",n, ans);
  }
}



13-1. Run the above Server/Client programs. 
      The source files of server.c/clinet.c are in ~samples/LAB4/ directory.
      Download them, cc and run.

      Modify them to do computations, e.g. client sends 2 numbers to server, 
      which returns the SUM.

13-2. 
The above Server/Client code may be used as the basis for
myread: read 1024 char from file descriptor 0
 TCP-orineted network
programming. You may adapt it for different applications by simply changing the
data contents and the ways they process the data.

                    Example:
============================================================================== 
Instead of numbers, the Client may send a "command" string, such as

           pwd  
           ls  [pathname]
           cd  [pathname]
           get filename  
           put filename
           
The Server executes the command and sends results back to the Client. 

Simlarly, you may implement mkdir, rmdir, creat, rm operations at the Server. 
==============================================================================
<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Lab Assignment #2 </H1>

<Pre>

Given the C program:

main(int argc, char *argv[], char *env[])
{
  int a,b,c;
  printf("enter main\n");
  a=1; b=2; c=3;

     //****** DO (1): Write C code here to print the ************* 
     (1). argv[] strings
    
myread: read 1024 char from file descriptor 0
 (2).  env[] strings

  A(a,b);
  printf("exit main\n");
}

int A(int x, int y)
{
  int d,e,f;
  printf("enter A\n");
  d=3; e=4; f=5;
  B(d,e);
  printf("exit A\n");
}

int B(int x, int y)
{
  int g,h,i;
  printf("enter B\n");
  g=6; h=7; i=8;
  C(g,h);
  printf("exit B\n");
}

int C(int x, int y)
{
  int p,q,r;
  printf("enter C\n");
  p=9; q=10; r=11;

    / Write C and assembly code to 
    ********* DO (2)-(4) AS SPECIFIED BELOW *************/

  printf("exit C\n");
}
=============================================================================

(1). Call an assembly function
             getfp:   
                     pushl %ebp
                     movl  %esp, %ebp
                     ...............
     which returns the current frame pointer fp=%ebp. As shown by the diagram,
     fp is the head pointer of a link list of the stack frames, which ends 
     with a 0.

       HIHG                                                  LOW
        ---------------------------------------------------------
    
myread: read 1024 char from file descriptor 0
      0        fp0       fpM       fpA        fpB     fpC
        ---------------------------------------------------------  
          ^         ^         ^         ^          ^       ^ 
         fp0       fpM       fpA       fpB        fpC      fp

(2). Print in HEX the stack contents from fp to fp0 in the form

              Address      Contents
             ---------    ----------

             ---------    ---------- 

(3). On a hard copy of the outputs, IDENTIFY and EXPLAIN the stack contents 
     in terms of the function stack frames, i.e. local variables, parameters, 
     return address, etc. 


4: Long Jump:
   In the above calling sequence, it is possible to return from C() directly 
   to, say main(), by a long jump, as shown below:

4-1: First, define global variables

       int mainFP, mainPC;  /* for saving main()'s FP and PC */

       main()
       { 
           int r;

4-2: /**** Save long jump return point ****/
         if ( r = setjump() )

             /*******************************
myread: read 1024 char from file descriptor 0
**************
              Implement setjump() in such a way that it
              saves main's FP into mainFP, setjump()'s return
              PC into mainPC, and returns to here with a 0;
             **********************************************/    
         { 
             printf("back via long jump: r=%d\n",r);
             exit(1);
         }
4-3: /***** Normal call out ******/
         /* call A() -> B() -> C() as before */
         printf("noraml return\n");
       }


4-4:  In one of the called functions, e.g. C():

       int C()
       { .......................;

         printf("long jump back to main? {y|n) ");
        
         /**************************************
           If the answer is 'y' call the function
                 longjump(100);  
           which returns to main() via the saved 
           globals (mainFP, mainPC), and return a 
           nonzero value, e.g. 100.
          **************************************/
       }

           
-------------------  DO #3  --------
myread: read 1024 char from file descriptor 0
-------------------
3-5: Implement the functions IN ASSEMBLY:
         int setjump();
         int longjump(int returnValue);
     and DEMO your long jump in LAB.

NOTE: YOU MUST IMPLEMENT these in ASSEMBLY !!!!
=======================================================
<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Lab #2 Pre-Work</H1>

<Pre>
            DUE : in Lab 

1. A binary executable file, a.out, consists of

           |header| TEXT | DATA |<== BSS ===>|

The Unix command    size a.out   shows the size of TEXT, DATA, BSS of a.out.

Use the following C program, t1.c, to generate t2.c, t3.c,.. t6.c as specified
below. 
        //********** t1.c file ************
          int g;                              
          main()                              
          {                                   
             int a,b,c; 
             a = 1; b = 2; 
             c = a + b;
             printf("c=%d\n", c);
          }                                

t2.c: Change the g
myread: read 1024 char from file descriptor 0
lobal variable  g  to  int g=3;
t3.c  Change the global variable  g  to  int g[10000];
t4.c  Change the global variable  g  to  int g[10000] = {4);
t5.c  Change the local variables of main() to
                 int a,b,c, d[10000];
t6.c. Change the local variables of main() to
                 int a,b,c, d[10000]={5];
t7.c  Change the local variables of main() to
                 static int a,b,c, d[10000];
t8.c  Change the local variables of main() to
                 static int a,b,c, d[10000]={6};
           
(A). For each case, use cc to generate a.out. Then use  ls -l a.out to get 
     a.out size, and run size a.out to get its section sizes. Record the
     observed sizes in a table:

          Case  | a.out |  TEXT  |  DATA  |  BSS   |
        --------------------------------------------
          (1)   |       |        |        |        |
        --------------------------------------------  
          (2)
        --------------------------------------------
          (3)
        ---------------------
myread: read 1024 char from file descriptor 0
-----------------------
          (4)
        --------------------------------------------
          (5)
        --------------------------------------------        
          (6)
        --------------------------------------------
          (7)
        --------------------------------------------        
          (8)
        --------------------------------------------

                  ANSWER THESE QUESTIONS:

   1. Variables in C may be classified as

          globals ---|--- UNINITIALIZED  globals;
                     |---   INITIALIZED  globals;

          locals  ---|--- AUTOMATIC locals;
                     |--- STATIC    locals;
          

   In terms of the above classifications and the variables g, a, b, c, d,

      Which variables are in DATA? ______________________________________
      Which variables are in BSS ? ______________________________________

   2. In terms of the TEXT, DATA and BSS sections,
      Which sections are in a.out, which section is NOT in a.out?
      WHY?__________
myread: read 1024 char from file descriptor 0
____________________________________________

  (B). For each case, use   cc -static t.c   to generate a.out.
       Record the sizes again and compare them with the sizes in (A).
       WHAT DO YOU SEE?_________________________________________________

       WHY?______________________________________________________________


2. Given the C function, test.c:
     int g;
     int sub(int x, int y)
     {
        int a, b;
        g = 1;
        x = 2; y = 3;
        a = 4; b = 5;
        return 6;
     }

Use cc -S test.c to generate test.s   Examine the test.s file

ABSWER these questions: WHAT ARE THE addresses OF
(1). g?______________________________________________________
(2). parameters x, y ________________________________________
(3). locals a, b     ________________________________________
(3). Which CPU register contains the return value?___________       
<html>
<Body bgcolor="#00cccc" text="#000000">
<pre>

     CS360 Lab Assignment #4 : File Operations across Networks
               
           
myread: read 1024 char from file descriptor 0
        WORK IN 2-person teams
                  DUE & DENO : to be posted


A. OBJECTIVE:
   Network Programming using TCP.
   Unix system calls for file operations.

B. PRE Lab (Do these on your own).:
   Donwload the server.c and client.c files from samples/LAB4/ direcotry.
   cc and run the server and client programs.

   Modify the programs to do the following:
      Client: input 2 numbers, send them to server and get the answer.
      Server: Add the two numbers and send the result back to client.

C. REQUIREMENTS:
   Modify the server/client programs in samples/LAB4/ to do the following:

     Client : input a command:
              ----------------  
              pwd
              ls   [pathname]
              cd    pathname
              mkdir pathname
              rmdir pathname       
              rm    pathname       (rm pathname file)
              get   pathname       (cp pathname file to client side)
              put   pathname       (cp pathanme file to server side)
              quit    
myread: read 1024 char from file descriptor 0
             (Client exits)
           -----------------
           send command to Server.
           receive reply (results) from Server.

     Also,implement the (local) commands
         lpwd, lls, lcd, lmkdir. lrmdir, lrm
     which the Client executes LOCALLY.

     Server:
             get a command from Client;
             perform the command;
             send reply to Client;

C. HELP Hints:

   Make each command a fixed-length string, e.g. of LEN=128 bytes.
   REASON: a TCP socket contains a "stream" of data. Each read operation
           reads whatever is available in the socket. Using fixed-length 
           items simplifies reading inidvidual command strings.

D. Sample Solutions
   in samples/LAB4/ : lab4.server  and lab4.client

<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H2>360 LAB Pre-Work #6</H2>
<Pre>
                   CS 360 LAB #5 Pre_work
          PART 1 only:   DUE Wed Oct 15, in LAB 
===========================================================================
myread: read 1024 char from file descriptor 0
====

1. Given: kcmkfs.c file in samples/LAB5

   Write YOUR own C code for 

         get_block(int dev, char *buf, int blk);
         put_block(int dev, char *buf, int blk);

   where dev is an opened file descriptor of a "DEVICE", such as a FD. 

         set_bit(char buf[], int bit);
         clr_bit(char buf[], int bit):
         
         make_bmap();
         make_imap();

   to make the program kcmkfs.c complete. DEMO YOUR WORK on Wednesday,3-19


2. ASSUME: mkfs /dev/fd0 1440  OR  kcmkfs /dev/fd0 1440 184   
   Write C programs to display the specified information on the FD:
------------------------------------------------------------------------
1. super.c  : the superblock information,
2. gd.c     : the group descriptor information.
3. bmap.c   : the Bmap as a sequence of 0/1 chars (80 chars per row).
4. imap.c   : the Imap as a sequence of 0/1 chars (80 chars per row)
5. inode.c  : root inode info
6. dir.c    : dir_entries of the root directory.
----------------------------------------------------
myread: read 1024 char from file descriptor 0
---------------------


//Sample dir.c code

<PRE>

#include &lt;fcntl.h&gt;
#include &lt;linux/ext2_fs.h&gt;

// define shorter TYPES
typedef struct ext2_group_desc    GD;
typedef struct ext2_super_block   SUPER;
typedef struct ext2_inode         INODE;
typedef struct ext2_dir_entry_2   DIR;  

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 


char buf[1024], rbuf[1024];
int fd, blk, i;

int get_block(int blk, char *buf)
{
  // read disk blk into buf[ ]
}

main()
{
  char *cp, temp[256];

  fd=open("/dev/fd0", O_RDONLY);

  get_block(5, buf);      // get root inode block
  ip = (INODE *)buf + 1;  // it's inode #2

  for (i=0; i<12; i++){   // ASSUME dir has only direct blocks
    blk = ip->i_block[i];
    printf("i_block[%d] = %d\n", i, blk);  // print blk number
    if (blk==0)
       break;

    get_block(blk, rbuf); // get block contents into rbuf[] 
    
    dp = (DIR *)rbuf;     // as DIR entries
    cp = rbuf;            
 
   while(cp &lt; &rbuf[1024]){
      bzero(temp, 256);
      strncpy(temp, dp->nam
myread: read 1024 char from file descriptor 0
e, dp->name_len);

      // print DIR entry info
      printf("%4d %4d %4d  %s\n", dp->inode, dp->rec_len, dp->name_len, temp);
      // In addition to printing, CAN YOU SEARCH FOR A name STRING? 
      // OR SEARCH FOR A INOODE NUMBER?
      
      cp += dp->rec_len;
      dp = (DIR *)cp;
   }
  }
}







<html>
<Body bgcolor="#00cccc" text="#000000">
<H1>CS360 Lab Assignment #3 : sh Simulator</H1>
<pre>

                DUE & DENO : To be posted

A. OBJECTIVE:
   Understand how Unix sh works by using fork/wait/exec.
   String operations

B. REQUIREMENTS:
   Write a C program, mysh, which simulates the Unix sh for command processing.
   Your mysh should run as follows:

1. Prompt for an input line, which is of the form
          cmd arg1 arg2 arg3 .... argn
   where cmd is a command.

   For simplicity, do NOT consider sh scripts files.
   Valid commands include only "echo", "cd", "exit", and ANY Unix binary 
   executables, e.g. ls, date, pwd, cat, cp, mv, cc ... you name it !!!


2. Handle simple commands
myread: read 1024 char from file descriptor 0
:
     cmd = "cd"   :  chdir(arg1) OR chdir($HOME) if no arg1;
     cmd = "echo" :  echo the remaining line;
     cmd = "exit" :  exit(1) to terminate;  

   NOTE: chdir(pathname) is a syscall to change CWD.
         $HOME is the home directory; YOU must find its value from *env[ ].

3. For all other commands:
      fork a child process;
      wait for the child to terminate;
      print child's exit status code
      continue step 1;

4. Child process:
   4-1. Handle I/O redirection:
          cmd  arg1 arg2 ...  <  infile    // take inputs from infile
          cmd  arg1 arg2 ...  >  outfile   // send outputs to outfile
          cmd  arg1 arg2 ...  >> outfile   // APPEND outputs to outfile
        For simplicity, assume at most ONE I/O redirection per line.

   4-2. Execute cmd by execve(), passing parameters 
                char *myargv[], char *env[]
        to the cmd file, 
        where myargv[0]->cmd, myargv[1]->arg1, ....., ending with NULL pointer

        NOTE: if cmd begins with /, execute it di
myread: read 1024 char from file descriptor 0
rectly.
              otherwise, try to execute pathdir/cmd for every pathdir in $PATH


5. SAMPLE SOLUTION:
   
   ~samples/LAB3/lab3.bin          (down load and run under Linux)

===========================  I/O Redirections ===============================

6. I/O Redirections:

6-1. Stream FILEs and File Descriptors:
   Recall that the sh process has 3 stream FILEs: stdin, stdout, stderr.
   When sh forks a child, the child process also has the same FILE streams.
   Each of the FILE streams corresponds to an opened file in the Unix kernel.
   Each opened file has a unique file descriptor (number). The file descriptors
   of stdin, stdout, stderr are 0,1,2, respectively.

6-2. Stream I/O and System Call:
   When a process executes        scanf("formatString", &item);
   it tries to input an item from stdin, which points to a FILE struct.If the
   FILE struct's buffer is empty, it issues a system call to the Unix kernel,
   to READ data from the file descriptor 0, which is mapped to the terminal
   (/dev/tty
myread: read 1024 char from file descriptor 0
X) of the sh process.

                      REDIRECT INPUT: 
   If we let stdin point to the FILE struct of a diffferent file that's 
   opened for input, then every scanf() would read inputs from the new file.
   So, if we do
              fclose(stdin);
   which erases the FILE struct pointed by stdin, casuing stdin to be NULL, 
   followed by
              stdin = fopen("filename", "r");
   which fopens filename for READ and let stdin point at the new FILE struct,
   then scanf() would get inputs from the file filename.
   
   The FILE struct of stdin contains a file descriptor 0. If we replace the 
   file descriptor 0 with a newly opened file, we would achieve the same 
   effect. Thus, if we do 
           close(0);    // system call to close file descriptor 0
           open("filename", O_RDONLY);  // open filename for READ, which
                                        // will replace fd 0
   Then, every scanf() call will get inputs from the opened file.


   Similarly, when a process executes      p
myread: read 1024 char from file descriptor 0
rintf("formatString", item);
   it tries to write to stdout, which points to a FILE struct. If the FILE
   struct's buffer is full, it issues system call to the Unix kernel to
   write data to file descriptor 1, which is mapped to the terminal screen.

                       REDIRECT OUTPUT: 
   If we 
          fclose(stdout);
   which erase the FILE struct of stdout, followed by
          stdout = fopen("filenmae", "w");
   which opens filename for WRITE and let stdout point to the FILE struct,
   then printf() would send outputs to filename. More directly, we may keep
   stdout and its FILE struct but let file descriptor 1 point at a different
   file. Thus, if we
          close(1);
          open("filename", O_WRONLY|O_CREAT, 0644); 
   which change file descriptor 1 to point to a file, then the outputs will 
   go to that file instead of the screen. 
  
   When a process dies (in Kernel), it cloes all opened files, (causing
   data to be written out to disk ..

6-3 Use man open to read more on how to is
myread: read 1024 char from file descriptor 0
sue syscalls 
        open(), read(), write(), close(), 
    and (I/O library functions)
       fopen(), fclose()
              









<Title>460 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 Notes #5</H1>
<Pre>
         360 Notes on Process Management in Unix

1. Read Unix man pages on
        fork, exec, wait, exit,  
        kill, signal,  

2. Process:
   A process is a sequence of executions regarded as a single entity by the 
   Unix kernel. Each process has a unique pid and a ppid, which identify the
   process and its parent process, respectively. Processes in Unix form a 
   family tree. They compete for CPU time to run. 

3. Process Origin:
   How does a process begin? As explained before, when Unix starts, it creates
   a process P0 by brutle force. P0 creates (by fork) a child process P1, which 
   is the INIT process. P1 forks many children processes, one on each terminal 
   as the LOGIN process on that terminal. Each LOGIN process opens 3 stream FILEs, 
   stdin, stdout, stde
myread: read 1024 char from file descriptor 0
rr. It displays login: to its stdout and waits for a user to 
   login. After a user login, the LOGIN process becomes the user process. Typically, 
   the user process execute sh, so it's known as the sh process. 
   When sh sees an a.out command, it forks a child process to execute a.out. The sh 
   process "waits" until the child process dies. Then it prompts for another command.  

4. Process Image:
   In Unix, a process executes in two different modes; Kernel mode or User 
   mode, denoted by Kmode or Umode, for short. In each mode, a process has
   an "execution image", as shown by the following figure.

                  Images of Process i:
       ------------------------------------------ 
       Kmode :    Kcode_i  Kdata_i   Kstack_i
       ==========================================
       Umode :    Ucode_i  Udata_i   Ustack_i
       ------------------------------------------
   The index i indicates these are the images of process i. In general, the 
   Umode images of different processes are all d
myread: read 1024 char from file descriptor 0
ifferent. While in Kmode they 
   share the same Kcode and Kdata, which are those of the Unix Kernel. However,
   Each process still has its own Kstack.
    
   A process migrates between Kmode and Umode many many times during its life
   time.

   Every process comes into existence and begins execution in Kmode. In fact,
   it does everything of interest, including to die (or terminate), in Kmode. 
   While in Kmode, it can come to Umode easily (by changing CPU's status from 
   K to U mode) However, once in Umode it cannot change CPU's status  
   arbitrarily. A Umode process can enter Kmode in only one of 3 ways:

   (1). Interrupts : Interrupts are hardware signals to the CPU. When an
                     interrupt occurs, CPU will enter Kmode to handle the 
                     interrupt, which causes the process to enter Kmode. 
   (2). Traps: Traps are error conditions, such as invalid address, illegal 
               instruction, divide by 0, etc. recognized by the CPU, causing it
               to en
myread: read 1024 char from file descriptor 0
ter Kmode to deal with the error. Since traps are caused by
               the executing process on the CPU, the process typically dies
               (with a dreadful message such as "Segmentation Fault").

   (3). System Calls:
        System call (or syscall for short) is a mechanism that allows a process
        to enter Kmode to execute Kernel functions. When the Kernel function 
        finishes, it comes back to Umode with a return value, which is normally
        0 for success or -1 for error. In case of error, the global int 
        variable errno (in errno.h) contains an ERROR code which further 
        identifies the error.

        In the following, we shall discuss these syscalls:
           fork(), wait(), exec(), exit(), chdir(), open(), close() 

5. Process Management in Unix:

5-1. fork():  Usage:   int pid = fork();
     fork() creates a child process and returns the child's pid or -1 if error.
     The following diagram shows the actions of fork().


               PROCi                  
myread: read 1024 char from file descriptor 0
    |      PROCj
              --------                    |      -------
    Kmode :    Kcodei   kfork(){....}     |                    ( When Pj runs:)
               Kdatai        ^       |    |                          |
               kstacki       |       |    |      Kstackj             V
   ========================  |  ==== | ===========================   | =======
    Umode :    Ucodei  pid=fork(); <-     |      Ucodej  pid=fork();<-
               Udatai                     |      Udataj
               Ustacki                    |      Ustackj


   (1). The left hand side shows the images of a process Pi, which issues
        the syscall   pid=fork();    
   (2). Pi goes to Kmode to execute the corresponding kfork() function, in 
        which it creates a child process PROCj with Kstackj and Umode image of
        Pj, as shown in the right hand side of the diagram.
 
        The Umode image of Pj is an IDENTICAL copy of Pi's Umode image.

        Thus, Pj's Ucodej also has the statement
            
myread: read 1024 char from file descriptor 0
       pid=fork();

   (3). After creating Pj, Pi returns to the statement  
              pid = fork();
        in Ucodei with the child's pid = j.

   (4). When Pj begins to run, it exits Kmode and returns to the same statement
              pid = fork();
        with a 0 value in ITS OWN Umode image. 

   Example 1: Consider the C program:

        main()
        {
           int pid;
           printf("THIS IS %d  MY PARENT=%d\n", getpid(), getppid()); 

           pid = fork();   // fork syscall; parent returns child pid, 
                           //               child returns 0

           if (pid < 0){   // fork() may fail. e.g. no more PROC in Kernel
               perror("fork faild");
               exit(1);
           }
           
           if (pid){ // PARENT EXECUTES THIS PART 
                  printf("THIS IS %d  MY PARENT=%d\n", getpid(), getppid());
           } 
           else{ // child executes this part
                  printf("I am    %d  my parent=%d\n", getpid(), getppid());
    
myread: read 1024 char from file descriptor 0
       }
        }


5-2. pid = wait(int *howDidChildDie);

     wait() returns a dead child's pid and its exit code=[exit#|sig#]
            As usual, it returns -1 if error, e.g. caller has no child.

     Note:  if caller has more than one child, wait() returns ANY dead child.
               exit# is the exit(VALUE) used by child to die,
               sig#  is the (signal) number that caused the child to die.
            ONLY one of the numbers will be present, WHY?

     main()
     {
       int pid, status;
       pid = fork();
       if (pid){ // PARENT:
           printf("PARENT %d WAITS FOR CHILD %d TO DIE\n", getpid(),pid);
           pid=wait(&status);
           printf("DEAD CHILD=%d, HOW=%04x\n", pid, status);
       }
       else{// child:
           printf("child %d dies by exit(VALUE)\n", getpid());
           exit(100);  //OR {int a,b; a=b/0;} ==> see how does it die
       }
     }

5-3. Execution Order:
     After fork(), the child process competes with all other processes
     for CPU time
myread: read 1024 char from file descriptor 0
 to run. Which process will run next depends on their 
     scheduling prioirty, which changes dynamically.
 
     main()
     {
        int pid;
        pid=fork();
        if (pid){ // PARENT
           printf("PARENT %d DYING\n", getpid());
        }
        else{ // child
               printf("child %d sleeps for 2 seconds\n");
               sleep(2); // sleep for 2 seconds ==> PARENT DIES FIRST
               printf("child %d my parent=%d\n", getpid(), getppid());
        }
     }

5-4. Parent Process
     When a process dies (in Kmode), it becomes a ZOMBIE, i.e. its PROC is 
     marked as ZOMBIE and contains information, such as exit code. When the 
     parent process finds a ZOMBIE child (by wait() syscall), it collects the 
     needed information from the ZOMBIE PROC and finally lay the dead body to 
     rest, i.e. set the ZOMBIE PROC to FREE for recycle again. Thus, a process
     MUST have a parent at all times. However, because of the (independent) 
     process execution order, a process wit
myread: read 1024 char from file descriptor 0
h children may die first. Similar 
     to humman society, such children are called orphans. The natural question
     is: who should be the "parent" of such orphans? In humman society, they 
     would be sent to grandma's house. But what if gradma also died? In Unix,
     the parent of all orphans is P1. Thus, P1 wears many hats:
     It's the grand dad of ALL user processes. It's the head of an orphange, 
     and it's also the manager of a morgue (which buries DEAD bodies). 
                  
5-4. nice(VALUE); 
     Decrease caller's scheduling priority by VALUE, allowing other processes
     to run first.

6. Change Execution Image:

   A process may use exec() to change its USER mode image to another 
   (executable) file. The exec() library functions have several members:
 
     int execl( const char *path, const char *arg, ...);
     int execlp(const char *file, const char *arg, ...);
     int execle(const char *path, const char *arg , ..., char *const envp[]);
     int execv( const char *path, char 
myread: read 1024 char from file descriptor 0
*const argv[]);
     int execvp const char *file, char *const argv[]);

   All of them eventually issue the syscall

     int execve(const char *filename, char *const argv[], char *const envp[]);

   which is the basis of the C function

         main(int argc, char *argv[], char *env[])


   If successful, exec("filename",....) replaces the current Umode image with
   a new image generated from the executable filename. It's the SAME process 
   but with a new Umode image. The old Umode image is abandoned and therefore
   never returned to, unless exec() fails, e.g. filename is non-executable.

   This is similar to a person who goes to Heaven (Kernel) from where he/she
   builds a new house on Earth (Umode), burns down the old house (IRS allows 
   only one house per person?) and returns to the new house to begin a new life
   there. Naturally, the person must return to the same old house if the new
   house cannot be built.
    
Example #1 : Use execl(), which is of the form 
                     
         
myread: read 1024 char from file descriptor 0
    execl("a.out", "a.out", string1, string2, ..., 0);

----------- cc to a.out ---------------------------------
 main(int argc, char *argv[])
{
  printf("THIS IS %d IN %s\n", getpid(), argv[0]);
  execl("b.out", "b.out", "hi", 0);
  printf("SHOUDL NOT SEE THIS LINE\n");
}  

----------- cc to b.out ---------------------------------
main(int argc, char *argv[])
{
  printf("this is %d in %s\n", getpid(), argv[0]);
  while(1);
}
----------------------------------------------------------


7. Signals and Signal Handling:

(1). A signal is a number from 1 to 31, as defined in &lt;asm/signal.h&gt;

(2). Signal Sources:
     traps      : errors recognized by CPU as "traps", e.g. 
                  divide by 0, illgal instruction, invalid address, ....
     interrupts : Control_C, HangUp, ...
     pre-defined: death_of_child,...
     sent by other processes via kill()

(2). kill(pid, signal#): send signal# to pid; signal#=1 to 31.

     main()
     {
       int pid, status;
       pid=fork();
       if (pid){// PAR
myread: read 1024 char from file descriptor 0
ENT
                  kill(pid, 8);
                  pid=wait(&status);
                  printf("dead child=%d, how=%4x\n", pid, status);
                 }
       else{ // child
             while(1);  // while happily looping, child will die by sig# 8
           }
      }
============================================================================


(3). signal(sig#, ACTION); install a signal handler for sig#, 
            where ACTION = 0 ==> default action by Unix Kernel;
                           1 ==> ignore the signal (except #9)
                           &catcher() in user space.

#include &ltsignal.h&gt
#include &ltsys/time.h&gt

/**********************************************************
struct itimerval {
                struct timeval it_interval;
                struct timeval it_value;   
            };

struct timeval {
                long tv_sec;               
                long tv_usec;              
            };

int  setitimer(int which,  const  struct  itimerval  *value, struct
 
myread: read 1024 char from file descriptor 0
             itimerval *ovalue);
**************************************************************/

struct itimerval t;

int h, m, s;

void catcher(sig) int sig;
{
  printf("in catcher, sig=%d\n", sig);
}

main()
{

 t.it_interval.tv_sec = 1;    // interval=1 second
 t.it_interval.tv_usec= 0;

 t.it_value.tv_sec = 2;       // after 2 seconds 
 t.it_value.tv_usec= 0;

   signal(SIGALRM, (void *)catcher);   // install catcher for signal 14

   setitimer(ITIMER_REAL,&t,0);        // set interval timer REAL mode

 while(1);                             // sits here in a loop;

} 

<Title>360 Week 2 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes on Assembly Programming</H1>

<Pre>
   
              360 NOTES on Assembly Programming

1. Implement C functions in Assembly:

Example 1: Functions for getting CPU registers

main()
{
   int ebp, esp;
   ebp = get_ebp();
   esp = get_esp();
   printf("ebp=%8x   esp=%8x\n", ebp, esp);
}

=============================

	.global get_esp, get_ebp

get_esp:

myread: read 1024 char from file descriptor 0
         movl	%esp, %eax
         ret

get_ebp:
	movl	%ebp, %eax
	ret
=============================
EXERCISE: Write assembly functions for getting ebx, ecx, edx, esi and edi


Examples 2. A function that computes the sum of 2 integers

main()
{ 
  int a,b,c;
  a = 100; b = 200;
  c = mysum(a,b);
  printf("c=%d\n", c);
}

==========================
# int mysum(int x, int y)

        .global mysum
mysum:
# establish stack frame
        pushl	%ebp
        movl	%esp, %ebp

        movl	 8(%ebp), %eax
        addl	12(%ebp), %eax     
         
# return to main
        leave       # same as  { movl %ebp,%esp;  pop %ebp }
        ret


2. Call C functions from Assembly:

Example 3: Access global variables
 
int a, b;

main()
{
   a = 100;  b = 200;
   sub();
}

===================================

        .global sub, a, b, printf
sub:
        pushl   %ebp
        movl    %esp, %ebp

        pushl   b
        pushl   a
        pushl   $fmt
        call    printf
        addl    $12, %esp
        
        movl    %eb
myread: read 1024 char from file descriptor 0
p, %esp
        popl    %ebp
        ret

fmt:	.asciz	"a=%d  b=%d\n" 
====================================

Example 4: Assembly function format:

# entry:
          pushl  %ebp
          movl   %esp, %ebp 
----------------------------------

    # Actual code of fucntion 

----------------------------------
# exit:    leave
           ret
   <Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>
                
<Pre>
                     HOWTO cat_cp_mv

int cat_file()
{
  ask for a pathname to cat

  mycat(pathname);

}

// with open() and read(), mycat() is almost trivial
 
int mycat(pathname) char *pathname;
{
 fd = myopen(pathname, 0);  // call OUR own myopen() to open file for READ

 loop:
       read 1 BLOCK, printf() to show the chars;
       UNTIL end file

 myclose(fd);
 
 return(0);
}


NOTE: For simplicity, consider cp (or mv) of a SINGLE file only.
      However, files may have DOUBLE-INDIRECT BLOCKs !!!!

int cp_file()
{
    ask for 2 pathnames, src an
myread: read 1024 char from file descriptor 0
d dest, for cp src to dest.
    
    call mycp(src, dest) to do the actual cp
}


int mycp(char *src, char *dest)
{
   AS USUAL, NEVER cp a file to itself !!

   open src for READ   ==> fd
   creat f2 if not exists;
   open dest for WRITE ==> gd; 
   loop:
         n = read(fd, buf, nbytes);
         write(gd, buf, n);
   while (n>0)
   close fd;
   close gd;
}




int mv_file()
{
    ask for 2 pathnames src and dest for mv  src to dest

    return mymv(src, dest);
}


int mymv(char *srcf1, char *dest)
{
  Case 1: same dev:
          Listen to lecture

  Case 2: differnet dev (with mounted FS):
          mycp(src, dest);
          rm src;
}







<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Project Help #2</H1>

<Pre>

                 Simulator Data Structure Diagram

   KEEP A COPY OF THIS DIAGRAM FOR REFERENCE when designing your algorithms.


1. RunningPtr

     |
     V        |---- PointerToCWD ------|
              |                        |
2  PROC[]     |    3. OFT
myread: read 1024 char from file descriptor 0
[ ]           V 4.MINODE[]              Disk dev
 ===========  |    ===========          ============       ===================
  nextProcPtr |     mode                  INODE            |         INODE   |
  pid, ppid   |     refCount             -------           =================== 
  uid, gid    |     MinodePtr            dev,ino
  cwd --------|     offset               refCount          
                  ===========            dirty
  fd[10]                                 mounted
  ------                                 mTablePtr -----------
  ------                                 filename[]          |
  ------                                                     |
  ------                                ============         |  
 ==========                               INODE              |
                                         -------             |
                                         dev,ino             |
                                         refCount            |  
                        
myread: read 1024 char from file descriptor 0
                 dirty               |
                                         mounted             |
                                         mTablePtr           |
                                         filename[]          |
                                        ============         |
                                                             |
            PointAtRootInode                                 |
                   ^                                         V
                   |                                    PointAtMountTable[0]
                   |      5.   MuntTable[ ]
                   |  ------- 0 --------- 1 ----------
                   |  | dev          |            |
                   |--| MinodePtr    |            |
                      |............. |            |
                      | deviceName   |            |
                      | MinodePath   |            |
                      |              |            |
                      | nblocks      |            |
    
myread: read 1024 char from file descriptor 0
                  | ninodes      |            |
                      ---------------------------------  



This diagram shows the data structures of the file system simulator.

1. is a PROC pointer pointing at the PROC structure of the current running 
   process.  Each process has a Currnet Working Directory, cwd, which is
   initialized to point at the in-memory root inode.

2. is the PROC structure of processes. Everything in the simulator is performed
   by the current ruuning process.

3. is the Open File Table (OFT). Each OFT entry represents an instance of an 
   opened file. We shall discuss OFT later when dealing with Level-2.

4. is the in-memory inodes array, MINODE[100]. Each minode entry contains a 
   sub-structure INODE, which is the INODE struct on Disk.  Whenever a file
   (regular or DIR) is referenced, its inode must be brought into memory. In 
   order to ensure ONLY ONE copy of every inode in memory, a needed inode will
   be loaded into a MINODE slot. The (dev, ino) field identifies wh
myread: read 1024 char from file descriptor 0
ere the 
   inode came from (for writing it back to disk). The refCount keeps track of
   how many processes are using this minode. The dirty field tells whether the
   INODE has been modified or not. If an minode is dirty, the last user of the
   minode must write the INODE back to disk. The mounted flag says whether 
   this DIR has been mounted on or not. If mounted on, the mTablePtr points at
   the MountTable entry.

5. is the MountTable (MT). Each entry represetns a device that has been 
   mounted (on a DIR).  When a file system starts, it must mount a device on
   the Root DIR /. That device is called the root device. So the first thing
   our simulator does is also to mount-root.  As shown, MT[0] represents the
   root device. The dev field identifies which device this is. The MinodePtr
   points at the DIR that's mounted on. (in 4, the DIR also points back to the
   mounted device). Knowing the dev, we can always access the device to get 
   its Superblock, bitmaps, rootInode, etc. For convenience, 
myread: read 1024 char from file descriptor 0
some often
   used information are kept in the MountTable for quick reference, e.g. 
   nblocks, ninodes. Here is an exmple of their usage: If process wants to 
   release an inode, it calls dealloc(ino) to deallocate the inumber of the 
   inode. The caller may pass in an ino > actual number of inodes (hence 
   exceeds the range of the inodes bitmap). We can check the ino against 
   ninodes to avoid tunning the worng bits on in the bitmap. Similarly for 
   nblocks. 



<html>
<body>
<pre>

                NOTES #11 EXT2 File System on FD

Under Linux, the command  mkfs /dev/fd0 1440  makes an EXT2 file system on a 
1.44MB floppy disk. It also reports some statistics, such as block size=1024, 
184 inodes, 1440 blocks, etc. Linux's mkfs creates an EXT2 file system with a
default lost+found directory. You may use the commands  
        mount /dev/fd0 /mnt;  rm -r /mnt/*;   umount /mnt
to make the file system empty.
 
The layout of an EXT2 file system on a floppy disk is 

   |Boot|Super| Gd |Bmap|Imap|Inodes
myread: read 1024 char from file descriptor 0
 blocks .....|data blocks ..........|
      0    1    2    3     4    5  ..............| .....................|

The block contents are explained below.

Block#0: Boot Block:
  B0 is the boot block, which is not used by the file system.

Block#1: Super Block:
  B1 is the Superblock, described by the super_block structure, where only the
  essential fields are (shown and) explained. You may ignore the other fields.

struct ext2_super_block {
  unsigned long  s_inodes_count;       // total number of inodes
  unsigned long  s_blocks_count;       // total number of blocks
  unsigned long  s_r_blocks_count;     
  unsigned long  s_free_blocks_count;  // current number of free blocks
  unsigned long  s_free_inodes_count;  // current number of free inodes 
  unsigned long  s_first_data_block;   // first data block in this group
  unsigned long  s_log_block_size;     // 0 for 1KB block size
  long           s_log_frag_size;
  unsigned long  s_blocks_per_group;   // 8192 blocks per group 
  unsigned long  s_frags_per_
myread: read 1024 char from file descriptor 0
group;
  unsigned long  s_inodes_per_group;    
  unsigned long  s_mtime;
  unsigned long  s_wtime;
  unsigned short s_mnt_count;          // number of times mounted 
  short          s_max_mnt_count;      // mount limit
  unsigned short s_magic;              // 0xEF53
  // A FEW MORE non-essential fields
};

Block#2: Group Descriptor Block
EXT2 divides disk blocks into GROUPs. Each group contains 8192 (contiguous)
blocks. Each group is described by a group_desc structure of 32 bytes:

struct ext2_group_desc
{
  unsigned long  bg_block_bitmap;          // Bmap block number
  unsigned long  bg_inode_bitmap;          // Imap block number
  unsigned long  bg_inode_table;           // Inodes begin block number
  unsigned short bg_free_blocks_count;     // THESE are OBVIOUS
  unsigned short bg_free_inodes_count;
  unsigned short bg_used_dirs_count;        

  unsigned short bg_pad;                   // ignore these 
  unsigned long  bg_reserved[3];
};

A FD has only 1440 blocks. So, B2 contains only 1 group_desc s
myread: read 1024 char from file descriptor 0
tructure (The
rest are 0's).

Block#3: Block Bitmap (Bmap):
A bitmap is a sequence of bits used to represent some kind of items, e.g. disk
blocks or inode structures. Bitmaps are used to allocate/deallocate items. In a
bitmap, a 0 bit means the corresponding item is FREE, and a 1 bit means the 
corresponding item is in USE. A FD has 1440 blocks but block#0 is NOT used by
the file system. So, the Bmap has only 1439 valid bits in B3. The exact values 
of Bmap will be shown later.

Block#4: Inode Bitmap (Imap)
An inode is a data structure used to represent a file. A file system is created
with a finite number of inodes. The status of the inodes are represented by a
a bitmap, called the Imap, in B4. 
In an EXT2 FS, the first 10 inodes are reserved. Thus, the Imap of an empty FS
starts with TEN 1's, followed by 0's.

Block#5: Inodes (begin) Block
In Unix, every file is represented by a UNIQUE inode structure of 128 bytes, 
defined as follows.

struct ext2_inode {
  //***********************************************
myread: read 1024 char from file descriptor 0
**************************
  unsigned short i_mode;                      // will be explained in detail 
  unsigned short i_uid;                       // ownerID
  unsigned long  i_size;                      // file size in bytes
  unsigned long  i_atime;                     // time fields  
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;                       // groupID
  unsigned short i_links_count;               // link count
  unsigned long  i_blocks;                    // IGNORE
  unsigned long  i_flags;                     // IGNORE
  unsigned long  i_reserved1;                 // IGNORE
  unsigned long  i_block[15];                 // See details below
  //**************************************************************************

  // IGNORE THE FOLLOWING
  unsigned long  i_version;
  unsigned long  i_file_acl;
  unsigned long  i_dir_acl;
  unsigned long  i_faddr;
  unsigned char  i_frag;
  unsigned char  i_fsize;
  unsigned short i_pad1;
  unsign
myread: read 1024 char from file descriptor 0
ed long  i_reserved2[2
}

The fields i_block[15] record the disk blocks (numbers) of a file, which are 

    DIRECT blocks : i_block[0] to i_block[11], which point to direct blocks.
    INDIRECT block: I_block[12] points to a block, which contians 256 (ulong) 
                    block numbers.
    DOUBLE INDIRECT block: 
                    I_block[13] points to a block, which points to 256 blocks,
                    each of which point to 256 blocks.
    TRIPLE INDIRECT block: 
                    I_block[14] points to a block, which points to 256 blocks,
                    each of which points to 256 blocks, each of which points to
                    256 blocks.
    
The total number of inodes is always a multiple of 8 (so that every inodes 
block is full). The number of inode blocks is therefore
                    (total number of inodes)/8. 
For example, if the number of inodes is 184, then the inode blocks include 
B5, B6, B7, ...., B27.


Data Blocks:
Immediately after the inode blocks are the data
myread: read 1024 char from file descriptor 0
 blocks. In the example of 184
inodes, the first real data block is B28, which is i_block[0] of the root
directory /.


EXT2 Directory Entries:
A directory contains dir_entry sturctures. In EXT2, component file names can 
vary form 1 to 255 chars long. So the dir_entries also have varying length. 

struct ext2_dir_entry_2 {
	unsigned long  inode;        // Inode number; count from 1, NOT from 0
	unsigned short rec_len;      // This entry length in bytes
	unsigned char  name_len;     // Name length in bytes
	unsigned char  file_type;    // for future use
	char   name[EXT2_NAME_LEN];  // File name: 1-255 chars, no NULL byte
};

                  HOW TO STEP THROUGH dir_entries:

Example: Assume the root directory / contains entries 
                this  is  aVeryLongName short
Then the 0th data block (i_block[0] in its inode) of this DIR file contains:
 
|2 12 1.|2 12 2..|11 12 4this|12 12 2is|13 24 13aVeryLongName|14 952 5short   |

Each record has a rec_len and a name_len field, which will be explained later
myread: read 1024 char from file descriptor 0
.

First, read the block into a char buf[1024].
Let DIR *dp and char *cp BOTH point at buf;
Use dp-> to access the fields of the record, e.g. print the name

                    TO MOVE TO THE NEXT entry:
        cp += dp->rec_len;       // advance cp by rec_len BYTEs
        dp = (shut-up)cp;        // pull dp along to the next record

This way, you can step through ALL the record entries of a DIR file.


************************ Mailman's Algorithm by KCW *************************
Each inode is determined uniquely by its POSITION (counting from 0,1,2,...) in
the inode area. The position PLUS 1 is called the inode number (i_number or 
ino for short), which counts from 1. (A 0 i_number means no inode). In an EXT2
FS, the root inode is inode #2.
                       
                             QUESTION:
----------------------------------------------------------------------------
 Given an i_number, such as 123, how to find the inode in the inode blocks?
 i.e. which inode block?  which inode in that inode b
myread: read 1024 char from file descriptor 0
lock?
 This problem has a more general form:

                         Mailman's Algorithm:
 A city has M blocks, numbered 0,1,2,..,M-1. Each block has N houses, numbered 
 0,1,..,N-1.
 Each house has a unique BLOCK address in the form
                BA = (BLOCK, HOUSE)
 A house also has a unique LINEAR address 
                LA = 0,1,2,..,N-1, N,N+1,......

                            PROBLEM:
 Given a linear address LA, e.g. 123, determine its BLOCK address, and vice 
 versa. The solution is called the Mailman's algorithm:
 
 IF everything counts from 0,the algorithm is very simple:

                    BA = (LA / N, LA % N)
                    LA = N*BLOCK + HOUSE

 It is so simple that you may ask: What's all the fuss about?
 QUESTION: WHAT IF they do not count from 0?
============================================================================
Applications of Mailman's Algorithm:

1. Test, Set, Clear BITs in C:
   Consider  char buf[1024]; buf[] has 1024 bytes, known as buf[i], i=0,1,2,.. 
   It also 
myread: read 1024 char from file descriptor 0
has 8192 BITs numbered 0,1,2,....

   Given a bit number BIT, e.g. 1234, which byte i contains the bit, and which 
   bit j is it in that byte?
   Solution:
               i = BIT / 8
               j = BIT % 8

   To TST a bit at BIT:  if ( buf[i] & (1 << j) )

   To SET a bit at BIT:  buf[i] |=  (1 << j);
     
   To CLR a bit at BIT:  buf[i] &= ~(1 << j);
 
2. Convert i_number to inode:
   In an EXT2 FS, inodes begin in the inode_table block (block 5 for FD).
   Each inode has a unique i_number = 1,2,.....

   Given an i_number, e.g. 1234, determine which disk block# contains that
   inode, and which inode# is it in that block?

   We need to know the block# because READ/WRITE real disk is always in block,
   can't just read/write an item inside a disk block.    

   Soution:  block# = (i_number - 1)/INODES_PER_BLOCK + inode_table;
             inode# = (i_number - 1)%INODES_PER_BLOCK;

   TRY TO ANSWER FOR YOURSELF: WHY i_number-1? and WHY + inode_table
   
3. Convert disk block# to CHS = (cyl, head, sect
myread: read 1024 char from file descriptor 0
or) of a REAL disk:
   A FD has 80 cylinders, each cylinder has 2 tracks (heads), each track has
   18 sectors. A hard disk just has many MORE cylinders, heads and sectors.
 
   Given a (linear) block#, e.g. 1234, determine its (cyl, head, sector) on
   the disk. Some disk drivers takes only (cyl,head,sector) for disk I/O.
*****************************************************************************

All the struct types are defined in 
&ltlinux/ext2_fs.h&gt

==========================================================================
#include &ltstdio.h&gt
#include &ltfcntl.h&gt
#include &ltlinux/ext2_fs.h&gt

// define shorter TYPES, save typing efforts
typedef struct ext2_super_block SUPER;
typedef struct ext2_group_desc  GD;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

==============================================================================

                            EXERCISES

ASSUM
myread: read 1024 char from file descriptor 0
E: mkfs /dev/fd0 1440
Write C programs to display the specified information on the FD:
------------------------------------------------------------------------
1. super.c  : the superblock information,
2. gd.c     : the group descriptor information.
3. bmap.c   : the Bmap as a sequence of 0/1 chars (80 chars per row).
4. imap.c   : the Imap as a sequence of 0/1 chars (80 chars per row)
5. inode.c  : root inode
6. dir.c    : dir_entries of the root directory.
-------------------------------------------------------------------------

<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 NOTES #10 Linux EXT2 File System</H1>

<Pre>

The Second Extended File system (EXT2)

1. Groups

An EXT2 disk partition is divided into groups (of 8K blocks). Each group 
contains in the order: 

    Superblock 

    Group Descriptors 

    Block bitmap of the group

    Inode bitmap of the group

    Inodes of the group

    Data blocks of the group 


2. The EXT2 Superblock

  The Superblock contains 
myread: read 1024 char from file descriptor 0
information about the entire file system.
Amongst other information it contains:

Magic Number 
    This allows the mounting software to check that this is indeed the 
    Superblock for an EXT2 file system. For the current version of EXT2 this 
    is 0xEF53. 
Revision Level 
    The major and minor revision levels allow the mounting code to determine 
    whether or not this file system supports features that are only available 
    in particular revisions of the file system. There are also feature
    compatibility fields which help the mounting code to determine which new 
    features can safely be used on this file system, 
Mount Count and Maximum Mount Count 
    Together these allow the system to determine if the file system should be 
    fully checked. The mount count is incremented each time the file system is
    mounted and when it equals the maximum mount count the warning message 
    ``maximal mount count reached, running e2fsck is recommended'' is 
    displayed, 
Block Group Number 
    The 
myread: read 1024 char from file descriptor 0
Block Group number that holds this copy of the Superblock, 
Block Size 
    Block size used by the file system.
Blocks per Group 
    The number of blocks in a group. Like the block size this is fixed when 
    the file system is created, 
Free Blocks 
    The number of free blocks in the file system, 
Free Inodes 
    The number of free Inodes in the file system, 
First Inode 
    This is the inode number of the first inode in the file system. 

The detailed structure of an ext2fs superblock is [include/linux/ext2_fs.h]: 

struct ext2_super_block {
  unsigned long  s_inodes_count;
  unsigned long  s_blocks_count;
  unsigned long  s_r_blocks_count;
  unsigned long  s_free_blocks_count;
  unsigned long  s_free_inodes_count;
  unsigned long  s_first_data_block;
  unsigned long  s_log_block_size;
  long           s_log_frag_size;
  unsigned long  s_blocks_per_group;
  unsigned long  s_frags_per_group;
  unsigned long  s_inodes_per_group;
  unsigned long  s_mtime;
  unsigned long  s_wtime;
  unsigned short s_mnt_
myread: read 1024 char from file descriptor 0
count;
  short          s_max_mnt_count;
  unsigned short s_magic;
  unsigned short s_state;
  unsigned short s_errors;
  unsigned short s_pad;
  unsigned long  s_lastcheck;
  unsigned long  s_checkinterval;
  unsigned long  s_reserved[238];
};

s_inodes_count 
    the total number of inodes on the fs. 

s_blocks_count 
    the total number of blocks on the fs. 

s_r_blocks_count 
    the total number of blocks reserved for the exclusive use of the superuser.

s_free_blocks_count 
    the total number of free blocks on the fs. 

s_free_inodes_count 
    the total number of free inodes on the fs. 

s_first_data_block 
    the position on the fs of the first data block. Usually, this is block 
    number 1 for fs containing 1024 bytes blocks and is number 0 for other fs. 

s_log_block_size 
    used to compute the logical block size in bytes. The logical block size is
    in fact 1024 << s_log_block_size. 

s_log_frag_size 
    used to compute the logical fragment size. The logical fragment size is in
    fact 
myread: read 1024 char from file descriptor 0
1024 << s_log_frag_size if s_log_frag_size is positive and 1024 >> 
    -s_log_frag_size if s_log_frag_size is negative. 

s_blocks_per_group 
    the total number of blocks contained in a group. 

s_frags_per_group 
    the total number of fragments contained in a group. 

s_inodes_per_group 
    the total number of inodes contained in a group. 

s_mtime 
    the time at which the last mount of the fs was performed. 

s_wtime 
    the time at which the last write of the superblock on the fs was performed.

s_mnt_count 
    the number of time the fs has been mounted in read-write mode without 
    having been checked. 

s_max_mnt_count 
    the maximum number of time the fs may be mounted in read-write mode before
    a check must be done. 

s_magic 
    a magic number that permits the identification of the file system. It is 
    0xEF53 for a normal ext2fs and 0xEF51 for versions of prior to 0.2b. 

s_state 
    the state of the file system. It contains an or'ed value of EXT2_VALID_FS
    (0x0001) which mean
myread: read 1024 char from file descriptor 0
s: unmounted cleanly; and EXT2_ERROR_FS (0x0002) which 
    means: errors detected by the kernel code. 

s_errors 
    indicates what operation to perform when an error occurs. See section 
    Error Handling 

s_pad 
    unused. 

s_lastcheck 
    the time of the last check performed on the fs. 

s_checkinterval 
    the maximum possible time between checks on the fs. 

s_reserved 
    unused. 

Times are measured in seconds since 00:00:00 GMT, January 1, 1970. 



3. The EXT2 Group Descriptor

  Each Group is described by a data structure called the Group Descriptor.
Like the Superblock, all the group descriptors for all of the Block Groups are
duplicated in each Block Group in case of file system corruption. 

Each Group Descriptor contains the following information: 

Blocks Bitmap 
    The block number of the block allocation bitmap for this Block Group. 
    This is used during block allocation and deallocation, 
Inode Bitmap 
    The block number of the inode allocation bitmap for this Block Group. 
  
myread: read 1024 char from file descriptor 0
  This is used during inode allocation and deallocation, 
Inode Table 
    The block number of the starting block for the inode table for this Block 
    Group. Each inode is represented by the EXT2 inode data structure 
    described below. 
Free blocks count, Free Inodes count, Used directory count 

The group descriptors are placed one after another and together they make the 
group descriptor table. Each Blocks Group contains the entire table of group 
descriptors after its copy of the Superblock. Only the first copy (in Block
Group 0) is actually used by the EXT2 file system. The other copies are there,
like the copies of the Superblock, in case the main copy is corrupted. 

On disk, the group descriptors immediately follow the superblock and each 
descriptor has the following layout: 

struct ext2_group_desc
{
  unsigned long  bg_block_bitmap;
  unsigned long  bg_inode_bitmap;
  unsigned long  bg_inode_table;
  unsigned short bg_free_blocks_count;
  unsigned short bg_free_inodes_count;
  unsigned short 
myread: read 1024 char from file descriptor 0
bg_used_dirs_count;
  unsigned short bg_pad;
  unsigned long  bg_reserved[3];
};

bg_block_bitmap 
    points to the blocks bitmap block for the group. 

bg_inode_bitmap 
    points to the inodes bitmap block for the group. 

bg_inode_table 
    points to the inodes table first block. 

bg_free_blocks_count 
    number of free blocks in the group. 

bg_free_inodes_count 
    number of free inodes in the group. 

bg_used_dirs_count 
    number of inodes allocated to directories in the group. 

bg_pad 
    padding. 

The information in a group descriptor pertains only to the group it is 
actually describing. 


4. Block and Inode Bitmaps

The ext2 file system uses bitmaps to keep track of allocated blocks and inodes.
The blocks bitmap of each group refers to blocks ranging from the 0th block
to the last block in the group. The inode bitmap of each group refer to inodes
ranging from the 0th inode (inumber couts from 1) to the last inode of the
group. A 0 bit means that block/inode is FREE, and a 1 bit means it h
myread: read 1024 char from file descriptor 0
as been
allocated.


5. Inodes

   An inode is a structure that uniquely describes a file. In the EXT2 file
system, every file and directory is described by one and only one inode. 
The EXT2 inodes for each Block Group are kept in the inode table together with
a bitmap that allows the system to keep track of allocated and unallocated 
inodes. It contains the following fields: 

mode 
    This holds two pieces of information; what does this inode describe and 
    the permissions that users have to it. For EXT2, an inode can describe one
    of file, directory, symbolic link, block device, character device or FIFO. 
Owner Information 
    The user and group identifiers of the owners of this file or directory. 
    This allows the file system to correctly allow the right sort of accesses, 
Size 
    The size of the file in bytes, 
Timestamps 
    The time that the inode was created and the last time that it was modified,


The detailed inode structure is as follows.

struct ext2_inode {
  unsigned short i_mode;
myread: read 1024 char from file descriptor 0

  unsigned short i_uid;
  unsigned long  i_size;
  unsigned long  i_atime;
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;
  unsigned short i_links_count;
  unsigned long  i_blocks;
  unsigned long  i_flags;
  unsigned long  i_reserved1;
  unsigned long  i_block[EXT2_N_BLOCKS];
  unsigned long  i_version;
  unsigned long  i_file_acl;
  unsigned long  i_dir_acl;
  unsigned long  i_faddr;
  unsigned char  i_frag;
  unsigned char  i_fsize;
  unsigned short i_pad1;
  unsigned long  i_reserved2[2];
};

i_mode 
    type of file (character, block, link, etc.) and access rights on the file. 

i_uid 
    uid of the owner of the file. 

i_size 
    logical size in bytes. 

i_atime 
    last time the file was accessed. 

i_ctime 
    last time the inode information of the file was changed. 

i_mtime 
    last time the file content was modified. 

i_dtime 
    when this file was deleted. 

i_gid 
    gid of the file. 

i_links_count 
    number of links pointing to t
myread: read 1024 char from file descriptor 0
his file. 

i_blocks 
    number of blocks allocated to this file counted in 512 bytes units. 

i_flags 
    flags (see below). 

i_reserved1 
    reserved. 

i_block 
    pointers to blocks (see below). 

i_version 
    version of the file (used by NFS). 

i_file_acl 
    control access list of the file (not used yet). 

i_dir_acl 
    control access list of the directory (not used yet). 

i_faddr 
    block where the fragment of the file resides. 

i_frag 
    number of the fragment in the block. 

i_size 
    size of the fragment. 

i_pad1 
    padding. 

i_reserved2 
    reserved. 

As can be seen, an inode contains, EXT2_N_BLOCKS (15) pointers to block. 
Of theses pointers, the first EXT2_NDIR_BLOCKS (12) are direct pointers to 
data blocks. The following entry points to a block of pointers to data 
(indirect). The following entry points to a block of pointers to blocks of 
pointers to data (double indirection). The following entry points to a block 
of pointers to a block of pointers to a block of point
myread: read 1024 char from file descriptor 0
ers to data
(triple indirection).

For SPECIAL files (I/O devices such as /dev/fd0, /dev/hda1, etc.) they
do not need data block pointers. Only iblock[0] contains the device's
(major, minor) ID numbers.


The inode flags may take one or more of the following or'ed values: 

EXT2_SECRM_FL 0x0001 
    secure deletion. This usually means that when this flag is set and we 
    delete the file, random data is written in  the blocks previously allocated
    to the file. 

EXT2_UNRM_FL 0x0002 
    undelete. When this flag is set and the file is being deleted, the file 
    system code must store enough information to ensure the undeletion of the 
    file (to a certain extent). 

EXT2_COMPR_FL 0x0004 
    compress file. The content of the file is compressed, the file system code
    must use compression/decompression algorithms when accessing the data of 
    this file. 

EXT2_SYNC_FL 0x0008 
    synchronous updates. The disk representation of this file must be kept in 
    sync with it's in core representation. Asy
myread: read 1024 char from file descriptor 0
nchronous I/O on this kind of 
    file is not possible. The synchronous updates only apply to
    the inode itself and to the indirect blocks. Data blocks are always written
    asynchronously on the disk. 

Some inodes have a special meaning: 

EXT2_BAD_INO 1 
    a file containing the list of bad blocks on the file system. 

EXT2_ROOT_INO 2 
    the root directory of the file system. 

EXT2_ACL_IDX_INO 3 
    ACL inode. 

EXT2_ACL_DATA_INO 4 
    ACL inode. 

EXT2_BOOT_LOADER_INO 5 
    the file containing the boot loader. (Not used yet it seems.) 

EXT2_UNDEL_DIR_INO 6 
    the undelete directory of the system. 

EXT2_FIRST_INO 11 
    this is the first inode that does not have a special meaning. 


6. Directories

A directory is a file containing a list of entries of the following format: 

struct ext2_dir_entry_2 {
        unsigned long  inode;                  /* Inode number */
        unsigned short rec_len;                /* Directory entry length */
        unsigned char  name_len;               /*
myread: read 1024 char from file descriptor 0
 Name length */
        unsigned char  file_type;            
        char    name[EXT2_NAME_LEN];           /* File name */
};


inode 
    points to the inode of the file. 

rec_len 
    length of the entry record. 

name_len 
    length of the file name. 

name 
    name of the file. This name may have a maximum length of EXT2_NAME_LEN 
    bytes (255 bytes as of version 0.5). 

As in all Unix file systems. the first two entries in a directory are "." and
".." which represent to the current directory and the parent directory.


Whenever possible, ext2 uses the following rules to allocate new inodes and 
data blocks: 

    the inode for a new file is allocated in the same group of the inode of 
    its parent directory. 

    inodes are allocated equally between groups. 

    a new block is allocated in the same group as its inode. 

    allocate consecutive sequences of blocks. 
<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #6</H1>

<Pre>
                   CS360 NO
myread: read 1024 char from file descriptor 0
TES on FILE OPERATIONS

1. File Operations in Unix consists of 5 levels, from LOW to HIGH:
   
1.1. Hardware Level:
     This is the lowest level of file operations. It prepares the hardware 
     device, e.g. disk drive, for file systems
     Examples: fdisk : divide a hard disk into partitions.
               mkfs  : create a file system on a disk, also known as format.
               fsck  : check and repair file systems.
     Many "comercial" file system tools, such as DiskManager, DiskDoctor, etc.
     belong to this catagory.

1.2. System Call Level:
     Every Operating System provides support for BASIC file operations. 
     Unix has the following file operation functions in its kernel:

          kmount(), kumount();            (for mount/umount file systems)

          Kmkdir(), Krmdir(), Kchdir(),   (obvious)
          klink(),  kunlink(),ksymlink(), (for link/remove files) 
          Kchmod(), Kchown(), ktouch()    (change file MODE, owner, time)  

          Kcreat(), Kopen(),              (creat
myread: read 1024 char from file descriptor 0
e/open file for R,W,RW,..) 
          Kread(),  Kwrite(),             (read/write opened files) 
          Klseek();                       (change R/W byte position)
          Kclose()                        (close opened files)

          kopendir(), kreaddir(), kclosedir(), (READ directories)
          kreadlink();                    (READ symbolic link files)

          kstat(),  kfstat(), klstat(),   (get file status/information)

     The prefix K emphasizes that these are functions inside the Unix Kernel.

     
                        SYSTEM CALLS:

     Processes use System Calls (syscall for short) to access Kernel functions.
     More will be on this later.  For the time being, consider how to READ a 
     file.
     
     Assume myfile is an existing file. The following C program shows HOW TO
     READ the file (contents).

           #include    &lt;fcntl.h&gt;
           int fd, n;   char myBuffer[1024]; 
           main()
           {
              fd = open("myfile", flags, mode); where flag = 
myread: read 1024 char from file descriptor 0
O_RDONLY|O_WRONLY|O_RDWR|many others
                                                      mode = permission bits for new file

              if (fd < 0)                  fd is called a FileDescriptor.
                 exit(1);                  if fd < 0, open() call has failed.
                   
              n = read(fd, myBuffer, nbytes);  where nbytes = number of bytes you wish to read.
                                               data will be read into myBuffer[]. 
                                               n = ACTUAL # of bytes read.
              
             lseek(fd, (long)POSITION, 0);     This moves the read Pointer to POSITION bytes from 
                                               the file beginning. NOTE: It's a LONG.
 
             close(fd);                        This closes an opened file.

           }


Examples:  
          #define BLKSIZE 1024

          int fd; char buffer[BLKSIZE];

          fd = open("/dev/fd0", 0);       /* open floppy drive 0 for READ */
          lseek
myread: read 1024 char from file descriptor 0
(fd, (long)BLKSIZE, 0);    /* skip 1024 bytes ==> to BLOCK#1 */
          read(fd, buffer, BLKSIZE);      /* read one block into buffer */
          lseek(fd, (long)4*BLKSIZE, 0)   /* move to beginning of Block#4 */
          read(fd, buffer, BLKSIZE);      /* read one block into buffer */
          .........................

     The functions open(), read(), write(), lseek(), close() in a User mode 
     program are Library functions.  Each such Library function will issue a
     syscall, causing the process to switch from User mode to Kernel mode.
     Once in K mode, the process will be directed to the corresponding Kenrel
     function, e.g. open() goes to Kopen(), read() goes to Kread(), etc.  
     When the process finishes executing the Kernel function, it exits Kernel 
     and returns to User mode.

     Every syscall causes the process to enter K mode and then back to U mode.
     Switching between Umode and Kmode takes a lot of actions (and time). Data
     transfer between Kmode and Umode is espe
myread: read 1024 char from file descriptor 0
cially "expensive". Although it is
     permissible to issue
                         read(fd, buffer, 1);
     syscall to read just ONE byte, it is NOT wise to do so because that one 
     byte would come with a terrible price. Every time you have to cross the 
     boarder to enter the wonderful world of Kernel, do as much as you can 
     rather than in piece meal in order to make the journey worthwhile. In the
     case of READ/WRITE files, the best way is to match what the Kernel does. 
     The kernel reads/writes disks by BLOCK size, which ranges from 1KB to
     8KB. For instance, in Linux, the default BLOCK size is 4KB for hard disks
     and 1KB for floppy disks. 

1.3  Library I/O Functions:
    
     Syscalls allow us to read/write chunks of data, which are just a sequence
     of bytes. They do not know, nor care, about the meaning of the data. 
     However, a user (program) often needs to read/write individual chars or
     lines. If so, the user program would have to do these from/to a beffere
myread: read 1024 char from file descriptor 0
d 
     data area by itself. Most users would consider this "too much"!

     The C library provides a set of standard I/O functions for convenience, as
     well as for run-time efficiency. The library I/O functions include:

     FILE I/O      :  fopen(), fread(); fwrite(), fseek(), fclose();
                      fflush(), 
     char mode I/O :  getc(), putc(), getchar(), putchar(), ungetc()
     line mode I/O :  gets(), puts(), fgets(), fputs();

     formatted I/O :  scanf(), fscanf(), sscanf();
                      printf(), fprintf(), sprintf()

     With the exceptions of sscanf()/sprintf(), which read/write memroy 
     locations, all other library I/O functions are built on top of syscalls 
     in that they ultimately issue syscalls for "actual" data transfer through
     the Operating System Kernel.

1.4. User Commands Level:

     Instead of writing programs, users may use Unix commands to manipulate
     files. Examples of user commands are

            mkdir, rmdir, cd, pwd, ls;
            rm
myread: read 1024 char from file descriptor 0
, cat, cp, mv, chmod, .....

     Each user command is in fact an executable program (except cd), which 
     typically calls library I/O functions, which in turn issue syscalls to 
     invoke the corresponding kernel functions. Thus, the processing sequence 
     is either
            Command ==> Library I/O function ==> Syscall ==> | Kernel Function
        or
            Command ===========================> Syscall ==> | Kernel Function

1.5. sh Script Files:

     Although much more convenient than syscalls, commands must be entered
     manually, which is often tedious and time-consuming.

     sh scripts are files written in the sh programming language. The sh 
     language includes all valid Unix commands. It also includes additional 
     statements (if, do, for, while, case, etc.) to control the executions.  
     In practice, sh scripts are used extensively in Unix system programming.
     In addition to sh, many other script languages, such as Perl, are also in
     wide use. sh programming will 
myread: read 1024 char from file descriptor 0
be covered later. 


<tITLE>CS460</TITLE>

<BODY bgcolor="#00CCCC" TEXT="#000000" LINK="#990000" VLINK="#0000FF" ALINK="#3300FF"> 

<H1>CS360 CLASS NOTES</H1>
<H2>
<P>
<img src="redball.gif" alt ="*">
<A HREF="planF08.html">Course Plan : Fall, 2008</a>
<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_final_signup.html">Final Demo Signup</a>

<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_460_ta.html">TA Information</a>
<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_grade.html">Lab Grades</a>
<P>
<img src="redball.gif" alt=*">
<A HREF="ta_files/cs360_grade_exam.html">Exam Grades</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes1.html">Notes #1: Introduction to Unix</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="lab1.html">Lab Assignment #1</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes2.html">Notes #2 : Program Development</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes3.html">Notes #3 : Function Calls</a>
<P>
<img src="redball.gif" alt ="*">
<A HR
myread: read 1024 char from file descriptor 0
EF="LAB2Pre.html">Lab#2 Pre-work</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="ass.html">Notes #4 : Assembly Programming</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LAB2.html">Lab Assignment #2</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="PROC.html">Notes #5 : Process Management in Unix</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LABsh.html">Lab Assignment #3 : sh Simulator</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="fileops.html">Notes #6 : File Operations</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="syscall.html">Notes #7 : System Calls</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="libio.html">Notes #8 : Library I/O Functions</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="pre4.html">Lab #4 Pre-Work; DUE : in Lab, Sept. 24, 2008</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="IP.07.html">Notes #9 : Newtork Programming</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB4.tcp.html">LAB #4 : File Operations across Networks</a>
<P>
<img src="redball.gif" alt = "*"
myread: read 1024 char from file descriptor 0
>
<A HREF="sh.html">Notes #10 : sh programming</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="ext2fs.html">Notes #11 : EXT2 File System Info</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="ext2fd.html">Notes #12 : EXT2 FS on Floppy Disk</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB5pre.html">LAB #5 Pre-work (DUE : 10-15-08)</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="lab508.html">LAB #5 show block (DUE : 10-15-08)</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="review.html">REVIEW FOR EXAM #1</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="proj08.html">Project Specification</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="project.help.html">Project Organization</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="diagram.html">Project Data Structures</a>

<P>
<img src="redball.gif" alt = "*">
<A HREF="util.html">Project HELP: Utility functions</a>

<P>
<img src="redball.gif" alt = "*">
<A HREF="mkdir_creat.html">Project HELP: HOW TO mkdir_creat</a>
<P>
<img src="redball.gif" alt =
myread: read 1024 char from file descriptor 0
 "*">
<A HREF="stat_ls_cd_pwd.html">Project HELP: HOW TO cd_stat_ls_pwd</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="rmdir_rm.html">Project HELP: HOW TO rmdir_rm</a>
<h2>Project Level-2 Help Files</h2>
<P>
<img src="redball.gif" alt = "*">
<A HREF="open_close.html">Project HELP: HOW TO open_close files</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="read_ext2.html">Project HELP: HOW TO read</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="write_ext2.html">Project HELP: HOW TO write</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="cat_cp_mv.html">Project HELP: HOW TO cat_cp_mv</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="mount_umount.html">Project HELP: HOW TO mount_umount</a>




<TITLE>CS360 LAB ASSIGNMENT #1</Title>
<Body bgcolor="#FFFFd8" text="#000000">
<H1>CS360 LAB ASSIGNMENT #1</H1>
<Pre>
                     CS360 ASSIGNMENT #1
              DUE & DEOM: Week of Sept 1, 2008

1. OBJECTIVES
   Partition table, fdisk, structures in C, read/write special files

2 Partition Table:

A dis
myread: read 1024 char from file descriptor 0
k is usually divided into several partitions. The partitions are recorded
in a partition table in the very first sector of the disk, called the Master Boot 
Record (MBR). Each sector is 512 bytes long. Inside the MBR, the partition table 
begins at the offset 0x1BE. The Partitin Table contains 4 entries, each 16 bytes 
long as defined in the following C structure.

struct partition {
	unsigned char drive;            /* 0x80 - active */

	unsigned char head;             /* starting head */
	unsigned char sector;           /* starting sector */
	unsigned char cylinder;         /* starting cylinder */

	unsigned char sys_type;         /* partition type */

	unsigned char end_head;         /* end head */
	unsigned char end_sector;       /* end sector */
	unsigned char end_cylinder;     /* end cylinder */

	unsigned long start_sector;     /* starting sector counting from 0 */
	unsigned long nr_sectors;       /* nr of sectors in partition */
};

As can be seen, sector and cylinder are all unsiged chars (8 bits). Ho
myread: read 1024 char from file descriptor 0
wever, the
cylinder value is actually 10 bits. The highest 2 bits of cylinder value are in  
the leftmost 2 bits of sector, which is only 6 bits.
 
Each partition has a type, which indicates the kind of file system of the 
partition. Consult Linux's fdisk to see the partition types.

If a partition is EXTEND type (type==5), the partition may be further divided 
into more partitions. The extended partitions forms a link-list as the 
following diagram shows. 

Assume P4 is EXT type:
P4's beginSector = MBR
                    P5's beginSector
                    P6's MBR's sector# = MBR
                         (r.e. to P4)     P6's begin sector#
                                          P7's MBR r.e. to P4 --> etc.

Since use fdisk on any hard disk is risky, we shall use a floppy disk for this
assignment. Download the file ~cs360/samples/LAB1/floppyImage.gz to Linux. 
Uncompress and dump it to flopy disk by
                gunzip floppyImage.gz           ( unzip to floppyImage ) 
                dd if=floppyIma
myread: read 1024 char from file descriptor 0
ge  of=/dev/fd0  ( dump to a FD         )

Then, run       fdisk /dev/fd0  
                 'p' : to print the partition table
                 'q' : to quit fdisk
to see the partition table on the floppy disk. 


                      REQUIREMENTS

Write a C progrom to display the partition table of the FLOPPY disk in 
(1). RAW form, i.e. as per the partiton struct entries (%20), then 
(2). Linux fdisk 'p' output form (%40),
(3). including ALL the extend partitions (%40) <== YOU BETTER DO THIS !!!!.

Turn in a floppy disk containing your work. Also, sign up for demonstration
in SLOAN 327 on Wednesday.
==============================================================================

3. HELP INFO: UNIX System calls for reading/writing files
                   int fd = open("filename", mode);
                   lseek(fd, (long)position, 0); 
                   read(fd, buffer, nbytes);
                   write(fd, buffer, nbytes);
                   close(fd);

The following C program writes/reads floppy disk se
myread: read 1024 char from file descriptor 0
ctors

#include &ltfcntl.h&gt
char buf[512];
int sector;

main()
{
   int fd, r;
   sector = 10;                           // sector # 10 (count from 0)  

   fd = open("/dev/fd0", O_WRONLY);       // open /dev/fd0 for WRITE
   strcpy(buf, "cs360 is fun");           // create a string in buf[]
   lseek(fd, (long)sector*512, 0);        // seek to the sector 10
   r = write(fd, buf, 512);               // write 512 bytes to fd
   printf("r=%d bytes written\n", r);     // show number of bytes written
   close(fd);                             // close the file descriptor fd

   fd = open("/dev/fd0", O_RDONLY);       // open /dev/fd0 for READ
   lseek(fd, (long)sector*512, 0);        // seek to sector 10           
   r = read(fd, buf, 512);                // read 512 bytes into buf
   printf("r=%d read  buf=%s\n", r, buf); // show result
   close(fd);                             // close opened file
}

4. Sample Solution:
   ~cs360/samples/LAB1/lab1.bin






<Title>360 PROJECT HELP</Title>
<Body bgcolor="#FFFFFF
myread: read 1024 char from file descriptor 0
" text="#000000">

<H1>LAB Assignment #5</H1>

<Pre>

/ *************** DUE & DEMO : Oct. 15, 2008 ********************
 
 Write a C program, showblock, which displays the disk blocks of a file 
 in an EXT2 file system. The program runs as follows

       showblock   DEVICE    PATHNAME

e.g.   showblock  /dev/fd0   /a/b/c/d
OR     showblock  ext2Image  /x/y/z    (ext2Image is an EXT2 image file)

 It locates the file named PATHNAME and prints the disk blocks (direct, 
 indirect, double-indirect) of the file.
**************************************************************************/ 

               HOWTO Traverse EXT2 File System Tree

1. REVIEW The Mailman's Algorithm

2. Traverse the EXT2 FS tree
   Given a device (/dev/fd0), containing an ext2 FS, and a pathname, e.g. 
                   /cs360/is/fun
   of a file, find the file.

   NOTE!!! To find a file amounts to finding its INODE. 
           From the inode, you have ALL the information of a file.

  
3. ALGORITHM
  
1. Open the device for READ. 
   
myread: read 1024 char from file descriptor 0
Read in Superblock (blk #1 for FD to verify it's indeed an ext2 FS. (HOW?)

   (With the SuperBlock read in, you might as well print some of its important
    fields, e.g. nblocks, ninodes, ngroups, inodes_per_group, number of free 
    inodes and blocks, etc.
   )

2. Read in the group descriptor block (block #2 for FD) and access Group0 
   Descriptor. From its bg_inode_table entry, determine where INODEs begin on 
   the disk.  Call it the InodesBeginBlock.  

3. Read in InodeBeginBlock to get the inode of /, which is INODE #2.
   NOTE: inode number counts from 1.

4. Break up pathname into components and let the number of components be n,
   Example:
                            |<----- n = 3  ---->|
         /cs360/is/fun  ==> cs360     is      fun 

   Denote the components by name[0] name[1] name[n-1]

   YOU HAVE DONE THESE BEFORE!!!

6. Start from the root INODE in (3), search for name[0] in its data block(s).
   For DIRs, you may assume that (the number of entries is small so that) it 
   only has DI
myread: read 1024 char from file descriptor 0
RECT data blocks. Therefore, search only the direct blocks for 
   name[0].

   Each data block of a DIR inode contains DIR structures of the form 

     [ino rlen nlen .   ] [ino rlen nlen ..  ] [ino rlen nlen NAME ] ....
     [ino rlen nlen NAME] [ino rlen nlen NAME] [ino rlen nlen NAME ] ....
     
   where each NAME is a string (without terminating NULL !!!) of nlen chars. 
   You may use nlen to extract the NAME string, and rlen to advance to the 
   next DIR structure (Listen to lecture in class). 

   If name[0] exists. you can find its inode number.

7. Use the inode number, ino, to locate the corresponding INODE:
   Recall that ino counts from 1.  Use the Mailman's algorithm

               (ino - 1) / 8    and   InodeBeginBlock    
               (ino - 1) % 8 
               
   to read in the INODE of /cs360

   NOTE: the number 8 comes from : for FD, blockSize=1024 and inodeSize=128. 
         If BlockSize != 1024, you must adjust the number 8 accordingly.

   From the INODE of /cs360, you can ea
myread: read 1024 char from file descriptor 0
sily determine whether it's a DIR.
   
   (READ how to use S_ISDIR(), S_ISREG() macros by  man stat)
  
   If it's not a DIR, there can't be anything like /cs360/is ...., so give up.

   If it's a DIR and there are more components yet to search (BAD NEWS!)
   you must go on.

   The problem now becomes:
       Search for name[1] in the INODE of /cs360
   which is exactly the same as that of Step (6).

8. Since Steps 6-7 will be repeated n times, you should implement a function
 
     int search(INODE * inodePtr, char * name)
         {
            // search for name string in the data blocks of this INODE
            // if found, return name's inumber
            // else      return 0
         }


7. Then, all you have to do is call search() n times, as sketched below.

   Assume:    n,  name[0], ...., name[n-1]   are globals

   ip --> INODE of /

   for (i= 0; i &lt; n; i++){
       inumber = search(ip, name[i])  
       if (inumber == 0) : can't find name[i], BOMB OUT!
       ------------------------------
myread: read 1024 char from file descriptor 0
-------------------------
       use inumber to read in its INODE and let ip --> this INODE 
   }
  
   // if you reach here, you must have ip --> the INODE of pathname.


8. Extract information from ip --> as required.
   Pat yourself on the back and say: Good Job!

9. EXTRA CREDITS (50%):
   Make your showblock work (CORRECTLY!) for hard disk.

10. SAMPLES SOLUTION in samples/LAB5:
            showblock.bin
    Run it under Linux as
            showblock.bin /dev/XYZ pathname    where XYZ=fd0  for floppy drive,
                                               hda2 for Partition2 of HD, etc.
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#FFFFFF" text="#000000">

<H1>LAB Assignment #5</H1>

<Pre>

/ *************** DUE & DEMO : Week of Oct. 13 2008 ********************
 
 Write a C program, showblock, which displays the disk blocks of a file 
 in an EXT2 file system. The program runs as follows

       showblock   DEVICE    PATHNAME

e.g.   showblock  /dev/fd0   /a/b/c/d
OR     showblock  ext2Image  /x/y/z    
myread: read 1024 char from file descriptor 0
(ext2Image is an EXT2 image file)

 It locates the file named PATHNAME and prints the disk blocks (direct, 
 indirect, double-indirect) of the file.
**************************************************************************/ 

               HOWTO Traverse EXT2 File System Tree

1. REVIEW The Mailman's Algorithm

2. Traverse the EXT2 FS tree
   Given a device (/dev/fd0), containing an ext2 FS, and a pathname, e.g. 
                   /cs360/is/fun
   of a file, find the file.

   NOTE!!! To find a file amounts to finding its INODE. 
           From the inode, you have ALL the information of a file.

  
3. ALGORITHM
  
1. Open the device for READ. 
   Read in Superblock (blk #1 for FD to verify it's indeed an ext2 FS. (HOW?)

   (With the SuperBlock read in, you might as well print some of its important
    fields, e.g. nblocks, ninodes, ngroups, inodes_per_group, number of free 
    inodes and blocks, etc.
   )

2. Read in the group descriptor block (block #2 for FD) and access Group0 
   Descriptor. From its
myread: read 1024 char from file descriptor 0
 bg_inode_table entry, determine where INODEs begin on 
   the disk.  Call it the InodesBeginBlock.  

3. Read in InodeBeginBlock to get the inode of /, which is INODE #2.
   NOTE: inode number counts from 1.

4. Break up pathname into components and let the number of components be n,
   Example:
                            |<----- n = 3  ---->|
         /cs360/is/fun  ==> cs360     is      fun 

   Denote the components by name[0] name[1] name[n-1]

   YOU HAVE DONE THESE BEFORE!!!

6. Start from the root INODE in (3), search for name[0] in its data block(s).
   For DIRs, you may assume that (the number of entries is small so that) it 
   only has DIRECT data blocks. Therefore, search only the direct blocks for 
   name[0].

   Each data block of a DIR inode contains DIR structures of the form 

     [ino rlen nlen .   ] [ino rlen nlen ..  ] [ino rlen nlen NAME ] ....
     [ino rlen nlen NAME] [ino rlen nlen NAME] [ino rlen nlen NAME ] ....
     
   where each NAME is a string (without terminating NULL !!!) 
myread: read 1024 char from file descriptor 0
of nlen chars. 
   You may use nlen to extract the NAME string, and rlen to advance to the 
   next DIR structure (Listen to lecture in class). 

   If name[0] exists. you can find its inode number.

7. Use the inode number, ino, to locate the corresponding INODE:
   Recall that ino counts from 1.  Use the Mailman's algorithm

               (ino - 1) / 8    and   InodeBeginBlock    
               (ino - 1) % 8 
               
   to read in the INODE of /cs360

   NOTE: the number 8 comes from : for FD, blockSize=1024 and inodeSize=128. 
         If BlockSize != 1024, you must adjust the number 8 accordingly.

   From the INODE of /cs360, you can easily determine whether it's a DIR.
   
   (Remember S_ISDIR(), S_ISREG() ?)
  
   If it's not a DIR, there can't be anything like /cs360/is ...., so give up.

   If it's a DIR and there are more components yet to search (BAD NEWS!)
   you must go on.

   The problem now becomes:
       Search for name[1] in the INODE of /cs360
   which is exactly the same as that
myread: read 1024 char from file descriptor 0
 of Step (6).

8. Since Steps 6-7 will be repeated n times, you should implement a function
 
     int search(INODE * inodePtr, char * name)
         {
            // search for name string in the data blocks of this INODE
            // if found, return name's inumber
            // else      return 0
         }


7. Then, all you have to do is call search() n times, as sketched below.

   Assume:    n,  name[0], ...., name[n-1]   are globals

   ip --> INODE of /

   for (i= 0; i &lt; n; i++){
       inumber = search(ip, name[i])  
       if (inumber == 0) : can't find name[i], BOMB OUT!
       -------------------------------------------------------
       use inumber to read in its INODE and let ip --> this INODE 
   }
  
   // if you reach here, you must have ip --> the INODE of pathname.


8. Extract information from ip --> as required.
   Pat yourself on the back and say: Good Job!

9. EXTRA CREDITS (50%):
   Make your showblock work (CORRECTLY!) for hard disk.

10. SAMPLES SOLUTION in samples/LAB6:
   
myread: read 1024 char from file descriptor 0
         showblock.bin
    Run it under Linux as
            showblock.bin /dev/XYZ pathname    where XYZ=fd0  for floppy drive,
                                               hda2 for Partition2 of HD, etc.
<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #8</H1>

<Pre>
           CS 360 NOTES #8  Library I/O Functions

1. WHY Library I/O functions?

   Although system calls are the basis for read/write files, they are often
   inconvenient to use. For examples, users may wish to read/write files in 
   logical units most suited to the application, e.g. as lines, chars, etc. 

   Library I/O functions are provided for this purpose. Although not 
   absolutely essential, they provide added convenience and overall 
   efficiency.

2. What are Library I/O functions?

   Almost every OS that supports C also provides Library functions for
   file I/O.  In Unix, Library I/O functions are built on top of the 
   syscall functions. In order to illustrate their intimate relationsh
myread: read 1024 char from file descriptor 0
ip, 
   we first list a few of them:
      
    Syscall Functions:  open(),  read(),  write(), lseek(),  close();
    Library Functions; fopen(), fread(), fwrite(), fseek(), fclose();

   From their strong similrities, you can almost guess that every library 
   I/O function has its root in a corresponding syscall function. This is
   indeed the case as fopen() relies on open(), fread() makes use of read(),
   etc. The following C programs illutrate their usage.
       
        System Calls                      Library I/O Functions 
  -----------------------------------|----------------------------------------
   #include &lt;fcntl.h&gt;                |     #include &lt;stdio.h&gt;
                                     | 
   int fd, gd;                       |     FILE *fp, *gp;
   char buf[BLKSIZE];                |     char buf[BLKSIZE];
                                     |
   main()                            |     main()  
   {                                 |     {
     int n, total=0;               
myread: read 1024 char from file descriptor 0
  |        int n, total=0;
     fd = open("file1", O_RDONLY);   |        fp = fopen("file1", "r");
     if (fd < 0) exit(1);            |        if (fp == NULL) exit(1); 
     gd = open("file2", O_WRONLY);   |        gp = fopen("file2", "w");
     if (gd < 0) exit(2);            |        if (gp == NULL) exit(2);
     while (n=read(fd, buf, BLKSIZE))|        while (n=fread(buf,1,BLKSIZE,fp))
     {                               |        {
        write(gd, buf, n);           |             fwrite(buf, 1, n, gp);
        total += n;                  |             total += n;
     }                               |        }
     printf("total=%d\n:,total);     |        printf("total = %d\n", total);
                                     |
     close(fd); close(gd);           |        fclose(fp); fclose(gd);
   }                                 |    }  
   ----------------------------------------------------------------------------

    Both programs copy file1 to file2. Since you already know how syscalls
    work,
myread: read 1024 char from file descriptor 0
 we shall only discuss the program that uses Library I/O functions.

    (1). fopen() uses a string for Mode, where "r" stands for READ, "w" for 
         WRITE. It returns a pointer to a FILE structure. The FILE structure 
         contains a buffer, whose size usually matches that of BLKSIZE. In 
         addition, it also has pointers, counters and status variables for 
         manipulating the buffer.

         fopen() first allocates and initialize a FILE structure in (heap area
         of) the UserImage. It then issues an open() syscall for the file. If 
         the open() syscall succeeds, it records the returned fd in the FILE 
         structure, and returns a pointer to the FILE structure. Otherwise, it
         frees the FILE structure and returns a NULL pointer.

         It is important to note that the FILE structure, which is allocated/
         freed dynamically, is in the process' UserImage. This means that calls
         to Library I/O functions are ordinary function calls, not syscalls. 
myread: read 1024 char from file descriptor 0
 
         
    (2). The programs terminates if any of the fopen() calls has failed. As 
         mentioned above, fopen() returns a NULL pointer on failure.

    (3). Then it uses a while loop to copy the file.  Each iteration of the
         while loop tries to read BLKSIZE bytes from the source file, and 
         write n bytes to the target file, where n is the returned value from 
         fread().

         The general forms of fread() and fwrite() are

                 n = fread(buffer, size, nitems, FILEptr);
                 n = fwrite(buffer,size, nitems, FILEptr);
         
         where size is the data object size in bytes,  nitems is the number of 
         data objects to be READ or WRITTEN, and n is the actual number of 
         objects read or written. These functions are intended for R/W 
         structured data objects. For example, suppose that the buffer area 
         contains data objects of the type
                     struct OBJECT{.....}
         We may use 
                 n = 
myread: read 1024 char from file descriptor 0
fwrite(buffer, sizeof(struct OBJEC), M, FILEptr);
         to wirte M objects to a file.  Similarly,
                 n = fread(buffer, sizeof(struct OBJECT), N, FILEptr);
         reads N such objects from a file.

         The above program tries to read/write BLKSIZE bytes at a time. So, it
         has size = 1 and nitems = BLKSIZE. As a matter of fact, any comination
         of size and nitems such that size*nitems = BLKSIZE would also works. 
         However, using a size > 1 may cause problem on the last fread() 
         because the file may have fewer than size bytes left. In that case, 
         the returned n is zero but there are still bytes remaining. To deal 
         with the "tail" part of the surce file, we may add the following 
         lines of code after the while loop:
                 
                 fseek(fp, (long)total, 0);
                 n = fread(buf, 1, size, fp);
                     fwrite(buf,1, n, gp);
                 total += n;
         
         fseek() works in exac
myread: read 1024 char from file descriptor 0
tly the same way as lseek(). It positions the 
         file's R/W pointer to the byte location total. From there, we read 
         the file as 1-byte objects. This will read all the remaining bytes 
         and write them to the target file.

    (4). After the copying is done, both files are closed by calling fclose().


3. Algorithms of fread(), fwrite() and fclose()

3-1. The algorithm of fread() is as follows:

     (1). On the first call to fread(), the FILE structure's buffer is empty.
          fread() uses the saved file descriptor fd to issue a
                  n = read(fd, fbuffer, BLKSIZE);
          syscall to fill the local fbuffer. Then, it initializes fbuffer's 
          pointers, counters and status variables to indicate that there is a 
          block full of data in the local buffer.
          It then tries to satisfy the fread() call from the local buffer by 
          copying data to the program's buffer area. If the local buffer does 
          not have enough data, it issues additi
myread: read 1024 char from file descriptor 0
onal read() syscalls to fill 
          the local buffer, until the needed number of bytes is satisfied (or 
          end of file is reached). After copying data to the program's buffer 
          area, it updates the local buffer's pointers, counters, etc. getting
          ready for next fread() request.  It then returns the acutal number of
          objects read to the calling place.

     (2). On each subsequent call to fread(), it tries to satisfy the call from
          the FILE structure's local buffer. It issues a read() syscall to 
          refill the local buffer whenever the buffer becomes empty.

          Thus, fopen() accepts calls from user program on one side and issues
          read() syscalls to the Kenrel on the other. Except for the read() 
          syscalls, all processing of fread() are performed in the User Mode. 
          It enters the Kernel mode only when needed and it does so in a way 
          that matches the Kernel's behavior for best efficiency. It provides 
          aut
myread: read 1024 char from file descriptor 0
omatic buffering mechanism so that user programs do not have to 
          worry about such detailed operations.

3-2 fwrite():
 
     The algorithm of fwrite() is similar to that of fread() except for the 
     data movement direction.  Initially the FILE structure's local buffer is 
     empty. On each call to fwrite(), it writes data to the local buffer, and 
     adjust the buffer's pointers, counters and status variable to keep track 
     of the number of bytes in the buffer. If the buffer becomes full, it 
     issues a write() syscall to write the entire buffer to Kernel. 
     
3-3. USE syscalls OR Library Functions?
          
     Based on the above discussion, we can now answer the question of whether 
     to use syscalls or Libray functions to do file I/O?

     fread() relies on read() to copy data from Kernel to the local buffer,
     from which it copies data to the program's buf area. In contrast, read() 
     copies data from Kernel directly to the program's buf area.  Thus, for 
     read/
myread: read 1024 char from file descriptor 0
write data in units of BLKSIZEs, read() is inherently more efficient
     than fread() because it only needs one copying operation instead of two. 
     Therefore, in the above C programs, the one that uses syscalls is actually
     more efficient than the other that uses Library I/O functions.  However, 
     if the read/write is not in units of BLKSIZE, fread() and fwrite() may be
     far more efficient. For example, if we insists on R/W one byte at a time,
     fread() and fwrite() would be far better because they enter Kernel Mode 
     only to fill or flush the local buffer, not on every byte. Here, we have 
     implicitly assumed that entering Kernel mode is more expensive than 
     staying in User mode. This is indeed true. 

3-4. Algorithm of fclose():

     fclose() first flushes the local buffer if the file was opened for WRITE.
     Then it issues a close() syscall to close the file descriptor.  Finally 
     it frees the FILE structure and resets the FILE pointer to NULL.

3-5. Other Modes for 
myread: read 1024 char from file descriptor 0
fopen():

     The Mode parameter in fopen() may be specified as

       "r", "w", "a" : for READ, WRITE, APPEND, or with a +, which means to 
                       create the file if it does not exist.
       "r+" : for R/W, without truncating the file.
       "w+" : for R/W, but truncate the file first.
       "a+" : for R/W by appending.

     However, when a file is fopened for both R/W, there may be restrictions on
     the use of mixed fread() and fwrite() calls. The specification requires 
     that at least one fseek() or ftell() be used between every pair of fread()
     and fwrite(). 

     Example: This program yields different results when run under HP Unix and 
              Linux.

              #include &lt;stdio.h&gt;
              FILE fp; char buf[1024]; 
              main()
              { 
                  fp = fopen("t.c", "r+");   /* for both R/W */
                  fread(buf, 1, 20, fp);     /* read 20 bytes */ 
                  fwrite(buf,1, 20, fp);     /* write to the same file 
myread: read 1024 char from file descriptor 0
*/
              }


     Linux gives the right result, which modifies the bytes from 20 to 39. But
     HP Unix appends 40 bytes to the end of the original file.

     The difference stems from the non-uniform treatment of R/W pointers in the
     two systems.  Recall that fread()/fwrite() issue read()/write() syscalls
     to fill/flush the local buffer.  While read()/write() use the R/W pointer 
     in the file's OFTE, fread()/fwrite() use the local buffer's R/W pointer in
     the FILE structure.  Without a fseek() to synchronize these two pointers,
     the results depend on how are they used in the implementations. In order 
     avoid any inconsistencies, follow the man pages. For the example program, 
     the results become idnetical (and correct) if you insert a line

                  fseek(fp, (long)20, 0);

     between the fread() and fwrite().

4. Additional Library I/O functions:

4-1. Line mode I/O:
          retString = fgets(buf,nchars,fp); 
          retString = fputs(string,fp);
     Exa
myread: read 1024 char from file descriptor 0
mples:
          #include &lt;stdio.h&gt;
          FILE *fp,*gp;
          char buf[256]; char *s="this is a string";
          main()
          {
             fp = fopen("source", "r");
             gp = fopen("target", "w");
             fgets(buf, 256, fp);    /* read a line of upto 255 chars to buf */
             fputs(buf, 256, gp);    /* write string to target file */

          }
    
     When fp is stdin or stdout, fgets() and fputs() are shortened to
             gets(buf);     /* assume char buf[] is big enough */
             puts(string);  /* print string to stdout */

4-2. Char Mode I/O:
          int c;         /* NOTE the int type */       
          c = getc(fp);  /* get a char from fp, return EOF on end of file */
              ungetc(c, fp); /* push c back to stream */

          putc(c, fp);   /* put a char to fp */
     
     The reason for the int type of c is that the EOF symbol is usually an int
     value. 

   For fp = stdin or stdout,  c = getchar();  putchar(c); may be used inste
myread: read 1024 char from file descriptor 0
ad.
   For run time efficiency, getchar() and putchar() are often NOT the shortened
   versions of getc() and putc(). Instead, they may be implemented as Macros
   in order to avoid an extra function call.
   Examples:

     (1). /* file copy using getc(), putc() */
          #include &lt;stdio.h&gt;
          FILE *fp,*gp;
          main()
          {
            int c;  /* for testing EOF */
            fp=fopen("source", "r");
            gp=fopen("target", "w");
            while ( (c=getc(fp)) != EOF )
               putc(c,gp);
            fclose(fp); fclose(gp);
          }

    (2). /* Linux's man pages contain lots of 0x08 code. It is used as follows:
             0x08TT0x08HH0x08II0x08SS  high light the word THIS.
             t_0x08h_0x08a_0x08t_0x08  display the _ under that.
             However, a _ not immediately followed by 0x08 is part of the text.

             The following program eliminates the 0x08 code from the outputs 
             of man. EXPLAIN HOW DOES IT WORK ? */

             #
myread: read 1024 char from file descriptor 0
include &lt;stdio.h&gt;
             main()
             {  int c, nextc;
                while ( (c=getchar()) != EOF ){
                   if (c == 0x08){
                       c = getchar();
                       continue;
                   }
                   if (c == '_'){
                       nextc=getchar();
                       if (nextc == 0x08)
                       continue;
                       ungetc(nextc,stdin);
                   }
                   putchar(c); 
                }
             }


4-3. FORMATTED I/O:
     These are perhaps the most commonly used I/O functions.
     Foratted Inputs: ( FMT=format string )
                      scanf(FMT, &items);    /* from stdin */     
                     fscanf(fp, FMT, &items);
                     sscanf(buf,FMT, &items);  
     Formatted Outputs:     
                      printf(FMT, items);   /* to stdouot */
                     fprintf(fp, FMT, items);
                     sprintf(buf,FMT, items);
     
     Note that sscan
myread: read 1024 char from file descriptor 0
f() and sprintf() are not really I/O functions but
     string assemble/extraction funcions.
      

4-4. Other Functions:

     fseek(), ftell(), rewind()
     feof(), ferr(), fileno()

     freopen(), fdopen()
     setbuf(), setvbuf()
     popen()
   





<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 HELP #5</H1>

<Pre>
   
            360 PROJECT HELP :  HOWTO_MKDIR_CREATE

make_dir()
{
1. Ask for a pahtname, e.g. /a/b/c  or a/b/c, etc.

2.  if (pathname[0] == '/') 
        dev = root->dev;
     else
        dev = cwd->dev;
3. Let  
     parent = dirname(pathname);   parent= "/a/b"
     child  = basename(pathname);  child = "c"

4. Get the In_MEMORY minode of parent:

         ino  = getino(&dev, parent);
         pip  = iget(dev, ino); 

   Then, verify :
         parent INODE is a DIR AND
         child des NOT exists in the parent directory;
               
5. Call 
          r = mymkdir(pip, child);
 
6.  return(r);

} 


int mymkdir(MINODE *pip, char *name)
{
1. pip points
myread: read 1024 char from file descriptor 0
 at the parent minode[] of "/a/b", name is a string "c") 

2. allocate an inode and a disk block for the new directory;
       call   inumber=ialloc(dev),      bnumber=balloc(dev)
   where dev=pip->dev, i.e. SAME dev as the parent directory.

3. call mip = iget(dev,inumber) to load the inode into a minode[] (in order to
   wirte contents into the intended INODE in memory).

4. Write contents into mip->INODE, including:
        (same as the root directory in mkfs)
        INOODE.i_block[0] = bnumber; 
        all other INODE.i_block[] = 0;
        mip->dirty = 1;  /* mark dirty */

5. call  iput(mip);  
   which should write the new INODE out to disk.

  // C CODE:
  //**********************************************************************
  mip = iget(dev,inumber);

  mip->INODE.i_mode = 0x41ED;		/* DIR and permissions */
  mip->INODE.i_uid  = running->uid;	/* Owner Uid */
  mip->INODE.i_gid =  running->gid;	/* Group Id */
  mip->INODE.i_size = 1024 ;		/* Size in bytes */

  mip->INODE.i_links_count = 2;	/* Li
myread: read 1024 char from file descriptor 0
nks count */

  mip->INODE.i_atime=mip->INODE.i_ctime=mip->INODE.i_mtime = time(0L); 

  mip->INODE.i_blocks = 2;     	/* Blocks count in 512-byte blocks */
  mip->dirty = 1;               /* mark dirty */

  for (i=0; i<15; i++)
    mip->INODE.i_block[i] = 0;
  mip->INODE.i_block[0] = znumber; 

  iput(mip);
  //**********************************************************************


6. Write the . and .. entries into a buf[ ] of BLOCK_SIZE; 
   write buf[] to the disk block allocated to this directory;

// C CODE:
//****************************************************************  
  dp = (DIR *)buf;

  dp->inode = inumber;		/* Inode number */
  strncpy(dp->name, ".", 1);    /* File name */
  dp->name_len = 1;		/* Name length */
  dp->rec_len = 12;		/* Directory entry length */

  cp = buf; 
  cp += dp->rec_len;            /* advance by rec_len */
  dp = (DIR *)cp;

  dp->inode = parent->ino;      /* Inode number of parent DIR */
  dp->name_len = 2;		/* Name length */
  strncpy(dp->name, "..", 2);   /* File
myread: read 1024 char from file descriptor 0
 name */
  dp->rec_len = BLOCK_SIZE - 12;/* last DIR entry length to end of block */

  put_block(dev, bnumber, buf);


7. Finally, enter name into parent's directory 
   Read parent's data block into buf[];

     !!! LISTEN TO LECTURE CAREFULLY ON HOW TO DO THESE !!!:

// EXT2 DIR entries: Each DIR entry has rec_len and name_len.
// (1). rec_len = name_len+8 raised to the next multiple of 4 bytes.
//      So,       ideal_len = [(name_len + 8 + 3)/4] * 4
// (2). When deleting an entry, first zero out its inode number, then absorb
        its rec_len to the previous entry's rec_len ==> which effectively
        "hides" the deleted entry.

        If the deleted entry is the first in a data block, then there is no
        previous entry to absorb its rec_len. However, the entry is "deleted"
        since its inode number is zero. The idel_len of such entries is 0.

// (3). (2) ==> when entering a name into DIR, should look for an entry whose
//      rec_len - ideal_len >= new entry's ideal_len. Then, reduce thi
myread: read 1024 char from file descriptor 0
s entry's
//      rec_len to its ideal_len and enter the new entry in the remaining space

//      The new entry's rec_len = remain = this entry's (rec_len - ideal_len).
// (4). When scaning a DIR block, must check for block ending; allocate new
//      data block if needed.


(As said before, you may assume directories only have direct data blocks.)
        
8. Write parent's data block back to disk;

9. inc parent inodes's link count by 1; touch its atime and mark it DIRTY

10. iput(pip);

}  

creat_file()
{
  This is similar to mkdir() except : its inode's mode field is set to
  a REGULAR file, permission bits to (default) rw-r--r--, and no data 
  block is allocated for it.
} 


int mycreat(parent,name) MINODE *parent; char *name;
{
    Same as my_mkdir() except NO data block and do NOT inc parent's link count.
}  




<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 HELP INFO</H1>
<Pre>
   
                 HOWTO_MOUNT_UMOUNT

// ASSUME: newfs  is a file containing an EXT2 filesy
myread: read 1024 char from file descriptor 0
s image.

mount()    /*  Usage: mount filesys mount_point OR mount */
{

1. Ask for filesys (a pathname) and mount_point (a pathname also).
   If mount with no parameters: display current mounted filesystems.

2. Check whether filesys is already mounted: 
   (you may store the name of mounted filesys in the MOUNT table entry). 
   If already mounted, reject;
   else: allocate a free MOUNT table entry (whose dev == 0 means FREE).

3. open filesys for RW; use its fd number as the NEW dev;
   Check whether it's an EXT2 filesys: if not, reject.

4. find the ino, and then the minode of mount_point:
    call  ino  = get_ino(&dev, pathname);  to get ino:
    call  mip  = iget(dev, ino);           to load its inode into memory;    

5. Check mount_point is a DIR.  
   Check mount_point is NOT busy (e.g. can't be someone's CWD)

6. Record NEW dev in the MOUNT table entry;

   (For convenience, store the filsys name in the Mount table, and also
                     store its ninodes, nblocks)

7. Mark mount_point's min
myread: read 1024 char from file descriptor 0
ode as being mounted on and let it point at the
   MOUNT table entry, which points back to the mount_point minode.

8. return 0;

}
  

umount(filesys) char *filesys;
{

1. Search the MOUNT table to check filesys is indeed mounted.

2. Check whether any file is still active in the mounted filesys;
      e.g. someone's CWD or opened files are still there,
   if so, the mounted filesys is BUSY ==> cannot be umounted yet.
   HOW to check?      ANS: by checking all minode[].dev

3. Find the mount_point's inode (which should be in memory while it's mounted 
   on).  Reset it to "not mounted"; then 
         iput()   the minode.  (because it was iget()ed during mounting)

4. return(0);

}  
  

                  IMPLICATIONS of mount:

With mounting, you must modify the
 
               ino = get_ino(&dev, pathname)

function to support "cross mounting point" operations.

Assume :    mount newfs /a/b/c   ==> newfs has been mounted on /a/b/c.
 
Case 1: When traversing the pathname /a/b/c/x/y, once you reach /a/b/c,

myread: read 1024 char from file descriptor 0
        you should see that /a/b/c has been MOUNTed on (because its mounted
        flag = 1). You should

        Use the minode's mountTable pointer to locate the MOUNT table entry.
        From newfs's  dev number, you can get its / inode into memory.
        THEN, continue to look for x/y under this / inode.

Case 2: Assume that you are at the directory
               /a/b/c/x/
        and you are trversing upward. e.g.
               cd  ../../
        which will cross mount point at /a/b/c.
        THINK ABOUT HOW TO HANDLE THIS CASE. LISTEN TO LECTURE.

<TITLE>CS360 NOTES#2</Title>
<Body bgcolor="#00CCCC" text="#000000">

<H1>CS360 NOTES #1 : Introduction to Unix</H1>

<Pre>

1. The Unix File System Tree:
   The Unix file system is organized as a tree, as shown below.


            |--> bin 

            |--> dev

            |--> etc

     / ---> |--> lib

            |--> sbin
                           |--> bin
            |--> tmp       |--> include --> .h files 
                           |--> lib
myread: read 1024 char from file descriptor 0

            |--> usr ----->|--> local
                           |--> man
            |--> user      |--> X11 ------>
       
            |--> vmunix 


   Each NODE of the tree is a FILE. Unix files have the following types:

2. Unix File Types:

   (1). Directory files : 
        These are directories. A directory may contain other directories 
        and (non-directory) files.

   (2). Non-directory files : 
        Non-directory files are either REGULAR or SPECIAL files (SEE BELOW).
        Note that Non-directory files can only appear as leaf-nodes in the 
        tree.

        (2).1  REGULAR files : 
               Regular files are also called ORDINARY files. They contain 
               either ordinary text or executable binary codes.

        (2).2  SPECIAL files : 
               Special files are entries in the /dev directory. They represent
               I/O devices, and are further classified as . 

               CHAR  special files, e.g. /dev/tty0, /dev/modem.
               BLOCK special f
myread: read 1024 char from file descriptor 0
iles, e.g. /dev/fd0,  /dev/hda.
               Other types such as Network special files.

   (3). Soft LINK files:
        These are Regular files whose contents are pathnames of other 
        files. As such they are used to reference other files.
        Example: the Unix command
                 ln   -s   aVeryLongFileName   myLink
        sets up  myLink  as a soft-link to  aVeryLongFileName.  Access to 
        myLink will be re-directed to the actual file aVeryLongFileName.

3. Pathname:

   The ROOT node of a Unix file system tree, symbolized by /, is called the 
   "root directory".

   Each node of the tree is represented by a PATHNAME of the form

             /a/b/c/d    OR    a/b/c/d

   So, each Unix file is specified by a pathname.

*   A pathname is ABSOLUTE if it begins with a /.  
*   A pathname is RELATIVE if it does not begin with a /. 
 
    A relative pathname starts from the Current Working Directory (CWD).
    When a user login to Unix, the CWD is usually set to his/hers HOME 
    dire
myread: read 1024 char from file descriptor 0
ctory.  The CWD can be changed by using the cd  command.  
    The pwd command prints the absolute pathname of the CWD.
            
4. Contents of Directories Under / :  

   /bin : commonly used system commands, e.g ls, date,...
   /dev : Special files.
   /etc : Unix system maintenance files.
   /lib : Unix system libraries.
   /sbin: Unix system administration commands.
   /tmp : temporary files.
   /usr : /usr/bin:      more executable files such as  cc,  gzip.
          /usr/include : .h files
          /usr/lib:      specific library files.
          /usr/man     : on-line manual directory.
          /usr/X11     : X-Window system.

   /user: user home directories.
   /vmunix : bootable Unix system image file.


5. Login Process:

(1). User Account:
     Each user is assigned an account by the system administrator. In a stand-
     alone Unix system, user accounts are maintained in a file named     
                        /etc/passwd.
     In a network system composed of many Unix machines, such infor
myread: read 1024 char from file descriptor 0
mation is 
     usually maintained on a Server machine, which provides other Unix machines
     with a single copy of the user account information. 
 
     A user account typically contains the following fields, separated by :

     root:aXuoPkB4hz:0:0:root:/root:/bin/bash
     kwang:Pir2NYB4Bqi9I:501:100:k.c.wang,cs faculty:/home/kwang:/bin/bash
     ----- ----------------- --- ------------------- ----------- --------------
  username: password :gid:uid:    full name      : HOME dir  : programToExecute

(2). Login Process:
     
     A PROCESS is a sequence of executions regarded as a single entiry by the 
     system. In Unix, every activity is carried out by a process.  
     When Unix starts, it generates a special process, P1, which executes the 
     file   /etc/init.  For this reason, P1 is also called the INIT process. 
     It is the parent of all user processes in the following manner:

     P1 reads some system configuration files to find out the terminals 
     supported by the system.  For each t
myread: read 1024 char from file descriptor 0
erminal, it generates a child process 
     on that terminal. Then, it waits for any of the terminal process to 
     terminate.  When a terminal process terminates (by user logout), P1 
     regenerates another child process on that terminal. 

     Each child process opens 3 (stream) FILEs on its own terminal. These FILEs
     are known as 

          stdin : the terminal's Keyboard, for inputs;
          stdout: the terminal's Display, for outputs;
          stderr: also the Display, for error outputs;

     Then the child process executes /etc/getty, which displays the message  
          login:  
     on its stdout, awaiting a user to login.  
     At this moment, the login process is not yet associated with any user.

     When a user tries to login, the login process validates his/her username 
     and password in /etc/passwd. If the user has a valid account, the login 
     process takes on the user's uid and gid, thereby becoming the user's 
     process.  It then sets the CWD to the user's HOME dir
myread: read 1024 char from file descriptor 0
ectory and executes 
     the program specified in the user's account. That program is usually a 
     version of the Unix shell, e.g. bash, csh, etc.
    
     The Unix shell is a command interpreter.  It displays a prompt
         %     (OR some other symbol, which can be set by the usr)
     and waits for the user to input commands.

     A command is simply an executable program. When the user enters a command,
     the sh process (i.e. the user process that's executing the sh) will

       (1). generate a child process to perform the command;
       (2). wait for the child process to terminate;
       (3). prompt the user for commands again;  
            The sh process terminates when it sees logout or END_OF_FILE.
   
     NOTE that the command is NOT executed by sh itself but by a child process.

     Using this feature of sh, a user can start many processes, each performing
     a different task.  For example, the command (line)

            %   ls & date & a.out  &
                --   ----   ----- 
myread: read 1024 char from file descriptor 0
----- 
                C1    C2     C3   NoWait

     will start 3 children processes, C1, C2, C3, which execute ls, date, a.out
     respectively, and cause the sh to prompt again without waiting for any of
     the child processes to terminate.  This is called MULTI-TASKING.

     In this example, all 4 processes will run CONCURRENTLY (which means IN 
     PARALLEL in a logical sense). Among them, the sh runs in the FOREGROUND 
     while others run in the BACKGROUND.  Only the foreground process can 
     receive inputs from stdin.
     The  fg  command can be used to raise a background process to foreground.
     The  ps  command displays all the ProcessId (PID) of a user.


6. REVIEW QUESTIONS:

(1). The   ls -l   command lists the contents of a directory:

drwxr-xr-x   root   bin     2048  Dec 23 09:22 bin/
lrwxrwxrwx   root   root      23  Dec 20 20:15 kwang -> /home/kwang/public_html
-rw-r--r--   root   root  433387  Dec  8 21:52 vmlinuz
-rwxr-xr-x   kwang  kwang  21400  Jan 10 07{30 a.out

EXPLAIN TH
myread: read 1024 char from file descriptor 0
E MEANING OF EACH field?

(2). What are the permission bits of a file, and what do they do?
     
(3). Each user has a UserId (uid) and a GroupId (gid).  
     How does a user get hid/her uid and gid?
     What are the uid and gid used for? 

(4). The owner of a file can use the Unix command
         chmod  0766  fileName  
     to change the mode of fileName. What are the resulting permissions?

(5). What does the x bits of a directory mean?

(6). Unix has a special user, called the SuperUser or the Root, who can access
     any file. What's the reason for having such a Super user?

(7). How does a user acquire a Unix process?

(8). How many processes will be executing with the sh command?
         %  a & b & c & d &
     Which one is the foreground process?

(9). The Unix command    ls | more
     sets up 2 processes, one executes ls and the other executes more, in such 
     a way that the outputs of the first process ls are PIPEd to the second 
     process more. 
     How many processes will be executing
myread: read 1024 char from file descriptor 0
 with the sh command?
         %  a | b | c | d 
 








<TITLE>CS360 NOTES#3</Title>
<Body bgcolor="#00FFCC" text="#000000">

<H1>360 NOTES #2 : PROGRAM DEVELOPMENT</H1>

<Pre>

1. OBJECTIVES
   To understand the steps involved in program development.

2. THE STEPS:

(1). Source file : A text editor, such as vi or emacs, may be used to create
     one or more source program files in some language(s). Typical languages
     are C and Assembly.

(2). Consider C programs first. Let the source of a C program be written as
     two files, t1.c and t2.c,  as shown below:

/********  t1.c file *************************************************/
     extern int g;                      /*  IMPORT g    */
     int      sum;                      /* global variable */
     main(int argc, char *argv[ ])      /* main function */
     {
       int a,b;                         /* local variables */
       a = 1;
       b = 2;
       g = 100;                         /* reference extern variable */
       sum = mysum(a,b);  
myread: read 1024 char from file descriptor 0
              /* call mysum(), passing a,b */
       printf("sum=%d g=%d\n",sum, g);  /* call printf() */
     }
/**********************************************************************/

/*******  t2.c file **************************************************/
     int g;                             /* global variable  */
     int mysum(int x, int y)            /* function heading */
     {
        return x+y+g;                   
     }              
/*********************************************************************/

(3). To convert these source files into an executable, we typically use the 
     cc command (In Linux, cc is linked to gcc, so they are the same).

        cc  t1.c t2.c       =====> this generates an executable file  a.out

(4). WHAT'S cc or gcc?
     cc is a program, which consists of 3 major steps:
     
     1. Convert C source files to Assembly code files:
        The first step of cc is to invoke the C COMPILER, which translates
        the .c files into .s files containing ASSEMBLY co
myread: read 1024 char from file descriptor 0
de for the 
        target machine.  

     2. Convert ASSEMBLY Code to OBJECT code:
        Every machine has its own set of machine instructions. Users may 
        write programs in an ASSEMBLY language for a specific machine.

        An ASSEMBLER is a program, which translates assembly code into 
        machine code in binary form. The resulting .o files are called 
        OBJECT code. 

        The second step of cc is to invoke the ASSEMBLER to translate the
        .s files into .o files.

        Each .o file consists of 3 parts:
         
              a CODE section consisting of machine instructions;
              a DATA section consisting of all GLOBAL and static variables; 
              a SymbolTable  containing all variable and function names
                             and their attributes.

     3. LINKING: 
        A program may be composed of several pieces of .o files, which are 
        usually dependent on one another.  In addition, the .o files may call
        C library functions (
myread: read 1024 char from file descriptor 0
e.g. printf), which are NOT present.

        The last step of cc is to invoke the LINKER, which puts all the .o 
        files and the needed library functions together into a single 
        executable binary file, a.out. More specifically, the LINKER does the 
        following:

        .Combine all the code sections of the individual .o files into a
         single CODE section,

        .Combine all the data sections into a single DATA section,

        .Use the SymbolTables to resolve the cross references among the
         inidvidual .o files. 

         For instance, when the compiler sees sum = mysum(a,b), it does NOT 
         know where mysum is. So it leaves a blank in the .o file for the
         entry address of mysum. When the linker puts t1.o t2.o together, it 
         knows where mysum is since mysum is recorded in the SymbolTable
         of t2.o. So the linker can replace the blank in t1.o with the address
         of mysum. Similarly for other symbols that are cross referenced.

        
myread: read 1024 char from file descriptor 0
If everything goes well, the linker will write the resulting combined 
        file as a.out, which is the executable binary.
 
3. STATIC Vs. DYNAMIC Linking:
   There are two ways to create a.out, known as static and dynamic linking.
   In static linking, the linker includes every needed library function in 
   a.out. This makes a.out self-sufficient but usually very large.
     
   In dynamic linking, the library functions are not included in a.out but 
   calls to such functions are recorded in a.out as a directives to the LOADER.
   When a.out is to be executed, the system LOADER will load both a.out and 
   its needed libaray files into memory. 

   The main advantages of dynamic linking are:
       .The size of every a.out is reduced.
       .Once loaded into memory, the library functions can be SHARED.
      . Modifying library functions does not have to re-linking any a.out file.
 
   This kind of libraries are known as Dynamic Linking Libraries (DLLs).

4. WHAT's in a.out?
   a.out is the executable 
myread: read 1024 char from file descriptor 0
binary file, which usually has the format:
   ---------------------------------------------------------------------------
     header      : The header of a.out contains its sizes in bytes: 
                       tsize = size of Code section;
                       dsize = size of Data section;
                       bss_size=size of bss section;
                       Needed library functions (if dynamic linked).

     Code Section: this is the combined code area of a.out; it always begins
                   with the standard C startup file crt0.o, which calls main. 

     Data Section: The Data section contains INITIALIZED global and static data
                   objects. Examples of static data are static variables and 
                   format strings in printf(fmt, .....).

     bss (Block Started by Symbol) Section: un-initialized statics and globals
   ---------------------------------------------------------------------------
   NOTE that the bss section is NOT included in a.out. However, its size

myread: read 1024 char from file descriptor 0
   is recorded in the header of a.out as bss_size.

5. Execution of a.out
   The sh command
       %  a.out ONE TWO THREE 
   executes a.out with the strings ONE TWO THREE as command-line parameters.
   As explained before, sh will create a child process to execute a.out.
   
   After creation, The child process does the following

   (1). It reads the header of a.out to determine the Total memroy size needed:
             TotalSize = tsize + dsize + bss_size + stackSize
        where the stackSize is usually a default value of say, 4K bytes.

   (2). It then allocates a memory area of TotalSize bytes. Conceptually, we
        may assume that the allocated memory area is a single piece of
        contiguous memory. It then loads a.out (without the header) into this 
        memroy area, with the Code section at the Low address end. The High
        address end will be the stack area. Thus, the stack grows downward.

   (3). The main() function of  a.out  may be written as 
              main(int argc, char *a
myread: read 1024 char from file descriptor 0
rgv[ ], char *env[ ])
        As will be shown later, parameters are passed through the stack. 

   (4). It then starts to execute crt0.o, whcih calls main().
  
   (5). The execution image of a process is shown by the figure:

            LowAddress                                 HighAddress 
                      |  CODE  |  DATA | HEAP | STACK |

        where the HEAP is for dynamic memory allocations (by malloc() in C or
        new() in C++) and STACK is the run-time stack.
        Subject to a certain maximum size limit, both HEAP and STACK may be 
        expanded automatically by the Unix operating system.

   (6). Termination:
        The process that executes a.out may terminate in ONE of 4 ways:

        1. The process calls exit(bye_value), which does some clean-up work 
           (such as flush stdout, close I/O stream FILEs) and then issues an 
           _exit(value) system call, which causes the process to enter the Unix
           Kernel to die. For instance, when the process return from m
myread: read 1024 char from file descriptor 0
ain() to
           crt0.o, it calls exit(0). Alternatively, the process may call
           exit(byte_value) anywhere in a.out to terminate (without going back
           to crt0.o). 

        2. Inside a.out, the process may call _exit(value) anywhere to enter 
           Kernel to die IMMEDIATELY. Reason: if you want to die in a such a 
           hurry, why bother to clean up your room first?
           
           When a process dies, it records the byte_value in the _exit() call
           as the "cause of death" on its body, notifies its parent that it is
           dying and then becomes a ZOMBIE. The parent (either the original 
           parent or P1) will find the ZOMBIE, get its pid and "cause of death"
           value via the 
                         dead_child_pid = wait(&cause_of_death);
           system call, where cause_of_death has 2 bytes containing
                              |exitValue|signal#|
           Naturally, only one of the bytes would be non-zero, WHY?

        3. While exe
myread: read 1024 char from file descriptor 0
cuting, the process encounters an error (in YOUR a.out of
           course), which is recognized and "caught" by the CPU. The process is
           forced into the Unix kernel by a "trap". Once in kernel, it converts
           the trap error (type) into a magic number called a SIGNAL number and
           delivers the signal to itself, causing it to die. In this case, the
           ZOMBIE's "cause of death" is the signal number, and we may say that
           the process has died abnormally. 

           Examples: Try to run these C programs
                      int *p;
                      main(){   *p = 1;  }

                      int a,b,c;
                      main(){   c = a/b; }

                      main(){   main();  }

           What do you see and WHY?


        4. Killed by a signal, which may originate from hardware (interrupts)
           or sent by another process via the 
                      kill pid 
           command, which uses the kill(pid, singal#) system call.
           Examp
myread: read 1024 char from file descriptor 0
le:  If you run the C program:
                        main()
                        {
                           while(1);
                        }       
           What would happen and how do you get out the mess?





<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #3</H1>

<Pre>
            360 NOTES #3 Function Calls in C

Consider the program:

         main()
         { int a,b,c;
           a = 1; b = 2; c = 3;
           c = mysub(a,b);
           printf("c=%d\n", c); 
         }

         int mysub(int x, int y)
         {
           int u, v;
           u = 4; v = 5;
           return(x+y+u+v);
         }

The topics here are:
     ----------------------------------------------
     Function call conventions in C and stack usage.
     ----------------------------------------------

(1). When we execute a.out, a process image is created in memory, which looks 
     (logically) like the following:
   
     lowAddress                      HighAddress
          -----
myread: read 1024 char from file descriptor 0
------------------------
          | Code | Data |  stack      |
          ----------------------------- 
(2). CPU registers:

     Every CPU has:

        PC register, which points to the next instruction
                     to be executed by the CPU.
        SP register, which points to the current top of 
                     the stack. (esp register)
        FP register, which points to the stack Frame of the
                     current active function (ebp register).
        A register for return value (eax register).

(3). Our main() is called by the C startup code, crt0.o. When crt0.o calls 
     main(), it pushes the return address (its current PC contents) onto stack,
     and enters main(). When main() is entered, the stack contains:

     HighAddress      ---------->              LowAddress
  
       --------------------------------------------- 
       XXXX|PC|
       --------------------------------------------- 
            ^ 
            SP 

     with SP pointing at the returnPC (where crt0.
myread: read 1024 char from file descriptor 0
o called main().

(4). Upon entry, every C function does the following
     (4).1  push FP into stack;   this saves the FP register
     (4).2  let  FP point at the stack top, i.e. point at the saved FP.
     (4).3  shift SP downward to allocate space for local variables.
   
     For this example, there are 3 local variables, a,b,c, each 4 bytes long. 
     The stack becomes:

     HighAddress      ---------->              LowAddress
                  a  b  c 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  |
       --------------------------------------------- 
               ^         ^ 
               FP        SP 
               
(5). a=1; b=2; c=3;  The values 1,2,3 go to the locations of a,b,c, which are
     at -4, -8, -12 bytes from where FP is pointing at, respectively. 
     These are expressed as -4(FP), -8(FP), -12(FP) in assembly code.

(6). main() calls mysub() by  c = mysub(a,b);

     The compiled code for the function call consists of:

         PUSH parameter
myread: read 1024 char from file descriptor 0
s in reverse order:
              push b's value onto stack, push a's value onto stack,
         CALL mysub
              which pushes the current PC (contents) onto stack and replaces PC
              with the address of mysub, causing the CPU to enter mysub().
 
     When control just enters mysub(), the stack becomes

     HighAddress      ---------->              LowAddress
                  a  b  c 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  | 2| 1|PC|
       --------------------------------------------- 
                                  ^ 
                                  SP 

(7). mysub() is written in C.  Its actions are the same as those of main():
        push FP; 
        let FP point at the saved FP, and
        shift SP downward to allocate locals u,v. 
     Then the stack becomes
         
     HighAddress      ---------->              LowAddress
                  a  b  c               u  v 
       --------------------------------------------- 
       XXXX|
myread: read 1024 char from file descriptor 0
PC|FP|  |  |  | 2| 1|PC|FP|  |  |
       --------------------------------------------- 
                                     ^     ^ 
                                     FP    SP 
(8). While in mysub(), 
 
               -----------------------------
               WHERE ARE x,y? WHERE ARE u,v?
               -----------------------------

     For this example, the parameters a, b are at 8(FP) and 12(FP), i.e at 
     where FP points at + 8 bytes, + 12 bytes.  Local variables u, v are at 
     -4(FP) and -8(FP).

     The stack area visible to a function (parameters and locals) is called 
     a stack FRAME (like a frame of movie). Thus, FP is called the stack
     FramePointer.
 
(9). Return from called function:

     When mysub executes return(expression); it puts the value of the 
     expression in the return value register (eax for 486/Pentinum CPUs).
     Then, it deallocates the local variables by

       .copy FP into SP;   stack top now contains the saved FP.
       .pop stack into FP; this restor
myread: read 1024 char from file descriptor 0
es FP, leaving the return PC on top of 
                           the stack.
       .RET   RET pops the stack top into PC register, causing the CPU to 
              execute from the "return address" saved earlier.

(10). Upon return, the caller function copies the contents of the return value
      register into c, then it pops the parameters a,b off the stack (by adding
      8 to SP). This restores the stack to the same situation before the call.
  
      Then it continues to the next statement.





<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                HOWTO open_close_lseek

int open_file()
{
  1. ask for a pathname and mode to open:
         You may use mode = 0|1|2|3 for R|W|RW|APPEND

  2. get pathname's inumber:
         ino = getino(&dev, pathname);

  3. get its Minode pointer
         mip = iget(dev,ino);  

  4. check mip->INODE.i_mode to verify it's a REGULAR file and permission OK.
     (Optional : do NOT check FILE type so th
myread: read 1024 char from file descriptor 0
at we can open DIRs for RW)
     
     Check whether the file is ALREADY opened with INCOMPATIBLE type:
           If it's already opened for W, RW, APPEND : reject.
           (that is, only multiple R are OK)

  5. allocate an OpenFileTable (OFT) entry and fill in values:
         oftp = falloc();       // get a FREE OFT
         oftp->mode = mode;     // open mode 
         oftp->refCount = 1;
         oftp->inodeptr = mip;  // point at the file's minode[]

  6. Depending on the open mode 0|1|2|3, set the OFT's offset accordingly:

      switch(mode){
         case 0 : oftp->offset = 0; 
                  break;
         case 1 : truncate(mip);        // W : truncate file to 0 size
                  oftp->offset = 0;
                  break;
         case 2 : oftp->offset = 0;    // RW does NOT truncate file
                  break;
         case 3 : oftp->offset =  mip->INODE.i_size;  // APPEND mode
                  break;
         default: printf("invalid mode\n");
                  return(-1);
      }

myread: read 1024 char from file descriptor 0

   7. find the SMALLEST i in running PROC's fd[ ] such that fd[i] is NULL
      Let running->fd[i] point at the OFT entry

   8. update INODE's time field. 
      for W|RW|APPEND mode : mark Minode[] dirty

   9. return i as the file descriptor
}


truncate(MINODE *mip)
{
  1. release mip->INODE's data blocks;
     a file may have 12 direct blocks, 256 indirect blocks and 256*256
     double indirect data blocks. release them all.
  2. update INODE's time field

  3. set INODE's size to 0 and mark Minode[ ] dirty
}
 
      
int close_file(int fd)
{
  1. verify fd is within range.

  2. verify running->fd[fd] is pointing at a OFT entry

  3. The following code segments should be fairly obvious:
     oftp = running->fd[fd];
     running->fd[fd] = 0;
     oftp->refCount--;
     if (oftp->refCount > 0) return 0;

     // last user of this OFT entry ==> dispose of the Minode[]
     mip = oftp->inodeptr;
     iput(mip);

     fdalloc(oftp);   (optional, refCount==0 says it's FREE)
     return 0; 
}

long lseek(int
myread: read 1024 char from file descriptor 0
 fd, long position)
{
  From fd, find the OFT entry. 

  change OFT entry's offset to position but make sure NOT to over run
  either end of the file.

  return originalPosition
}

int pfd()
{
  This function displays the currently opened files as follows:

       filename  fd  mode  offset
       --------  --  ----  ------ 
       /a/b/c     1  READ   1234       
  
  to help the user know what files has been opened.
}
<Title>360 Week 1 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
	<H1>360 Course Plan</H1>
	<Pre>                CPTS 360 COURSE PLAN
                    
                    Fall, 2008

COURSE TITLE : CPTS 360 Systems Programming

Reference    : Advanced Programming in the UNIX Environment, 
               W. Richard Stevens, Addison-Wesley, 1992.
CLASS NOTES  : www.eecs.wsu.edu/~cs360/

INSTRUCTORS  : K. C. Wang, Professor of EECS, Sloan 321
                           335-3769, kwang@eecs.wsu.edu
                           Office Hours: MW 9:10-10:00 AM
               TA: To be posted
myread: read 1024 char from file descriptor 0

   
PREQUISITES  : CPTS 250
  Basic knowledge and working experience in Unix commands.
  Ability to program in C or C++.

COURSE CONTENTS:
  Introduction to the Unix Operating System: 
     Files, directories, special files, logical organization of 
     Unix file system; user account, login process and command
     execution.

  Program development
     Source files;  compiler, assembler and object files; 
     linker, library and executable files; loader and execution 
     images. Symbolic debugger and run-time support.

  Execution image of C programs
     Code, data and stack segments; function calling convention, 
     stack frames and parameter passing; long jumps.

  File I/O
     System calls and low-level file I/O; open, close, read, write, 
     lseek, file descriptors and file sharing. Execution of User 
     mode and Kernel mode images, implementation and implications 
     of system calls.

  File Control
     Permissions and access control, fcntl, chown, chmod, hard 
     and soft links, file 
myread: read 1024 char from file descriptor 0
status and statistics. 
     I/O redirection, pipes, filters and applications.

  Standard I/O Library
     Streams and high-level file I/O; user space buffering, 
     relationship with low-level I/O,  char and line mode I/O. 
     Formatted I/O.

  File system implementation
     Inodes and file representation; mkfs and physical file 
     system layout; traversal of the file system tree; booting 
     system images.

  Processes
     Concept and implementation of processes, process execution 
     environment, user mode and kernel mode images, process
     states transitions. Processes in the Unix system; init, 
     login and user processes.

  Process Control
     fork, vfork, wait, exit, kill, exec operations. traps and 
     signal handling.

  Process Synchronization and Communication
     Signals, pipes, semaphores, messages and shared memory 
     segments. Sockets.
   
  Networking
     Introduction to Internet; host, address resolution, 
     routing; protocols, client and server; ftp, rlogin, nfs
myread: read 1024 char from file descriptor 0
, 
     and nis, Socket Programming. 

  Project: Implement an ETX2 File System Simulator

  Misc Topics: sh and Perl programming, Unix system adm. 

COMPUTER SYSTEMS: (Sloan 327) 
     Pentinum based PCs running Linux.
     Other HP Unix systems and work stations for general usage.

LABORATORY: 
     Time : Wed 7:10-10 PM Place: Sloan 233
     (Firt Week: NO LAB)
---------------------------------------------------------------------
GRADING:
   Exam                      %30  (Date and form will be set later).
   Programming Assignments   %30
   Project                   %40   
---------------------------------------------------------------------

</Pre>
</Body>
<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes </H1>

<Pre>
         Lab #4 Pre-work: DUE: Sept 24, 2008 in Lab


Download the server.c andd client.c files for samples/LAB4.
Compile and test run the server and client on IP hosts.
============================================================
MODIFY the programs to do the 
myread: read 1024 char from file descriptor 0
following :
       client : send 2 numbers to server
       server : return the SUM of the 2 numbers to client
===========================================================
<Title>360 PROJECT FILE</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 PROJECT</H1>
<Pre>
                    CPTS 360 PROJECT

               Date Assigned: Oct 13, 2008

 *****************************************************************************
  1.   DUE and DEMO: Wednesday to Thursday in Close Week.
       Sign up for demo time slots. Turn in a floppy disk AND a hard copy.
  2.   May work in 2-person teams. However, a comprehensive ORAL exam will 
       be given to EACH individual during the DEMO.  The ORAL exam score 
       will be a major part of your FINAL grade.
 ****************************************************************************

                     A. OBJECTIVE:
   Design and implement a Linux EXT2 file system simulator. 

                     B. SPECIFICATIONS:
1. Files:
   Files are exactly the same as th
myread: read 1024 char from file descriptor 0
ey are in the Linux file system, i.e.
   we shall use the same EXT2 file system data structures for

      SuperBlock, GroupDescriptor, Bit-maps, Inode, Directory

   EXCEPTIONS:
      Only DIR and REG file types; no SPECIAL files.
      File size : No triple-indirect blocks.
      
   
2. Disks:
    Disks are REAL floppy disks OR "virtual disks" simulated by Linux files.  
    Disk I/O are simulated by Linux read()/write() operations on a BLKSIZE 
    basis. You may use Linux's, mkfs (mke2fs) to create EXT2 file systems.

3. File names:
   As in Unix, each file is identified by a pathname, e.g. /a/b/c or x/y/z.

   If a pathname begins with "/",  it's relative to the / directory.
   Otherwise, it's relative to the Current Working Directory (cwd) of the 
   running process (see Processes below). 

4. Processes:
   Every file operation is performed by a process. A process has a unique uid and pid.
   The simulator starts with TWO processes:
       A process P1 with uid=0 (for SUPERUSER), and
       A process P
myread: read 1024 char from file descriptor 0
2 with uid=1 (for ordinary user).
   The initial CWD of both processes are initially /
  
   P1 runs first. P2 is in a readyQueue, which contains ALL processes
   that are ready to run.

   All processes executes the same code (i.e. the Simulator), in which it

       loop forever{
            prompt for a command;
            execute the command;
       }
 
   Each command is performed by the current running process. 
   
   Process management commands are:

      switch : switch process (to run another READY process).

      fork : create a child process with the SAME uid (and its own pid).
             As in Unix, the child process shares opened files with its parent.

      kill, exit: cause process to terminate.

5. File System Commands and Operations:
   Unlike Unix (Kernel), file operations will be executed as commands.
   The required commands are listed below. LEVEL 1 is the MINIMUM requirements 
   for passing.
    
              -------  LEVEL 1 ------------ 
               mount_root;
            
myread: read 1024 char from file descriptor 0
   mkdir, rmdir, ls, cd, pwd;
               creat, rm;       
               stat, chmod, touch;

              -------  LEVEl 2 -------------
               open,  close,  read,  write
               pfd,   lseek
               cat,   cp,     mv

              -------  LEVEl 3 ------------ 
               mount, umount,             
               Process Management Commands 
               File permission checking
              -----------------------------
      
   Unless as noted below, all commands behave exactly the same as they do in 
   Unix.
 
      pfd   : Show the valid fd's of the current process.

      write : Prompt for fd and a string of chars, then write the chars 
              to the file and show the number of chars written.

      read  : Prompt for fd and n, then read the file and DISPLAY the 
              chars that are read.
============================================================================
                       SAMPLE PROGRAMS:
                       ~cs360/samples/
 
  
myread: read 1024 char from file descriptor 0
     simulator.bin: The File System Simulator for EXT2 FS. 
                        Under Linux, use  
                              mkfs /dev/fd0 1440
                        to make an EXT2 FS on a FD.

                    Then, run the simulator to see what I expect of YOUR work.
============================================================================


<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 PROJECT HELP </H1>
<Pre>
                     EECS 360 PROJECT HELP #1
    
Given: mkfs ======> make an EXT2 file system on /dev/fd0 (or a Linux file).


                     PROJECT ORGANIZATION

1. type.h (samples/type.h file)
          define constants, e.g. BLKSIZE, NPROC, NMINODE, NOFT, etc.
          define types for SUPER, INODE, DIR => same as in Linux
                
            MOUNT ==>   ---------------------------------------
                               dev       : disk identifier (fd number)
                               MinodePtr : pointer to mounted Minode

   
myread: read 1024 char from file descriptor 0
                            deviceName: pathname of mounted device  
                               MinodePath: pathname of mounted Minode
                          ---------------------------------------

            MINODE ==> In_Memory Inodes = ------
                                           INODE
                                          -------
                                          dev,ino
                                          refCount
                                          dirty
                                          mounted
                                          mountTablePtr
                                          (lock:optional)
                                           -------

            OFT   ===> OpenFileTable = --------- 
                                       mode: R|W|RW|A 
                                       refCount
                                       MinodePtr
                                       offset
                                       file's string name
myread: read 1024 char from file descriptor 0
 (optional)
                                       -------   

            PROC  ===> Process Structure = ptrs to other PROC's;
                                           pid, ppid, 
                                           uid;
                                           cwd ---> currentWorkingDir
                                           fd[NFD] = openfilePointers
                                           -------------------------- 
                
2. global.c ===> Ths file defines global variables, e.g.
                 MINODE *root;      pointer to root inode in memory.
                 PROC   *running;   pointer to current running process.
                 MINODE minode[100] in-memory inodes
                 etc

3. include.c ==> #include  "type.h"
                 #include  "global.c"
                 #include  "utility.c"
                 #include  "mountroot.c"
 
                 #include  "mkdir_creat.c"
                 #include  "cd_ls_pwd.c"
                 #include  "rmdir_rm.c"
            
myread: read 1024 char from file descriptor 0
     #include  "other_level_1.c"

                 #include  "open_close_pfd.c"
                 #include  "write.c"
                 #include  "read.c"
                 #include  "cat_cp_mv.c"

                 #include  "mount_umount.c"
                 #include  "fork_switch_exit.c"
                 #include  "check_permission.c"

4. main.c:

   #include "include.c"

   init(){ 
           initialize the simulator system's data structures:
                MOUNT  mountTable[10];
                MINODE Minode[100];
                OFT    oft[100];
                PROC   proc[10];
            
           mount the rootdevice;  e.g. default to /dev/fd0
           Run porc[0] as the current process P0  with  cwd = /;
   }

             
   main()
   {
     init(); 
     while (1){
       print the current process ID;
       prompt for a commandString; ===>  mkdir, creat, cd, ....
              get paramter strings: e.g. mkdir pathaname

       cmdIndex = findCommand(commandString); ===> return 0,1,2,....

     
myread: read 1024 char from file descriptor 0
  switch(cmdIndex){
           case 0: mkdir(pathname);         break;
           case 1: creat_file(pathanme);    break;
           .......................................
           default: print INVALID command;
       }
   }

       
5. IMPLEMENT and TEST the commands in successive steps:

6. utility.c:
   This file implements the commonly used functions that are needed
   by the commands. It is suggested that you implement the following: 

(1). get_block(dev, buf, blkno);  read block to buf;
     put_block(dev, buf, blkno);  write block from buf


(2). Alocate/Deallocate functions:

     ialloc()/ idealloc() ===> allocate/deallocate an inode
     balloc()/ bdealloc() ===> allocate/deallocate a  file block;
     
     mialloc()/midealloc() ==> allocate an in memory inode 
     falloc()/fdealloc()   ==> allocate OFTE entry.

(3). ulong search(INODE *ip, char *name)
     search a DIR inode (data blocks) for name; 
     return ino if found, return 0 if not 

(4). THE MOST FUNDAMENTAL FUNCTION IS:

         
myread: read 1024 char from file descriptor 0
ino = getino(&dev, char *pathname);

     which returns the ino of pathname.  The beginning dev is either / or
     the running proc's CWD, as in
                if (pathname[0] == '/')
                   dev = root->dev;
                else
                   dev = cwd->dev;
    However, while traversing the pathname, dev may change to that of a 
    mounted device.  So bring in &dev to keep track of the changes. 
    Alternatively, you may write ino = getino(char *pathname) and use a 
    global variable dev to record the CURRENT device number. 

    Upon return from getino(), we have (dev, ino) of the file.

    THIS IS SIMILAR TO YOUR showblock.c


(5). MINODE *iget(dev, ino) ==>   Return ptr to in-memory inode=(dev,ino);
                                  load the inode into a minode[] if necessary.
             iput(minodePtr); ==> Release the inode;  WRITE BACK TO DISK
                                                      IF refCount=0 and dirty.

(6). Others as needed:

     Given ip->inode in memory,
myread: read 1024 char from file descriptor 0
 find its parent's ino;

     Given a parent ip->inode in memory, and a child stringName,
           search for the childName.
           search for an unused directory entry.



              HOW TO GENERATE THE simulator EXECUTABLE

                       METHOD 1:

As shown above, main.c includes ALL the needed .c files. So
         cc -o simulator main.c
would generate the simulator executable. In this approach, the .h file
can only be included ONCE. 


                    METHOD 2: Use make
The is the preferred method of managing a LARGE set of C programs.
To use the make facility, you need to create a Makefile (or makefile) containing
instructions for make to follow.  make reads the Makefile, compiles the .c 
files (as needed) and link the .o files into an executable.

NOTE: in this approach, each .c file must include the .h file and use
      extern to declare any needed (global) variables.
 
To learn more about makefile contents, read Linux's /usr/info/make.info-1, etc.
Here, we show a makefile for th
myread: read 1024 char from file descriptor 0
e project.

#            # starts a comment line, which is ignored by make

# ***************************************************************************
#                    Example Makefile
#            Save these as Makfile or makefile Then run  make
# ***************************************************************************

# Variable H defines the head file (string)

H = type.h

# Variable OBJ defines the string containing .o file names
# NOTE: this is ONE line, but splitted into several lines for easier to read

OBJS = global.o alloc_dalloc.o util.o mount_umount.o mkdir_creat.o \
       stat.o cd_ls_pwd.o rmdir_rm.o open_close.o read.o write.o \
       cp_mv.o cs_fork.o main.o

# simulator:  is a rule, which says simulator DEPENDS on $(OBJ), the (string)
# value of the OBJ variable
    
simulator : $(OBJS)

# This rule tell make how to generate simulator: by    cc $(OBJ s.s
# NOTE !!! Each ACTION rule must begin with a TAB char, NOT a bunch of spaces.

	cc  -o simulator $(OBJS) s.s


# These tell mak
myread: read 1024 char from file descriptor 0
e how to generate each .o file from a corresponding .c file.
# Each .o file DEPENDs on $(H), whcih means: The .o file will be generated 
# again if $(H) are changed. This certainly makes sense since each .c file
# depends on the TYPEs in type.h.

global.o : $(H)

alloc_dalloc.o : $(H)

util.o :  $(H)

mount_umount.o :  $(H)

mkdir_creat.o : $(H)

stat.o : $(H)

cd_ls_pwd.o : $(H)

rmdir_rm.o : $(H)

open_close.o : $(H)

read.o : $(H)

write.o : $(H)

cp_mv.o : $(H)

cs_fork.o : $(H)

main.o : $(H)


# make clean  ==>  remove the executable and all the .o files
clean :
	rm simulator *.o



<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                      HOWTO read

int read_file()
{
  Preparations:
   ask for a fd  and  nbytes to read
   verify that fd is indeed opened for READ or RW

   return(myread(fd, buf, nbytes));
}
 

// myread() behaves exactly the same as Unix's read(fd, buf, nbytes) syscall
// it tries to read nbytes from fd to buf[ ], an
myread: read 1024 char from file descriptor 0
d returns the actual number of
// bytes read.

int myread(int fd, char *buf, int nbytes)
{
 1. size = fileSize - OFT's offset //number of bytes remain in file.

 2. while (nbytes > 0 && size > 0){
     compute LOGICAL BLOCK lbk and startByte in that block from offset;
           lbk       = oftp->offset / BLOCK_SIZE;
           startByte = oftp->offset % BLOCK_SIZE;
     
     // I only show how to read DIRECT BLOCKS. YOU do INDIRECT and D_INDIRECT
 
     if (lbk < 12){              // direct block
        blk = mip->INODE.i_block[lbk];
     }
     else if (lbk >= 12 && lbk < 256 + 12) { 
          //  indirect blocks 
     }
     else{ 
          //  double indirect blocks
     } 

     /* get the data block into readbuf[] */
     get_block(mip->dev, blk, readbuf);

     /* copy from startByte to buf[], at most remain bytes in this block */
     char *cp = readbuf + startByte;   
     remain = BLOCK_SIZE - startByte;  // number of bytes remain in readbuf[]

     while (remain > 0){
            *cq++ = *cp++;
myread: read 1024 char from file descriptor 0
             // cq points at buf[ ]       
             oftp->offset++; 
             count++;                  // count=0 for counting
             size--; nbytes--;  remain--;
             if (nbytes <= 0 || size <= 0) 
                 break;
     }
 
     // if one data block is not enough, loop back to OUTER while for more ...

 }

 show ("myread : read %d char from file %d\n", count, fd);  

 return count;    // count is a actual number of bytes read
}
<html>
<body>
<pre>

                 360 Review Questions

1. What happens when you login to Unix?

2. Write C statements for a struct containing
         ---------------------------------------    
         NEXT  : a pointer to the SAME struct
         ID    : an integer                         
         NAME  : an array of 256 chars              
         ---------------------------------------    
   Write C statements to print the contents of a list.

3. What's cc? (Steps and what does each step do)
   Dynamic Vs. static linking?

4. Given a C progra
myread: read 1024 char from file descriptor 0
m,

        int g;
        int h = 1;

        main(int argc, char *argv[])      int A(        )
        {                                 {                            
           int a,b,c;                        int u,v;
           a = 2; 
           b = 3;                            HERE:       
           c = A(a,b,"hello");      
        }                                 }  

   (0). Complete the function heading of A(....)
   (1). Which variables are global? local?   
   (2). Which variables are in a.out?
   (3). In the run-time memory of a.out, where are the variables?

   (4). Execution is at HERE:  Show the stack contents from HERE to main()'s 
                               argc and argv.

5. A simple function in assembly:
            .global sub
   sub:

   ENTRY:   pushl   %ebp
            movl    %esp, %ebp
   
   BODY:
            movl    $1234, %eax
            movl     1234, %eax            

   EXIT:
            movl    %ebp, %esp
            popl    %ebp
            ret

   (0). What's purpo
myread: read 1024 char from file descriptor 0
se of .global sub ?
   (1). What's the purpose of the statements at ENTRY?
   (2). What's the difference between the 2 statements in BODY?
   (3). What does the EXIT part do?

6. int pid, dead, how;

   pid = fork();              What does it do?

   if (pid){ // do this }     which process does this?
   else{     // do that }     which process does that?

   dead = wait(&how);         IF CALLED BY THE ABOVE 2 processes, dead=? how=?

7. What does  int   r = execve("a.out", argv, env);    do?
   How does the system find a.out?
   Draw a diagram to show exactly what's argv?
   What's the value of r? (It can only have ONE possible value !!!)

8. a.out is the binary executable of the C program
     main(int argc, char *argv[], char *env[])
     {
       execve(argv[0], argv, env);
     }
   What would happen?
   HOW TO GET OUT THE MESS?

9. When run  a.out > outfile, how does sh do the I/O re-direction?

10. You can use the Unix command  mkdir /a/b/c  to make a directory.
    Write a C statement for the mkdir co
myread: read 1024 char from file descriptor 0
mmand.
    
11. open,  read,  write are system calls
   fopen, fread, fwrite are library I/O functions.

   What's their RELATIONSHIP? 
   WHY do wee need lib I/O functions?

   Write C code to
     open a file for READ; read the SECOND block of 1024 bytes into a buf[]
     open a file for WRITE (CREAT if needed); write a string of chars to it.

12. stat():
    What does it do?
    HOW TO determine a files's type, e.g. REG or DIR?
    HOW TO get the file size, creation time?
    How to print creation time in calendar form?
    How to tell whether 2 pathnames are really the SAME file?

13. HOW TO use opendir(), readdir()?

14. Network Programming using TCP
    What's IP? what's TCP? HOW DOES TCP achieve reliable data transfer?
    What's an IP address, a Port Number?
    Network (bytes) order Vs. host order?
    Compare a socket (number) with a file descriptor?

    In a TCP Server-Client model, to establish a "virtual" connection,

       What should the Server do?   |    What should the Client do? 
         
myread: read 1024 char from file descriptor 0
   
          (After Server accepted a Client connection)                      
       How does the Server know where is the Client?
            HOW DO THEY communicate with each other?

    HOW TO let the Server deal with multiple Clients?

15. mkfs:
    What's a bit map?
    Assume : char buf[1204], block 4 of a FD contains a bit map for inodes.
             INODE my_inode is an INODE struct.

    Write C code for the following:
   (1). read disk block 4 into buf[].
   (2). serach for a FREE inode (number) in the bit map, change it to BUSY
        and return the inode number.
   (3). copy the inode on disk to my_inode.


16. showblock:

    ASSUME: char buf[1024] contains a data block of a directory, such as that of /
    Write C code to 
      (1). search for a name string "abcde" in that data block.
      (2). while searching, print the names of the DIR entries in that block.









<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP : HOWTO rmdir_rm</H1>

<Pre>
myread: read 1024 char from file descriptor 0


int rmdir()
{
  1. ask for a pathname to rmdir
  2. get its inumber :  
         ino = getino(&dev, pathname) 
  3. get a pointer to its Minode[] :   
         mip = iget(dev, ino);

  4. check DIR type */
       if NOT : iput(mip); retunr -1;
 
  5. check ownership 
       super user : OK
       not super user: uid must match

  5. check for BUSY or mounted on ?
       test refCount and mounted flag

  6. check whether it's empty
     First, check link count (inks_count > 2 means not empty);
     However, links_count == 2 may still have FILEs, so go through its data 
     block(s) to see whether it has any entries in addition to . and ..

  7. Assume empty:
       get parent DIR's ino and Minode (pointed by pip);
       remove child's entry from parent directory:

       rm_child(pip, me, child);   pip->parent Minode, me=my_inumber
                                   child = nameString to remove

  8. deallocate its block and inode
     for (i=0; i<12; i++){
         if (mip->INODE.i_block[i]==0)
          
myread: read 1024 char from file descriptor 0
   continue;
         bdalloc(mip->dev, mip->INODE.i_block[i]);
     }
     idalloc(mip->dev, mip->ino);
     mip->refCount = 0;

     decrement pip's link_count by 1; 
     touch pip's atime, mtime fields;
     mark pip dirty;
     iput(pip);
     return(0);
}


int rm(pathname) char *pathname;
{
   1. get its ino and inode */
          ino = getino(&dev, temp);

   2. get its Minode pointer
          mip = iget(dev, ino);

   3. check busy:
          check refCount

   4. check FILE type */

   5. check ownership

   6. get parent's ino and Minode pointer
          pino = getino(&dev, parent);
          pip  = iget(dev, pino);

   7. remove name from parent directory */
          rm_child(pip, ino, child);

   8 deallocate direct and indirect data blocks */
     for (i=0; i<12; i++){
        if (mip->INODE.i_block[i]) 
            bdalloc(mip->dev, mip->INODE.i_block[i]);
      }
    
     deallocate indirect data blocks AND the indirect blocks themselves 
     NOTE: you MUST allow files to have DOUBLE indi
myread: read 1024 char from file descriptor 0
rect blocks

   9. deallocate its inode :
         idalloc(mip->dev, mip->ino);
   
   10. mip->refCount = 0;

   11. dispose of parent's Minode
       touch pip; mark pip dirty;
       iput(pip);
   
   return(0);
}



// rm_child() is common to both rmdir and rm. It remove an entry [me, child]
   from the parent's data block. WATCH the clever tricks used here.

int rm_child(parent, me, child)
    MINODE *parent; unsigned long me; char *child;
{
   1. Search parent INODE's data block(s) for an entry eqaul to me
   2. Erase my name from parent directory:
       if first entry in block ==> set my ino to 0;   
       if NOT first entry in block ==> absorb my rec_len to the previous entry;
          (this effectively makes my_entry disappear;
           no need to change parent's fileSize)
   3. Write the parent's data block back to disk
}




<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 NOTES #10 Sh Programming</H1>

<Pre>
1. sh scripts:
   A sh script is a text file containin
myread: read 1024 char from file descriptor 0
g sh statements for sh to execute.
   Example: Text edit a file, mysh,  containing
            -----------------------------------
            #! /bin/bash
            # comment line
            echo hello
            -----------------------------------
   Use chmod +x mysh to make it executable. Then run mysh. It will print hello.

2. Command-line parameters:
   Similar to running C programs, sh scripts can be invoked with parameters, 
   as in      mysh one two three

   $# = the number of such parameters, which are known as $1 to $9. $0 is the
        program name itself.
   $* = ALL command-line parameter (strings) $1 $2 ....
   
   Example:
            ------------------
            echo $#
            echo $1 $2
            echo $*
           -----------------
   mysh                      ====> print  0 
                 
   mysh one two three        ====> print  3
                                           one two
                                           one two three
2. sh Statements

2-1. sh statem
myread: read 1024 char from file descriptor 0
ents include all Unix commands, with I/O re-directions.
     Examples:    ls           ; ls > outfile 
                  date         
                  cp f1 f2
                  mkdir new
                  cat filename

2-2. Simple sh (built-in) statements
     echo This is a line              # display This is a line
     echo "This is     a   line"      # display This is    a   line
     echo -n hi                       # display hi without NEWLINE  
     echo    there                    # display hithere
     
     shift, eval (will be explained later).

2-3. Command Substitution:
     When sh sees $(cmd), it executes cmd first, and SUSTITUTEs $(cmd)
     with the RESULT (string) of the execution.

     echo $(date)       ==> display current date string
     echo $(ls)         ==> display the result of ls command 


3. Sh Variables:
   Sh has many built-in variables, e.g. PATH, HOME.
   You may use any symbol as sh variable. No declaration is necessary.
   sh variable values are STRINGs !!! If A is a var
myread: read 1024 char from file descriptor 0
iable, $A is its value.
   Examples
      echo A   ==>  A
      echo $A  ==>        (null string if A is not set)
      A="this is fun"     # set A value
      echo $A  ==> this is fun
      B=A
      echo $B   ==> A     (B was assigned the string "A")
      B=$A                (B takes the VALUE of A)
      echo $B   ==> this is fun

      echo -n "enter yes or no "
      read ANS            # sh reads an input line from stdin; try read A1 A2 with "one two three"
      echo $ANS

      local X             # X is local to this sh; not available in child sh
      export Y            # variable Y will be passed to child sh process

4. Quotes:
   Sh has many special chars, such as $, /, *, >, <, etc.  
   To use these as ordinary chars, use \ to quote them, as in
         echo \$A     ==> $A
     OR  echo '$A'    ==> $A    (NO substitution within SINGLE quotes)

         echo " this is $A"     (DOUBLE quotes will substitute $A !!!)

5. sh statements
5-1. if-else-fi statement
     if [ condition ]
       then
   
myread: read 1024 char from file descriptor 0
       statements
       else                # as usual, the else part is optional
          statements
     fi

Example:
echo ------------------------------
echo This sh script copies f1 to f2
echo "     then removes f2"        # Use double-quotes " " to include spaces
echo ------------------------------

# $# is the number of command line parameters, which are known as 
# $1,$2,$3,...., $9    As usual, $0 is the name of the execcutable itself.
# Here, $# must be 2. If not show Usage and exit

# By default, all values in sh are strings, so they can be compared by
#  if [ s1 = s2 ];  if [ s1 != s2 ];   if [ s1 \< s2 ]; if [ s1 \> s2 ]; etc.
# Note the spaces between the tokens

# In contrast, the operators -eq, -ne, -lt, -gt compare them as (integer)
# NUMBERS, thus
#  if [ "123" = "0123" ]  is false (since they differ as strings)
#  if [ "123" -eq "0123" ] is true. Since everything is string, you may use
#  if [ 123 -eq 0123 ] OR  if ["123" -eq 0123 ]

# Here we compare them as STRINGs; 
if [ $# != 2 ] 
then
myread: read 1024 char from file descriptor 0

     echo Usage: copy file1 file2
     exit 1
fi

# $1 is the first parameter string, $2 the second, etc.

echo You are copying $1 to $2 
echo in the directory $(pwd)     # COMMAND SUBSTITUTION

echo copying $1 to $2 ....
     cp  $1  $2                 # this is the actual copy operation
echo done

echo show $2 has been created ....
  ls -l $2
echo now try to remove $2

# if $2 exists as a file:
if [ -e $2 ]  
 then 
   echo removing $2 .....
   rm $2
fi
echo
echo all done
echo Let\'s go on .....      # QUOTE the special char ' by \ 

# ***************** DO THESE:  ****************************
# In sh, the following tests can be used:
# if [ -e name ]      test whether file name exists
# if [ -f name ]      test whether name is a (REG) file
# if [ -d name ]      test whether name is a DIR
# if [ -r name ]      test whether name is readable; also -w,-x
# if [ f1 -ef f2 ]    test whether f1, f2 are the SAME file
#.........................................................

                   EXERCISES:

# MODIF
myread: read 1024 char from file descriptor 0
Y the above sh program to do these:

#1. Check whether f1 exists. If not, echo a message and exit;

#2. Check whether f2 exists.  
#      If f2 already exists:
#         echo a message:     OK to over-write f2 (y/n)?
#         read user's response by    read ANS
#         if $ANS = "y" ===> go on, else exit.

#3. Ask for a directory name (relative to user's $HOME)
#   DIR to do the copying. Then copy f1 to f2, all in that 
#   directory.

#   read DIR
#   cd $DIR  will cd to that directory
#   (cd $DIR; sh commands; .....)  ==> commands grouping
#                                   
#   Alternatively, you may stay in the current directory 
#   but generate the right file names from $1 and $2.
#   basename a/b/c/d  ====> d 
    
# ******************************************************

5-2. for statement in sh:

       for VARIABLE in string1 string2,...., stringn
         do
            commands
         done

   Examples:
      for FRUIT in  apple  orange  banana  cherry
        do
           echo $FRUIT     
myread: read 1024 char from file descriptor 0
===> apple  orange  banana  cherry 
        done 

      for NAME in $* 
        do
          echo $NAME      ==>  all command-line param strings
          if [ -f $NAME ]; then
             echo $NAME is a file
          fi
          if [ -d $NAME ]; then
             echo $NAME is a DIR
          fi
        done


5-3. while [ condition ]
       do
          commands
       done

  -------------------------------------------------------------------
                  Example:
   echo '$#' = $#         # echo the number of parameters 
   I=0                    # set I to "0" (STRING !!!!) 
   while [ $1 ]           # while $1 is not the empty string
   do
      echo $1             # echo current $1
      I=$(expr $I + 1)    # use expr to change I from "0" to "1"
      shift               # shift once, $2 becomes $1, $3 becomes $2, ... etc.
   done
          
   echo I = $I            # total number of parameters 
  --------------------------------------------------------------------

5-4 Other Flow-Control st
myread: read 1024 char from file descriptor 0
atements:

    until [ "$ANS" = "give up" ]
    do
        echo -n "enter your answer : "
        read ANS
    done
   
    case statement (SELF-STUDY)

5-5. break and continue statements:
     They work exactly the same as they do in C

6 sh Processing Steps:

  Assume:   A='$B'    B='new.*'    C=newdir
   For each command line, e,g,
        cp  $A `pwd`/$C
   sh evaluates the variables in the following order:

   (1). Parameter substitution: (only scan ONCE) ==>
        cp  $A `pwd`/$C          Replace $A, $C ===> becomes  
        cp  $B `pwd`/newdir      NOTE that $A is replaced only ONCE.
    
   (2). Command substitution:
        cp  $B `pwd`/newdir     Perform `pwd` ===>   becomes
        cp  $B /a/b/c/newdir    (assuming CWD=/a/b/c)

   (3). Blank Interpretation:
        Use the value of $IFS (usually space,tab and newline) to
        break up the chars into non-blank words. ==> 
        cp  $B /a/b/c/newdir    NO change here.
       
   (4). File name generation:
        Each word is scanned for file
myread: read 1024 char from file descriptor 0
 pattern characters *, ?, [..]
        to generate a list of filenames, which replace the word.

        cp  $B /a/b/c/newdir    There are no file pattern chars, so no change.
                                This is the final command to sh.
        ------------------------------------------------------------- 
                         
7. eval  is a sh built-in command, which is executed by sh itself without
   forking a new process.   Each  eval  evaluates the input string ONCE 
   and use the results as inputs to sh. 

   Example 1: Assume execution of do_it generates output lines
                   A=a\nB=b\nC=c\n

            Then,  eval $(do_it)

            generates A=a\nB=b\C=c\n as inputs to sh AS IF you have
            entered the lines
                               A=a  
                               B=b
                               C=c
            Thus, sh will set the variables A,B,C to a,b,c, respectively.
             
   Example 2: Assume: A='$B'     B='new.*'     C=newdir
            The
myread: read 1024 char from file descriptor 0
n    eval echo $A  ==> generates  
                         echo $B      to sh, resulting   ===>  new.*

   Now, consider this command:

        eval cp $A `pwd`/$C     ===> eval  first converts this to
             cp $B `pwd`/newdir ===> and uses this as inputs to sh.
   
   With these inputs, sh will do the substitutions of Steps (1) to (3).
   The command at Step (4) is

             cp new.* /a/b/c/newdir 

   Step 4 : The command line has a file wild-card char *.
            sh will replace the word  new.* by the filenames 
            new.X, new,Y,... (assuming they exist) and finally 
            executes

            cp new.X new.Y ...  /a/b/c/newdir

4. Within a pair of double quotes, parameter and command substituions occur 
   but blank interpretation and file name generation do not.
 
8. sh FUNCTIONS (by examples)
    --------------------------------------------------------
     # check_file() is a function, NOT the entry point

              check_file()     
              {
                loca
myread: read 1024 char from file descriptor 0
l A=localVariable    # A is local to this function

                if [ -f $1 ]; then
                   return 0
                fi
                return 1
              }

     # Here is the entry point of the program
     # Usage : thisFile  f1 f2  f3 ......

              for FILE in $*             # for FILE in $1 $2 ....
              do
                  check_file  $FILE      # call check_file() 
                  if [ $? = 0 ]          # returnCode == 0 ?
                     then
                         echo $FILE is a regular file
                     else
                         echo $FILE is not regular
                  fi
              done
     -------------------------------------------------------------

9. Utility Programs and sh Programming
   
   expr is a utility program. It is used as
        expr x Operator y
   It evaluates the the expression (x Operator y), where Operator is
   any valid operator in C, e.g.
         expr 3 + 5  ==>  8
         expr 3 \* 5 ==> 15   #NOTE: * must b
myread: read 1024 char from file descriptor 0
e quoted 
         expr 5 % 3  ==>  1   etc

   There are many utility programs, such as basename, grep, sed, cut, etc. 
   which are used so often that they have become almost an indispensible part 
   of sh programming. You are free to develop your own utility programs and,
   if they prove to be useful enough, include them in the Unix command set.
   Many Unix commands originated this way. As they say: Necessity is the
   Mother of all inventions.

   For example, suppose you want to have a myinc operator, which
   increments a sh (COUNTing) variable by one.  You may write it as

       main(int argc, char *argv[])
       {  
          int i = 0;
          if (argc > 1)
             i = atoi(argv[1]) + 1;;
          printf("%d",i);
       }

   Then, use myinc to replace  expr  for incrementing $I by 1.

10. I/O Redirection:

   When entering a sh command, we may instruct sh to re-direct I/O
   to files other than the default stdin, stdout, sterr. I/O redirections
   have the following form and meaning:
  
myread: read 1024 char from file descriptor 0
    -------------------------------------------------
      >  file   stdout goes to file, which will be created if non-existing.
      >> file   stdout append to file
      <  file   use file as stdin; file must exist and have r permission.
      << word   take inputs from "here" file until a line containing only 
                "word" is encountered. 
                Try these:
                ---------------------------------------------
                echo << END    
                  keep entering lines until a line with only
                  END
                --------------------------------------------
                cat << DONE
                  keep entering lines until
                DONE
                -------------------------------------------

      >&2      dup (see below) the fd=2 and use the result as stdout.

      <&3      dup fd=3 and use the result as stdin
      --------------------------------------------------
      A digit may preceed any of these to mean: use that fd instead 
myread: read 1024 char from file descriptor 0
of 
      stdin or stdout.  Examples:
                2> file           stderr to file
                2>> file          stderr append to file
                2>&1              dup 1 and use it as 2 ==> merge 1 and 2

8-1. dup and dup2 syscalls:

     int dup(int fd);
     
     dup() duplicates a file descriptor by creating a new fileDescriptor
     using the lowest fd number. It returns the new fd,  or -1 if failed.

     -------------------------------------------------------------      
     Example 1:  int fd = open("infile", 0);  /* open for READ */
                   close(0);    /* This frees fd[0]*/
                   dup(fd);     /* dup fd into fd[0] */

               /*** from here on stdin is the same as fd */
                   sscanf(FMT, &items);  will input from infile.

     ------------------------------------------------------------
     Example 2:  int gd = creat("outfile", 0644);
                     close(1);  /* this frees  fd[1] */
                     dup(gd);   /* dup gd into fd[1] 
myread: read 1024 char from file descriptor 0
*/
               /** from here on stdout is really gd ***/
                     printf("hello world\n");  will go to outfile.
     ------------------------------------------------------------

     int dup2(int old_fd, int new_fd);

         duplicates  old_fd  into  fd[new_fd].  It closes new_fd first, 
         if necessary.  dup2(gd, 0) is equivalent to  close(0); followed
         by  dup(gd);

     ------------------------------------------------------------
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                 HOWTO STAT_CD_LS_PWD

1. HOW TO stat:

   struct stat mystat; 
   char *pathname = "/a/b/c/d";
 
   r = do_stat(pathname, &mystat); 

int do_stat(char *pathname, struct stat *stPtr)
{
  1. Get inode of pathname into an MINODE:
         ino = getino(&dev, pathname); 
         mip = iget(dev, ino);          // iget() returns a pointer to minode[]
         
  3. Copy entries of INODE into stat struct;

     As you can see, everythi
myread: read 1024 char from file descriptor 0
ng needed by the stat struct is in MINODE.
     Write C statements to copy from mip->INODE to stPtr->fields.

       struct ext2_inode {
	i_mode;		/* File mode */
	i_uid;		/* Owner Uid */
	i_size;		/* Size in bytes */
	i_atime;	/* Access time */
	i_ctime;	/* Creation time */
	i_mtime;	/* Modification time */
	i_dtime;	/* Deletion Time */
	i_gid;		/* Group Id */
	i_links_count;	/* Links count */
	i_blocks;	/* Blocks count */
        .................................
        i_block[15];    // Allocated disk blocks 
      }

      struct stat {
        st_dev;      // dev
        st_ino;      // ino

        st_mode;     // i_mode
        st_nlink;    // i_links_count
        st_uid;      // i_uid
        st_gid;      // i_gid
        st_rdev;     // IGNORE THIS
        st_size;     // i_size
        st_blksize;  // 1024
        st_blocks;   // i_blocks
        st_atime;    // i_atime
        st_mtime;    // i_mtime
        st_ctime;    // i_ctime
      };

  4. Print the entries of the stat struct;
  5. iput(m
myread: read 1024 char from file descriptor 0
ip);      // dispose of the in memory inode; see NOTE below.
     return 0 for success;
}
============================================================================
NOTE: In general,   mip = iget(dev, ino); and
                          iput(mip);
      should occur in pairs, with only a few exceptions:

       cd()   : iget(new CWD) but iput(old CWD)
       open() : iget() but close() does iput().
       mount(): iget() but umount() does input().
============================================================================
2. HOW TO ls:

int do_ls(char *pathname) 
{
 
  1. If pathname==NULL, ls CWD.

  2. YOU MAY USE do_stat() OR work on the INODE of pathname directly.
  
  3. In either case, USE YOUR myls LAB program here.

  4. return 0 for SUCCESS

}


3. HOW TO cd:

int do_cd(char *pathname)
{
  1. if pathname==NULL ==> cd to root (default HOME dir) AS SHOWN:

     if (pathname[0] == 0){
        iput(rnning->cwd);                 // dispose of CWD
        running->cwd = iget(rootdev, 2);   // OR running
myread: read 1024 char from file descriptor 0
->cwd = root; 
                                           //    root->refCount++;
        return 0;
     }
     

  2. Get INODE of pathname into a MINODE:
         ino = getino(&dev, pathname);     // return BAD if ino==0

  3. Get inode into an MINODE slot.
         mip = iget(dev, ino);

  4. Check DIR type ==> if NOT DIR: 
                           iput(mip); YELL at user; return BAD;

  5. Dispose of original running->cwd (by iput(running->cwd) ); 
     Change running->cwd to point at this Minode in memroy;
     return 0 for OK;
}


3. HOW TO pwd:

int do_pwd()
{ pwd(running->CWD); }

pwd(wd) MINODE *wd;
{ 
   Write this function as a recursive fucnction, which

   1. if wd is already the root:
         print /; return;

   2. Get parent's MINODE pointer wd; 
          (HOW? get i_block[0]; then iget(dev, ino of ..))
      Call pwd(wd) again with parent's MINODE pointer;

   3. Print wd's name followed by a /;
          (HOW TO get the name string of a MINODE?)

          2 ways: if you recorded the pat
myread: read 1024 char from file descriptor 0
hname of a file in its MINODE,
                  then it's the basename() of that string.
          OR    : You have this guy's ino and its parent's MINODE.
                  Search the parent DIR for an entry with this ino. Then, you
                  have its name. I PREFER THIS method !!!

   4. FOR LEVEL-3: If you implement MOUNTing, make sure your recursion can
                     cross mounting points.
}


<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #7</H1>

<Pre>

         360 Notes #7 System Calls for File Operations

1. What are syscalls?

   Syscall is a mechanism that allows a process to enter Kernel mode to 
   perform operations not allowed in User mode. Operations such as open files,
   read/write files, fork, exec, even termination, must all be done in Kernel.
   In this set of notes, we shall focus on Unix syscalls for file operations.
   
2. Where to find these information:

   Under Linux, the man pages of all syscalls are listed in /usr/man/man2/.
myread: read 1024 char from file descriptor 0

   The Unix command man 2 NAME displays the man pages of NAME in man2/. 
   Similarly, man 8 mkfs displays the man pages of mkfs in /usr/man/man8/. 

   DO: practice using man to read Linux's man pages.
 
3. How to use these functions?

   Include them in your C program, just like ordinary function calls. A return 
   value >=0 means OK, -1 means BAD. An implicitly defined global int variable,
   errno, records the error code.  Each error code number has a corresponding
   string description, as the following program shows.

            #include &lterrno.h&gt
            main()
            {
              if (mkdir("newdir", 0777) < 0){
                 printf("errno=%d : %s\n", errno, strerror(errno));
              }
            }

    If you run the program twice, the second time it will print
                   errno=17 : File exists
    as it should.
    ************************************************************** 
                 EXERCISES: (Some already in LAB#2)
       Write a C program to test : 
myread: read 1024 char from file descriptor 0
 
               mkdir, rmdir, chdir, creat, unlink, rename, chmod
    **************************************************************

4. READ and LEARN how to use these syscalls on your own:

   access : check user's permissions for a file : R_OK,W_OK,X_OK,F_OK. 
            int access(const char *pathname, int mode);

   chdir  : change directory
            int chdir(const char *path);

   chmod  : change permissions of a file
            int chmod(const char *path, mode_t mode);

   OTHERS : chown, chroot, setuid


   mkdir  : create a directory
            int mkdir(const char *pathname, mode_t mode);

   rmdir  : remove a directory (must be empty)
            int rmdir(const char *pathname);

   link   : make a new name for a file
            int link(const char *oldpath, const char *newpath);


   unlink : delete a name and possibly the file it refers to
            int unlink(const char *pathname);

   symlink: create a symbolic link for a file
            int symlink(const char *oldpath, const char *
myread: read 1024 char from file descriptor 0
newpath);

   rename : change the name of a file
            int rename(const char *oldpath, const char *newpath);
  
                       SPECIAL ONES:

   mount  : int  mount(const  char  *specialfile, const char * dir , 
                       const char *filesystemtype, unsigned long mountflags , 
                       const void * data);

   umount : int umount(const char *dir);

   mknod  : make special files, e.g.  mknod /dev/fd2 b 2 2


5. To be covered in details in class:

      open, creat, umask
      read, write, lseek
      close

      opendir : DIR *opendir(const char *name);
      readdir : int readdir(unsigned int fd, struct dirent *dirp, unsigned int count);
      readlink: int readlink(const char *path, char *buf, size_t bufsiz);

      stat :  int stat(const char *file_name, struct stat *buf);
              int fstat(int filedes, struct stat *buf);
              int lstat(const char *file_name, struct stat *buf);


6. The stat Systen Call

6-1. Link Files:
   In Unix, every file has a 
myread: read 1024 char from file descriptor 0
pathname, such as /a/b/c. However, Unix allows 
different pathnames to represent the same file. These are known as LINK files.
There are two kinds of LINKs, HARD link and SOFT link. 

HARD Links: 
     The command    ln  oldpath  newpath 

creates a HARD link from newpath to oldpath. The corresponding syscall is

          link(char *oldpath, char *newpath)

NOTE: Hard links can only be applied to non-DIR files. 
      (What would happen if DIRs could  be hard linked ?) 

Hard linked files share the same inode, whose nlink field records the number of
hard links to the inode. Converse to link, the syscall
 
        unlink(char *pathname)

finds the inode of pathname and decrements its nlink by 1. The file is truly 
removed only if nlink becomes 0. This is what the rm command does.
    
SOFT Links:  
     The command   ln -s  oldpath newpath  

creates a SOFT or Symbolic link from newpath to oldpath. The corresponding
syscall is 
             symlink(char *oldpath, char *newpath)

The newpath is (almost a regul
myread: read 1024 char from file descriptor 0
ar) file, which contains the oldpath string. It
acts like a detour road sign, which directs the traffic to the real destination
(oldpath). Unlike hard links, soft links can be applied to any file, such as

             ln -s   aVeryLongPathname                 a
             ln -s   aFileWhichMayBeChangedOften       b

One drawback of soft link is that the target file may NOT exist. If so, the
detour would direct the poor driver to fall off a cliff. In Linux, such death
traps are displayed in (the appropriate color of) RED under the ls -l command.

Also, if foo -> /a/b/c is a soft link file, the open("foo", 0) syscall, as 
implemented, will open the target file /a/b/c, not the link file foo itself. 
So, the open()/read() syscalls would NOT read any soft link file. Instead, the
syscall, readlink(), must be used to read the contents of a soft link file. 

 
A Brief Summary about Links:
           Command                               Syscall used
  ===============================================================
myread: read 1024 char from file descriptor 0
========
    ln     oldpath newpath             link(char *oldpath, char *newpath)
    ln -s  oldpath newpath          symlink(char *oldpath, char *newpath)
  =======================================================================

6-2. File Status:
   Every file has a UNIQUE inode, whcih contain ALL the information about the
file. The syscalls, stat/lstat/fstat, return the info of a file. (

9-2-1. INODE:
     Every file is represented by a unique INODE data strucutre, which is shown
here for reference.:

struct ext2_inode {
  unsigned short i_mode;
  unsigned short i_uid;
  unsigned long  i_size;
  unsigned long  i_atime;
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;
  unsigned short i_links_count;
  unsigned long  i_blocks;
  unsigned long  i_flags;
  unsigned long  i_reserved1;
  unsigned long  i_block[15];
  // several other unimportant fields
};

6-2.2  The man pages of stat:
    Use  man stat  to read the man pages of the stat system call, which i
myread: read 1024 char from file descriptor 0
s 
shown below.
=============================================================================
STAT(2)                    System calls                   STAT(2)

NAME
       stat, fstat, lstat - get file status

SYNOPSIS
       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;unistd.h&gt;

       int stat(const char *file_name, struct stat *buf);
       int fstat(int filedes, struct stat *buf);
       int lstat(const char *file_name, struct stat *buf);

DESCRIPTION
       These  functions  return  information  about the specified
       file.  You do not need any access rights to  the  file  to
       get  this  information  but  you need search rights to all
       directories named in the path leading to the file.

       stat stats the file pointed to by file_name and  fills  in
       buf.

       lstat  is  identical to stat, except in the case of a sym-
       bolic link, where the link itself is stat-ed, not the file
       that it refers to.

       fstat  is identica
myread: read 1024 char from file descriptor 0
l to stat, only the open file pointed to
       by filedes (as returned by open(2)) is stated in place  of
       file_name.


       They  all return a stat structure, which contains the fol-
       lowing fields:

            struct stat {
                dev_t         st_dev;      /* device */
                ino_t         st_ino;      /* inode */
                mode_t        st_mode;     /* protection */
                nlink_t       st_nlink;    /* number of hard links */
                uid_t         st_uid;      /* user ID of owner */
                gid_t         st_gid;      /* group ID of owner */
                dev_t         st_rdev;     /* device type (if inode device) */
                off_t         st_size;     /* total size, in bytes */
                unsigned long st_blksize;  /* blocksize for filesystem I/O */
                unsigned long st_blocks;   /* number of blocks allocated */
                time_t        st_atime;    /* time of last access */
                time_t        st_mti
myread: read 1024 char from file descriptor 0
me;    /* time of last modification */
                time_t        st_ctime;    /* time of last change */
            };

       The value st_size gives the size of the file (if it  is  a
       regular file or a symlink) in bytes. The size of a symlink
       is the length of the pathname it contains, without  trail-
       ing NULL.

       The value st_blocks gives the size of the file in 512-byte
       blocks.  (This may be smaller than st_size/512  e.g.  when
       the file has holes.)  The value st_blksize gives the "pre-
       ferred" blocksize for efficient file system I/O.  (Writing
       to a file in smaller chunks may cause an inefficient read-
       modify-rewrite.)

       Not all of the Linux filesystems implement all of the time
       fields.   Some  file system types allow mounting in such a
       way that file accesses do  not  cause  an  update  of  the
       st_atime field. (See `noatime' in mount(8).)

       The  field  st_atime  is changed by file accesses, e.g. by
       exec(
myread: read 1024 char from file descriptor 0
2), mknod(2), pipe(2), utime(2) and read(2) (of  more
       than zero bytes). Other routines, like mmap(2), may or may
       not update st_atime.

       The field st_mtime is changed by file modifications,  e.g.
       by  mknod(2),  truncate(2), utime(2) and write(2) (of more
       than zero bytes).  Moreover, st_mtime of  a  directory  is
       changed  by  the  creation  or  deletion  of files in that
       directory.  The st_mtime field is not changed for  changes
       in owner, group, hard link count, or mode.

       The  field  st_ctime  is  changed by writing or by setting
       inode information (i.e., owner, group, link  count,  mode,
       etc.).

       The  following  POSIX macros are defined to check the file
       type:

              S_ISREG(m)  is it a regular file?

              S_ISDIR(m)  directory?

              S_ISCHR(m)  character device?

              S_ISBLK(m)  block device?

              S_ISFIFO(m) fifo?

              S_ISLNK(m)  symbolic link? (Not in POSIX.1-1996
myread: read 1024 char from file descriptor 0
.)

              S_ISSOCK(m) socket? (Not in POSIX.1-1996.)

       The following flags are defined for the st_mode field:

       S_IFMT     0170000   bitmask for the file type bitfields
       S_IFSOCK   0140000   socket
       S_IFLNK    0120000   symbolic link
       S_IFREG    0100000   regular file
       S_IFBLK    0060000   block device
       S_IFDIR    0040000   directory
       S_IFCHR    0020000   character device
       S_IFIFO    0010000   fifo

       S_ISUID    0004000   set UID bit
       S_ISGID    0002000   set GID bit (see below)
       S_ISVTX    0001000   sticky bit (see below)

       S_IRWXU    00700     mask for file owner permissions
       S_IRUSR    00400     owner has read permission
       S_IWUSR    00200     owner has write permission
       S_IXUSR    00100     owner has execute permission
       S_IRWXG    00070     mask for group permissions
       S_IRGRP    00040     group has read permission
       S_IWGRP    00020     group has write permission
       S_IXGRP    00010  
myread: read 1024 char from file descriptor 0
   group has execute permission
       S_IRWXO    00007     mask for permissions for others (not in group)
       S_IROTH    00004     others have read permission
       S_IWOTH    00002     others have write permisson
       S_IXOTH    00001     others have execute permission

RETURN VALUE
       On success, zero is returned.  On error, -1  is  returned,
       and errno is set appropriately.


SEE ALSO
       chmod(2), chown(2), readlink(2), utime(2)
=============================================================================

6-2.3 File Type and Permissions:
    Among the fileds of the stat structure, only the st_mode field needs
    some explanation:

       mode_t        st_mode;     /* copied from i_mode of INODE */

    The TYPE of st_mode is unsigned short (2 bytes or 16 bits). 
    The 16 bits have the following meaning:

       |Type|   |permissions|
       ----------------------
       |tttt|fff|uuu|ggg|ooo| 
       ----------------------

    The leading 4 bits are file types, which can be interp
myread: read 1024 char from file descriptor 0
reted as (Octals)

       S_IFMT     0170000   bitmask for the file type bitfields
       S_IFSOCK   0140000   socket
       S_IFLNK    0120000   symbolic link
       S_IFREG    0100000   regular file
       S_IFBLK    0060000   block device
       S_IFDIR    0040000   directory
       S_IFCHR    0020000   character device
       S_IFIFO    0010000   fifo
 
    The next 3 bits are flags, which indicate special usage of the file 

       S_ISUID    0004000   set UID bit
       S_ISGID    0002000   set GID bit 
       S_ISVTX    0001000   sticky bit 

    The remaining 9 bits are PERMISSION bits for file protection:

        owner  group  other
         rwx    rwx    rwx
    
    By interpreting these bits, YOU may disaplay the st_mode field as
       -rwxr-xr-x             (REG file) 
       drwxr-xr-x             (DIR)
       lrw-r--r--             (LNK file)

==============================================================================
6-3. HOW TO read DIR Entries:
   Read the man pages of   
            op
myread: read 1024 char from file descriptor 0
endir, readdir, readlink  
to learn how to use these syscalls to open a DIR file for read, and then read 
the contents of a DIR file (as DIR entry strings). Alos, learn how to read the
contents of a (soft) LNK file itself.
<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>type.h for Project</H1>

<Pre>

/*	type.h for CS360 Project             */

#include &lt stdio.h >
#include &lt fcntl.h>
#include &lt linux/ext2_fs.h>
#include &lt libgen.h>
#include &lt string.h>
#include &lt sys/stat.h>

// define shorter TYPES, save typing efforts
typedef struct ext2_group_desc  GD;
typedef struct ext2_super_block SUPER;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

#define BLOCK_SIZE        1024
#define BITS_PER_BLOCK    (8*BLOCK_SIZE)
#define INODES_PER_BLOCK  (BLOCK_SIZE/sizeof(INODE))

// Block number of EXT2 FS on FD
#define SUPERBLOCK        1
#define GDBLOCK           2
#de
myread: read 1024 char from file descriptor 0
fine BBITMAP           3
#define IBITMAP           4
#define INODEBLOCK        5
#define ROOT_INODE        2

// Default dir and regulsr file modes
#define DIR_MODE          0040777 
#define FILE_MODE         0100644
#define SUPER_MAGIC       0xEF53
#define SUPER_USER        0

// Proc status
#define FREE              0
#define BUSY              1
#define KILLED            2

// Table sizes
#define NMINODES          50
#define NMOUNT            10
#define NPROC             10
#define NFD               10
#define NOFT              50

// Open File Table
typedef struct Oft{
  int   mode;
  int   refCount;
  struct Minode *inodeptr;
  long  offset;
} OFT;

// PROC structure
typedef struct Proc{
  int   uid;
  int   pid;
  int   gid;
  int   ppid;
  struct Proc *parent;
  int   status;

  struct Minode *cwd;
  OFT   *fd[NFD];
} PROC;
      
// In-memory inodes structure
typedef struct Minode{		
  INODE    INODE;               // disk inode
  ushort   dev;
  unsigned long ino;
  ushort   refCount;
  ushort   dirty
myread: read 1024 char from file descriptor 0
;
  ushort   mounted;
  struct Mount *mountptr;
  char     name[128];           // name string of file
} MINODE;

// Mount Table structure
typedef struct Mount{
        int    ninodes;
        int    nblocks;
        int    dev, busy;   
        struct Minode *mounted_inode;
        char   name[256]; 
        char   mount_name[64];
} MOUNT;
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HOWTO #3</H1>

<Pre>
   The util.c file contains utility functions that are needed by most other  
   functions.  It is suggested that you implement the following.

1. get_block(dev, blk, buf) 
   put_block(dev, blk, buf)    These require no explanation.


2. token_path(char *pathname)
{
  This function breaks up a pathname, such as /a/b/c/d, into components
  a   b   c   d  and  determines the number of components n.
  The components will be used to search for the inode of pathname. 
}


3. dirname() and basename():
   Use these functions to divide a pathname into dirname and basename
myread: read 1024 char from file descriptor 0

   NOTE: They are in clib but both functions destroy the parameter string
  
4. unsigned long getino(int *dev, char *pathname)
{
  This is the most important function of the project. It converts
  a pathname, such as /a/b/c/d OR x/y/z, into its (dev, inumber), i.e. 
  the returned value is its inumber and dev is its dev number. 

  NOTE: while traversing a pathname, the starting dev number is the dev of / 
  OR the dev of (running's) CWD. If you have only one device, the dev number 
  will not change. But when crossing MOUNTed file systems (for Level-3), the
  dev number may change. The dev parameter is used to keep the CURRENT dev 
  number.

  This function depends on search(), which searches an DIR's data block for 
  a component name, and returns the component's inmuber. Modify *dev if the
  dev number changes.
  
  You have already done these in showblock.c
}   

5. unsigned long search(MINODE *mip, char *name)
{
   This function searches the data blocks of a DIR inode (inside an Minode[])
   for name. 
myread: read 1024 char from file descriptor 0
You may assume DIRECT data blocks only.
}


6. MINODE *iget(int dev, unsigned long ino)
{
  Once you have the (dev, ino) of an inode, you may load the inode into a slot
  in the Minode[] array. To ensure uniqueness, you must search the Minode[] 
  array to see whether the needed INODE is already loaded.

  If you find the needed INODE already in a Minode[] slot, just inc its 
  refCount by 1 and return the Minode[] pointer.

  If you do not find it in memory, you must allocate a FREE Minode[i], load
  the INODE from disk into that Minode[i].INODE, initialize the Minode[]'s
  other fields and return its address as a MINODE pointer,
}


7. iput(MINODE *mip)
{
  This function releases a Minode[]. Since an Minode[]'s refCount indicates
  the number of users on this Minode[], releasing is done as follows:
    First, dec the refCount by 1. If (after dec) refCount > 0 ==> return;
    else:
      if Minode[].dirty == 0 ==> no need to write back, so return;
      Otherwise, (dirty==1) ==> must write the INODE back to 
myread: read 1024 char from file descriptor 0
disk.
   
  To write an INODE back to disk:
     Use Minode's (dev, ino) to determine which dev and which INODE on disk,
  i.e. which disk block and which inode in that block.
  Read that block in, copy Minode's INODE into the INODE area in that block
  and write the block back to disk.
} 


8. int findmyname(MINODE *parent, unsigned long myino, char *myname) 
{
   Given the parent DIR (MINODE pointer) and my inumber, this function finds 
   the name string of myino in the parent's data block. This is similar to 
   SERACH() mentioned above.
}


9. int findino(MINODE *mip; unsigned long *myino, *parentino)
{
  For a DIR Minode, extract the inumbers of . and .. 
  Read in 0th data block. The inumbers are in the first two dir entries.
}
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                     HOWTO write    

int write_file()
{
  1. Preprations:
     ask for a fd   and   a text string to write.

  2. verify fd is indeed opened for W or RW or 
myread: read 1024 char from file descriptor 0
APPEND mode

  3. copy the text string into a buf[] and get its length as nbytes.

     return(mywrite(fd, buf, nbytes));
}



// mywrite behaves exactly the same as Unix's write(fd, buf, nbytes) syscall.
// it writes nbytes from buf[] to the file fd

int mywrite(int fd, char *buf, int nbytes) 
{
  while (nbytes > 0 ){

     compute LOGICAL BLOCK (lbk) and the startByte in that lbk:
          lbk       = oftp->offset / BLOCK_SIZE;
          startByte = oftp->offset % BLOCK_SIZE;

    // I only show how to write DIRECT data blocks, you figure out how to 
    // write indirect and double-indirect blocks.

     if (lbk < 12){                         // direct block
        if (ip->INODE.i_block[lbk] == 0)    // if no data block yet
            mip->INODE.i_block[lbk] = balloc(mip->dev);
        blk = mip->INODE.i_block[lbk];
     }
     else if (lbk >= 12 && lbk < 256 + 12){ 
            // indirect blocks
     }
     else{
            // double indirect blocks */
     }

     /* all cases come to here : write t
myread: read 1024 char from file descriptor 0
o the data block */
     get_block(mip->dev, blk, wbuf);   // read disk block into wbuf[ ]  
     char *cp = wbuf + startByte;      // cp points at startByte in wbuf[]
     remain = BLOCK_SIZE - startByte;  // number of bytes remain in this block

     while (remain > 0){               // write as much as remain allows  
           *cp++ = *cq++;              // cq points at buf[ ]
           nbytes--; remain--;         // dec counts
           oftp->offset++;             // advance offset
           if (offset > i_size)        // especially for RW|APPEND mode
               mip->INODE.i_size++;    // inc file size (if offset>filesize)
           if (nbytes <= 0) break;     // if already nbytes, break
     }
     put_block(mip->dev, blk, wbuf);   // write wbuf[ ] to disk
     
     // loop back to while to write more .... until nbytes are written
  }

  mip->dirty = 1;       // mark mip dirty for iput() 
  show ("wrote %d char into file fd=%d\n", nbytes, fd);           
  return nbytes;
}

=============== END
myread: read 30 char from file descriptor 0
 OF huge FILE ===============

myread: read 0 char from file descriptor 0
cat 442398 bytes
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : head small
pathname=small parameter=

myread: read 1024 char from file descriptor 0
                   LAB2 Check List

Use YOUR C program source file in the tests.

// Simple commands
ls -a -l                       : show the ls results of CWD
cat file                       : show file contents

// Choose gedit OR nano OR vi OR emacs as the EDITOR
EDITOR file                    : show you can edit the file
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : tail small
pathname=small parameter=

myread: read 1024 char from file descriptor 0

 P1:                 show P1 childList as P2->P3->P4
 P1: wait        ==> find ZOMBIE P2 and put it into freeList
     wait        ==> P1 should sleep in wait(), until a child becomes ZOMBIE
                    (P1 sleeps, not runable, so switch to P3)
		  
 P3: exit        ==> wakeup P1, which will FREE the ZOMBIE P3.

sample solution: ~samples/LAB2pre/solution	       

========== END OF small FILE =============
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : cp large newlarge
pathname=large parameter=newlarge
ialloc : ino=11
balloc : bno=277
ino = 11 bno = 277
new file = [3 11]

myread: read 1024 char from file descriptor 0
balloc : bno=278
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=279
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=280
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=281
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=282
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=283
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=284
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=285
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=286
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=287
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=288
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=293
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=294
balloc : bno=295
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=296
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=297
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=298
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=299
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=300
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=301
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=302
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=303
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=304
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=305
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=306
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=307
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=308
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=309
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=310
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=311
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=312
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=313
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=314
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=315
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=316
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=317
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=318
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=319
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=320
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=353
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=354
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=355
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=356
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=357
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=358
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=359
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=360
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=361
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=362
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=363
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=364
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=365
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=366
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=367
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=368
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=513
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=514
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=515
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=516
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=517
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=518
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=519
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=520
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=521
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=522
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=523
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=524
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=525
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=526
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=527
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=528
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=529
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=530
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=531
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=532
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=533
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=534
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=535
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=536
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=537
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=538
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=539
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=540
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=541
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=542
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=543
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=544
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=545
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=546
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=547
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=548
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=549
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=550
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=551
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=552
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=553
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=554
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=555
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=556
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=557
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=558
wrote 1024 char into file descriptor fd = 1

myread: read 23 char from file descriptor 0
balloc : bno=559
wrote 23 char into file descriptor fd = 1

myread: read 0 char from file descriptor 0
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : ls
pathname= parameter=
i_block[0] = 276
drwxr-xr-x   2    0    0  Thu Apr 13 09:59:55 2023     1024        .	[3 2]
drwxr-xr-x   2    0    0  Thu Apr 13 09:59:55 2023     1024       ..	[3 2]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023        0    file1	[3 12]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023   442398     huge	[3 13]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023   102423    large	[3 14]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023     3297    small	[3 15]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023      104     tiny	[3 16]
-rw-r--r--   1    0    0  Wed Apr 26 23:55:23 2023   102423 newlarge	[3 11]
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : cp huge newhuge
pathname=huge parameter=newhuge
ialloc : ino=17
balloc : bno=560
ino = 17 bno = 560
new file = [3 17]

myread: read 1024 char from file descriptor 0
balloc : bno=561
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=562
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=563
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=564
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=565
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=566
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=567
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=568
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=569
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=570
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=571
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=572
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=573
balloc : bno=574
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=575
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=576
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=577
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=578
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=579
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=580
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=581
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=582
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=583
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=584
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=585
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=586
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=587
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=588
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=589
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=590
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=591
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=592
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=593
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=594
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=595
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=596
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=597
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=598
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=599
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=600
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=601
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=602
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=603
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=604
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=605
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=606
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=607
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=608
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=609
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=610
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=611
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=612
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=613
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=614
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=615
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=616
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=617
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=618
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=619
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=620
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=621
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=622
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=623
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=624
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=625
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=626
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=627
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=628
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=629
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=630
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=631
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=632
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=633
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=634
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=635
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=636
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=637
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=638
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=639
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=640
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=819
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=820
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=821
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=822
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=823
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=824
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=825
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=826
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=827
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=828
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=829
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=830
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=831
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=832
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=833
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=834
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=835
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=836
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=837
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=838
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=839
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=840
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=841
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=842
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=843
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=844
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=845
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=846
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=847
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=848
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=849
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=850
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=851
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=852
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=853
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=854
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=855
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=856
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=857
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=858
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=859
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=860
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=861
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=862
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=863
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=864
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=865
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=866
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=867
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=868
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=869
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=870
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=871
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=872
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=873
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=874
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=875
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=876
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=877
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=878
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=879
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=880
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=881
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=882
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=883
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=884
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=885
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=886
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=887
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=888
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=889
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=890
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=891
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=892
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=893
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=894
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=895
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=896
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=897
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=898
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=899
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=900
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=901
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=902
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=903
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=904
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=905
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=906
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=907
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=908
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=909
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=910
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=911
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=912
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=913
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=914
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=915
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=916
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=917
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=918
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=919
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=920
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=921
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=922
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=923
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=924
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=925
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=926
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=927
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=928
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=929
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=930
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=931
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=932
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=933
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=934
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=935
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=936
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=937
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=938
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=939
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=940
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=941
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=942
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=943
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=944
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=945
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=946
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=947
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=948
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=949
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=950
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=951
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=952
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=953
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=954
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=955
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=956
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=957
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=958
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=959
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=960
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=961
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=962
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=963
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=964
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=965
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=966
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=967
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=968
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=969
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=970
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=971
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=972
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=973
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=974
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=975
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=976
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=977
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=978
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=979
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=980
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=981
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=982
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=983
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=984
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=985
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=986
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=987
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=988
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=989
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=990
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=991
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=992
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=993
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=994
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=995
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=996
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=997
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=998
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=999
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1000
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1001
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1002
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1003
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1004
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1005
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1006
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1007
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1008
balloc : bno=1009
balloc : bno=1010
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1011
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1012
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1013
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1014
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1015
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1016
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1017
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1018
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1019
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1020
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1021
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1022
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1023
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1024
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1025
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1026
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1027
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1028
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1029
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1030
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1031
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1032
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1033
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1034
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1035
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1036
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1037
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1038
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1039
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1040
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1041
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1042
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1043
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1044
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1045
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1046
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1047
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1048
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1049
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1050
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1051
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1052
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1053
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1054
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1055
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1056
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1057
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1058
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1059
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1060
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1061
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1062
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1063
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1064
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1065
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1066
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1067
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1068
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1069
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1070
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1071
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1072
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1073
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1074
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1075
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1076
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1077
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1078
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1079
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1080
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1081
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1082
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1083
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1084
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1085
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1086
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1087
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1088
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1089
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1090
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1091
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1092
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1093
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1094
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1095
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1096
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1097
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1098
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1099
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1100
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1101
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1102
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1103
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1104
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1105
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1106
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1107
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1108
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1109
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1110
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1111
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1112
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1113
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1114
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1115
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1116
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1117
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1118
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1119
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1120
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1121
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1122
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1123
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1124
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1125
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1126
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1127
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1128
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1129
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1130
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1131
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1132
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1133
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1134
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1135
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1136
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1137
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1138
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1139
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1140
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1141
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1142
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1143
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1144
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1145
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1146
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1147
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1148
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1149
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1150
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1151
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1152
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1153
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1154
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1155
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1156
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1157
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1158
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1159
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1160
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1161
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1162
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1163
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1164
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1165
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1166
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1167
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1168
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1169
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1170
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1171
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1172
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
balloc : bno=1173
wrote 1024 char into file descriptor fd = 1

myread: read 30 char from file descriptor 0
balloc : bno=1174
wrote 30 char into file descriptor fd = 1

myread: read 0 char from file descriptor 0
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : ls
pathname= parameter=
i_block[0] = 276
drwxr-xr-x   2    0    0  Thu Apr 13 09:59:55 2023     1024        .	[3 2]
drwxr-xr-x   2    0    0  Thu Apr 13 09:59:55 2023     1024       ..	[3 2]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023        0    file1	[3 12]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023   442398     huge	[3 13]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023   102423    large	[3 14]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023     3297    small	[3 15]
-rw-r--r--   1    0    0  Thu Apr 13 09:59:55 2023      104     tiny	[3 16]
-rw-r--r--   1    0    0  Wed Apr 26 23:55:23 2023   102423 newlarge	[3 11]
-rw-r--r--   1    0    0  Wed Apr 26 23:55:28 2023   442398  newhuge	[3 17]
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : cp large newlarge
pathname=large parameter=newlarge
deallocate direct blocks
278 279 280 281 282 283 284 285 286 287 288 293 
------------------------------

deallocate indirect blocks: block = 294
295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 
------------------------------


myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 1024 char from file descriptor 0
wrote 1024 char into file descriptor fd = 1

myread: read 23 char from file descriptor 0
wrote 23 char into file descriptor fd = 1

myread: read 0 char from file descriptor 0
P1 running
enter command [ls|open|close|pfd|read|write|cat|cp|head|tail] : exit
pathname= parameter=

Linux head /mnt/small
--------------------------
                   LAB2 Check List

Use YOUR C program source file in the tests.

// Simple commands
ls -a -l                       : show the ls results of CWD
cat file                       : show file contents

// Choose gedit OR nano OR vi OR emacs as the EDITOR
EDITOR file                    : show you can edit the file
--------------------------
Linux tail /mnt/small
--------------------------
 P1:                 show P1 childList as P2->P3->P4
 P1: wait        ==> find ZOMBIE P2 and put it into freeList
     wait        ==> P1 should sleep in wait(), until a child becomes ZOMBIE
                    (P1 sleeps, not runable, so switch to P3)
		  
 P3: exit        ==> wakeup P1, which will FREE the ZOMBIE P3.

sample solution: ~samples/LAB2pre/solution	       

========== END OF small FILE =============
--------------------------

